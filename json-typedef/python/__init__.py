# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class RulesPackage:
    """
    Describes game rules compatible with the Ironsworn tabletop role-playing
    game by Shawn Tomkin.
    """

    type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackage':
        variants: Dict[str, Type[RulesPackage]] = {
            "expansion": RulesPackageExpansion,
            "ruleset": RulesPackageRuleset,
        }

        return variants[data["type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class RulesPackageExpansionDataswornVersion(Enum):
    """
    The version of the Datasworn format used by this data.
    """

    DEFAULT_NAME = "0.1.0"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageExpansionDataswornVersion':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class RulesPackageExpansion(RulesPackage):
    """
    A Datasworn package that relies on an external package to provide its
    ruleset.
    """

    id: 'ExpansionID'
    assets: 'Dict[str, AssetCollection]'
    """
    A dictionary object containing asset collections, which contain assets.
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    datasworn_version: 'RulesPackageExpansionDataswornVersion'
    """
    The version of the Datasworn format used by this data.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'WebURL'
    moves: 'Dict[str, MoveCategory]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    oracles: 'Dict[str, OracleTablesCollection]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    ruleset: 'RulesetID'
    title: 'Label'
    """
    The title of the source document.
    """

    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    atlas: 'Optional[Dict[str, AtlasCollection]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    description: 'Optional[MarkdownString]'
    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    rules: 'Optional[RulesExpansion]'
    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageExpansion':
        return cls(
            "expansion",
            _from_json_data(ExpansionID, data.get("_id")),
            _from_json_data(Dict[str, AssetCollection], data.get("assets")),
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(RulesPackageExpansionDataswornVersion, data.get("datasworn_version")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(WebURL, data.get("license")),
            _from_json_data(Dict[str, MoveCategory], data.get("moves")),
            _from_json_data(Dict[str, OracleTablesCollection], data.get("oracles")),
            _from_json_data(RulesetID, data.get("ruleset")),
            _from_json_data(Label, data.get("title")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[Dict[str, AtlasCollection]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[RulesExpansion], data.get("rules")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "expansion" }
        data["_id"] = _to_json_data(self.id)
        data["assets"] = _to_json_data(self.assets)
        data["authors"] = _to_json_data(self.authors)
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["moves"] = _to_json_data(self.moves)
        data["oracles"] = _to_json_data(self.oracles)
        data["ruleset"] = _to_json_data(self.ruleset)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.rules is not None:
             data["rules"] = _to_json_data(self.rules)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

class RulesPackageRulesetDataswornVersion(Enum):
    """
    The version of the Datasworn format used by this data.
    """

    DEFAULT_NAME = "0.1.0"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageRulesetDataswornVersion':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class RulesPackageRuleset(RulesPackage):
    """
    A standalone Datasworn package that describes its own ruleset.
    """

    id: 'RulesetID'
    assets: 'Dict[str, AssetCollection]'
    """
    A dictionary object containing asset collections, which contain assets.
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    datasworn_version: 'RulesPackageRulesetDataswornVersion'
    """
    The version of the Datasworn format used by this data.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'WebURL'
    moves: 'Dict[str, MoveCategory]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    oracles: 'Dict[str, OracleTablesCollection]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    rules: 'Rules'
    title: 'Label'
    """
    The title of the source document.
    """

    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    atlas: 'Optional[Dict[str, AtlasCollection]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    description: 'Optional[MarkdownString]'
    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageRuleset':
        return cls(
            "ruleset",
            _from_json_data(RulesetID, data.get("_id")),
            _from_json_data(Dict[str, AssetCollection], data.get("assets")),
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(RulesPackageRulesetDataswornVersion, data.get("datasworn_version")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(WebURL, data.get("license")),
            _from_json_data(Dict[str, MoveCategory], data.get("moves")),
            _from_json_data(Dict[str, OracleTablesCollection], data.get("oracles")),
            _from_json_data(Rules, data.get("rules")),
            _from_json_data(Label, data.get("title")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[Dict[str, AtlasCollection]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "ruleset" }
        data["_id"] = _to_json_data(self.id)
        data["assets"] = _to_json_data(self.assets)
        data["authors"] = _to_json_data(self.authors)
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["moves"] = _to_json_data(self.moves)
        data["oracles"] = _to_json_data(self.oracles)
        data["rules"] = _to_json_data(self.rules)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

class ActionRollMethod(Enum):
    ALL = "all"
    """
    Use _every_ roll option at once.
    """

    HIGHEST = "highest"
    """
    Use the roll option with the best/highest value.
    """

    LOWEST = "lowest"
    """
    Use the roll option with the worst/lowest value.
    """

    MISS = "miss"
    """
    An automatic miss.
    """

    PLAYER_CHOICE = "player_choice"
    """
    The player chooses which roll option to use.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ActionRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AnyID:
    """
    Represents any kind of non-wildcard ID, including IDs of embedded objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyIDWildcard:
    """
    Represents any kind of wildcard ID, including IDs of embedded objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyMoveID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyMoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyMoveIDWildcard:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyMoveIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyOracleRollableID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyOracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyOracleRollableIDWildcard:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyOracleRollableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyOracleRollableRowID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyOracleRollableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AnyOracleRollableRowIDWildcard:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AnyOracleRollableRowIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class AssetType(Enum):
    ASSET = "asset"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Asset:
    id: 'AssetID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    abilities: 'List[AssetAbility]'
    category: 'Label'
    """
    A localized category label for this asset. This is the surtitle above the
    asset's name on the card.
    """

    count_as_impact: 'bool'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    options: 'Dict[str, AssetOptionField]'
    """
    Options are input fields set when the player purchases the asset. They're
    likely to remain the same through the life of the asset. Typically, they are
    rendered at the top of the asset card.
    """

    shared: 'bool'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """

    type: 'AssetType'
    comment: 'Optional[Documentation]'
    attachments: 'Optional[AssetAttachment]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    controls: 'Optional[Dict[str, AssetControlField]]'
    """
    Controls are condition meters, clocks, counters, and other asset input
    fields whose values are expected to change throughout the life of the asset.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[AssetIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    requirement: 'Optional[MarkdownString]'
    """
    Describes prerequisites for purchasing or using this asset.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Asset':
        return cls(
            _from_json_data(AssetID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(List[AssetAbility], data.get("abilities")),
            _from_json_data(Label, data.get("category")),
            _from_json_data(bool, data.get("count_as_impact")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Dict[str, AssetOptionField], data.get("options")),
            _from_json_data(bool, data.get("shared")),
            _from_json_data(AssetType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, AssetControlField]], data.get("controls")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[AssetIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[MarkdownString], data.get("requirement")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["abilities"] = _to_json_data(self.abilities)
        data["category"] = _to_json_data(self.category)
        data["count_as_impact"] = _to_json_data(self.count_as_impact)
        data["name"] = _to_json_data(self.name)
        data["options"] = _to_json_data(self.options)
        data["shared"] = _to_json_data(self.shared)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.requirement is not None:
             data["requirement"] = _to_json_data(self.requirement)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AssetAbility:
    """
    An asset ability: one of the purchasable features of an asset. Most assets
    have three.
    """

    id: 'AssetAbilityID'
    """
    The unique Datasworn ID for this node.
    """

    enabled: 'bool'
    """
    Is this asset ability enabled?
    """

    text: 'MarkdownString'
    """
    The complete rules text of this asset ability.
    """

    comment: 'Optional[Documentation]'
    controls: 'Optional[Dict[str, AssetAbilityControlField]]'
    """
    Fields whose values are expected to change over the life of the asset.
    """

    enhance_asset: 'Optional[AssetEnhancement]'
    """
    Changes made to the asset, when this ability is enabled.
    """

    enhance_moves: 'Optional[List[MoveEnhancement]]'
    """
    Describes changes made to various moves by this asset ability. Usually these
    require specific trigger conditions.
    """

    moves: 'Optional[Dict[str, EmbeddedMove]]'
    """
    Unique moves added by this asset ability.
    """

    name: 'Optional[Label]'
    """
    A handful of asset abilities have a label/name, for instance classic
    Ironsworn companion assets. Most canonical assets omit this property.
    """

    options: 'Optional[Dict[str, AssetAbilityOptionField]]'
    """
    Fields that are expected to be set once and remain the same through the life
    of the asset.
    """

    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbility':
        return cls(
            _from_json_data(AssetAbilityID, data.get("_id")),
            _from_json_data(bool, data.get("enabled")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Dict[str, AssetAbilityControlField]], data.get("controls")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
            _from_json_data(Optional[Dict[str, EmbeddedMove]], data.get("moves")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[Dict[str, AssetAbilityOptionField]], data.get("options")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["enabled"] = _to_json_data(self.enabled)
        data["text"] = _to_json_data(self.text)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AssetAbilityControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlField':
        variants: Dict[str, Type[AssetAbilityControlField]] = {
            "checkbox": AssetAbilityControlFieldCheckbox,
            "clock": AssetAbilityControlFieldClock,
            "counter": AssetAbilityControlFieldCounter,
            "text": AssetAbilityControlFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityControlFieldCheckbox(AssetAbilityControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldClock(AssetAbilityControlField):
    """
    A clock with 4 or more segments.
    """

    label: 'Label'
    max: 'int'
    """
    The size of the clock -- in other words, the maximum number of filled clock
    segments. Standard clocks have 4, 6, 8, or 10 segments.
    """

    min: 'int'
    """
    The minimum number of filled clock segments. This is always 0.
    """

    rollable: 'bool'
    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldClock':
        return cls(
            "clock",
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "clock" }
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldCounter(AssetAbilityControlField):
    """
    A basic counter representing a non-rollable integer value. They usually
    start at 0, and may or may not have a maximum.
    """

    label: 'Label'
    max: 'int'
    min: 'int'
    """
    The (inclusive) minimum value.
    """

    rollable: 'bool'
    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCounter':
        return cls(
            "counter",
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "counter" }
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldText(AssetAbilityControlField):
    """
    Represents an input that accepts plain text.
    """

    label: 'Label'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldText':
        return cls(
            "text",
            _from_json_data(Label, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityID:
    """
    A unique ID representing an AssetAbility object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityIDWildcard:
    """
    A wildcarded AssetAbilityId that can be used to match multiple AssetAbility
    objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityMoveID:
    """
    A unique ID representing an AssetAbilityMove object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityMoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityMoveIDWildcard:
    """
    A wildcarded AssetAbilityMoveId that can be used to match multiple
    AssetAbilityMove objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityMoveIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOptionField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionField':
        variants: Dict[str, Type[AssetAbilityOptionField]] = {
            "text": AssetAbilityOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityOptionFieldText(AssetAbilityOptionField):
    """
    Represents an input that accepts plain text.
    """

    label: 'Label'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionFieldText':
        return cls(
            "text",
            _from_json_data(Label, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityOracleRollableID:
    """
    A unique ID representing an AssetAbilityOracleRollable object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOracleRollableIDWildcard:
    """
    A wildcarded AssetAbilityOracleRollableId that can be used to match multiple
    AssetAbilityOracleRollable objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOracleRollableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOracleRollableRowID:
    """
    A unique ID representing an AssetAbilityOracleRollableRow object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOracleRollableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOracleRollableRowIDWildcard:
    """
    A wildcarded AssetAbilityOracleRollableRowId that can be used to match
    multiple AssetAbilityOracleRollableRow objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOracleRollableRowIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAttachment:
    """
    Describes which assets can be attached to this asset. Example: Starforged's
    Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
    Starforged for more info.
    """

    assets: 'List[AssetIDWildcard]'
    """
    Asset IDs (which may be wildcards) that may be attached to this asset
    """

    max: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAttachment':
        return cls(
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["assets"] = _to_json_data(self.assets)
        data["max"] = _to_json_data(self.max)
        return data

class AssetCardFlipFieldFieldType(Enum):
    CARD_FLIP = "card_flip"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCardFlipFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetCardFlipField:
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    field_type: 'AssetCardFlipFieldFieldType'
    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCardFlipField':
        return cls(
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetCardFlipFieldFieldType, data.get("field_type")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["field_type"] = _to_json_data(self.field_type)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

class AssetCheckboxFieldFieldType(Enum):
    CHECKBOX = "checkbox"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCheckboxFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetCheckboxField:
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    field_type: 'AssetCheckboxFieldFieldType'
    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCheckboxField':
        return cls(
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetCheckboxFieldFieldType, data.get("field_type")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["field_type"] = _to_json_data(self.field_type)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

class AssetCollectionType(Enum):
    ASSET_COLLECTION = "asset_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCollectionType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetCollection:
    id: 'AssetCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    collections: 'Dict[str, AssetCollection]'
    contents: 'Dict[str, Asset]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'AssetCollectionType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[AssetCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[AssetCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCollection':
        return cls(
            _from_json_data(AssetCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(Dict[str, AssetCollection], data.get("collections")),
            _from_json_data(Dict[str, Asset], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(AssetCollectionType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[AssetCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[AssetCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["collections"] = _to_json_data(self.collections)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AssetCollectionID:
    """
    A unique ID representing an AssetCollection object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetCollectionIDWildcard:
    """
    A wildcarded AssetCollectionId that can be used to match multiple
    AssetCollection objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCollectionIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class AssetConditionMeterFieldType(Enum):
    CONDITION_METER = "condition_meter"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetConditionMeterMoves:
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """

    recover: 'Optional[List[AnyMoveIDWildcard]]'
    """
    The ID(s) of recovery moves associated with this meter.
    """

    suffer: 'Optional[List[AnyMoveIDWildcard]]'
    """
    The ID(s) of suffer moves associated with the condition meter. If the
    suffer move makes an action roll, this condition meter value should be made
    available as a roll option.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterMoves':
        return cls(
            _from_json_data(Optional[List[AnyMoveIDWildcard]], data.get("recover")),
            _from_json_data(Optional[List[AnyMoveIDWildcard]], data.get("suffer")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.recover is not None:
             data["recover"] = _to_json_data(self.recover)
        if self.suffer is not None:
             data["suffer"] = _to_json_data(self.suffer)
        return data

@dataclass
class AssetConditionMeter:
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    controls: 'Dict[str, AssetConditionMeterControlField]'
    """
    Checkbox controls rendered as part of the condition meter.
    """

    field_type: 'AssetConditionMeterFieldType'
    label: 'Label'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    rollable: 'bool'
    """
    Is this meter's `value` usable as a stat in an action roll?
    """

    value: 'int'
    """
    The current value of this meter.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """

    moves: 'Optional[AssetConditionMeterMoves]'
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeter':
        return cls(
            _from_json_data(Dict[str, AssetConditionMeterControlField], data.get("controls")),
            _from_json_data(AssetConditionMeterFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[AssetConditionMeterMoves], data.get("moves")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["controls"] = _to_json_data(self.controls)
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        return data

@dataclass
class AssetConditionMeterControlField:
    """
    A checkbox control field, rendered as part of an asset condition meter.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlField':
        variants: Dict[str, Type[AssetConditionMeterControlField]] = {
            "card_flip": AssetConditionMeterControlFieldCardFlip,
            "checkbox": AssetConditionMeterControlFieldCheckbox,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetConditionMeterControlFieldCardFlip(AssetConditionMeterControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldCardFlip':
        return cls(
            "card_flip",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "card_flip" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetConditionMeterControlFieldCheckbox(AssetConditionMeterControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

class AssetConditionMeterEnhancementFieldType(Enum):
    CONDITION_METER = "condition_meter"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterEnhancementFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetConditionMeterEnhancement:
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    field_type: 'AssetConditionMeterEnhancementFieldType'
    max: 'int'
    """
    The maximum value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterEnhancement':
        return cls(
            _from_json_data(AssetConditionMeterEnhancementFieldType, data.get("field_type")),
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["field_type"] = _to_json_data(self.field_type)
        data["max"] = _to_json_data(self.max)
        return data

@dataclass
class AssetControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlField':
        variants: Dict[str, Type[AssetControlField]] = {
            "card_flip": AssetControlFieldCardFlip,
            "checkbox": AssetControlFieldCheckbox,
            "condition_meter": AssetControlFieldConditionMeter,
            "select_enhancement": AssetControlFieldSelectEnhancement,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldCardFlip(AssetControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCardFlip':
        return cls(
            "card_flip",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "card_flip" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldCheckbox(AssetControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'Label'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldConditionMeterMoves:
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """

    recover: 'Optional[List[AnyMoveIDWildcard]]'
    """
    The ID(s) of recovery moves associated with this meter.
    """

    suffer: 'Optional[List[AnyMoveIDWildcard]]'
    """
    The ID(s) of suffer moves associated with the condition meter. If the
    suffer move makes an action roll, this condition meter value should be made
    available as a roll option.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeterMoves':
        return cls(
            _from_json_data(Optional[List[AnyMoveIDWildcard]], data.get("recover")),
            _from_json_data(Optional[List[AnyMoveIDWildcard]], data.get("suffer")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.recover is not None:
             data["recover"] = _to_json_data(self.recover)
        if self.suffer is not None:
             data["suffer"] = _to_json_data(self.suffer)
        return data

@dataclass
class AssetControlFieldConditionMeter(AssetControlField):
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    controls: 'Dict[str, AssetConditionMeterControlField]'
    """
    Checkbox controls rendered as part of the condition meter.
    """

    label: 'Label'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    rollable: 'bool'
    """
    Is this meter's `value` usable as a stat in an action roll?
    """

    value: 'int'
    """
    The current value of this meter.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """

    moves: 'Optional[AssetControlFieldConditionMeterMoves]'
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(Dict[str, AssetConditionMeterControlField], data.get("controls")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[AssetControlFieldConditionMeterMoves], data.get("moves")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["controls"] = _to_json_data(self.controls)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        return data

@dataclass
class AssetControlFieldSelectEnhancementChoice:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoice':
        variants: Dict[str, Type[AssetControlFieldSelectEnhancementChoice]] = {
            "choice": AssetControlFieldSelectEnhancementChoiceChoice,
            "choice_group": AssetControlFieldSelectEnhancementChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldSelectEnhancementChoiceChoice(AssetControlFieldSelectEnhancementChoice):
    """
    Represents an option in a list of choices.
    """

    label: 'Label'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoiceChoice':
        return cls(
            "choice",
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class AssetControlFieldSelectEnhancementChoiceChoiceGroup(AssetControlFieldSelectEnhancementChoice):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'Label'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(Label, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class AssetControlFieldSelectEnhancement(AssetControlField):
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, AssetControlFieldSelectEnhancementChoice]'
    label: 'Label'
    value: 'DictKey'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancement':
        return cls(
            "select_enhancement",
            _from_json_data(Dict[str, AssetControlFieldSelectEnhancementChoice], data.get("choices")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_enhancement" }
        data["choices"] = _to_json_data(self.choices)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldEnhancement:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldEnhancement':
        variants: Dict[str, Type[AssetControlFieldEnhancement]] = {
            "condition_meter": AssetControlFieldEnhancementConditionMeter,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldEnhancementConditionMeter(AssetControlFieldEnhancement):
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    max: 'int'
    """
    The maximum value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldEnhancementConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["max"] = _to_json_data(self.max)
        return data

class AssetControlValueRefUsing(Enum):
    """
    A reference to the value of an asset control.
    """

    ASSET_CONTROL = "asset_control"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlValueRefUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetControlValueRef:
    """
    A reference to the value of an asset control.
    """

    assets: 'List[AssetIDWildcard]'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    using: 'AssetControlValueRefUsing'
    """
    A reference to the value of an asset control.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlValueRef':
        return cls(
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(AssetControlValueRefUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["assets"] = _to_json_data(self.assets)
        data["control"] = _to_json_data(self.control)
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class AssetEnhancement:
    """
    Describes enhancements made to this asset in a partial asset object. The
    changes should be applied recursively; only the values that are specified
    should be changed.
    """

    attachments: 'Optional[AssetAttachment]'
    controls: 'Optional[Dict[str, AssetControlFieldEnhancement]]'
    """
    Controls are condition meters, clocks, counters, and other asset input
    fields whose values are expected to change throughout the life of the asset.
    """

    count_as_impact: 'Optional[bool]'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    shared: 'Optional[bool]'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetEnhancement':
        return cls(
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Dict[str, AssetControlFieldEnhancement]], data.get("controls")),
            _from_json_data(Optional[bool], data.get("count_as_impact")),
            _from_json_data(Optional[bool], data.get("shared")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.count_as_impact is not None:
             data["count_as_impact"] = _to_json_data(self.count_as_impact)
        if self.shared is not None:
             data["shared"] = _to_json_data(self.shared)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class AssetID:
    """
    A unique ID representing an Asset object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetIDWildcard:
    """
    A wildcarded AssetId that can be used to match multiple Asset objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetOptionField:
    """
    Options are asset input fields which are set once, usually when the
    character takes the asset. The most common example is the "name" field on
    companion assets. A more complex example is the choice of a god's stat for
    the Devotant asset.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionField':
        variants: Dict[str, Type[AssetOptionField]] = {
            "select_enhancement": AssetOptionFieldSelectEnhancement,
            "select_value": AssetOptionFieldSelectValue,
            "text": AssetOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectEnhancementChoice:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoice':
        variants: Dict[str, Type[AssetOptionFieldSelectEnhancementChoice]] = {
            "choice": AssetOptionFieldSelectEnhancementChoiceChoice,
            "choice_group": AssetOptionFieldSelectEnhancementChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectEnhancementChoiceChoice(AssetOptionFieldSelectEnhancementChoice):
    """
    Represents an option in a list of choices.
    """

    label: 'Label'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoiceChoice':
        return cls(
            "choice",
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class AssetOptionFieldSelectEnhancementChoiceChoiceGroup(AssetOptionFieldSelectEnhancementChoice):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'Label'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(Label, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class AssetOptionFieldSelectEnhancement(AssetOptionField):
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, AssetOptionFieldSelectEnhancementChoice]'
    label: 'Label'
    value: 'DictKey'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancement':
        return cls(
            "select_enhancement",
            _from_json_data(Dict[str, AssetOptionFieldSelectEnhancementChoice], data.get("choices")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_enhancement" }
        data["choices"] = _to_json_data(self.choices)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldSelectValue(AssetOptionField):
    """
    Represents a list of mutually exclusive choices.
    """

    choices: 'Dict[str, SelectValueFieldChoice]'
    label: 'Label'
    value: 'DictKey'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectValue':
        return cls(
            "select_value",
            _from_json_data(Dict[str, SelectValueFieldChoice], data.get("choices")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_value" }
        data["choices"] = _to_json_data(self.choices)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldText(AssetOptionField):
    """
    Represents an input that accepts plain text.
    """

    label: 'Label'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldText':
        return cls(
            "text",
            _from_json_data(Label, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

class AssetOptionValueRefUsing(Enum):
    """
    A reference to the value of an asset option.
    """

    ASSET_OPTION = "asset_option"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionValueRefUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AssetOptionValueRef:
    """
    A reference to the value of an asset option.
    """

    assets: 'List[AssetIDWildcard]'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """

    using: 'AssetOptionValueRefUsing'
    """
    A reference to the value of an asset option.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionValueRef':
        return cls(
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("option")),
            _from_json_data(AssetOptionValueRefUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["assets"] = _to_json_data(self.assets)
        data["option"] = _to_json_data(self.option)
        data["using"] = _to_json_data(self.using)
        return data

class AtlasCollectionType(Enum):
    ATLAS_COLLECTION = "atlas_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasCollectionType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AtlasCollection:
    id: 'AtlasCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    collections: 'Dict[str, AtlasCollection]'
    contents: 'Dict[str, AtlasEntry]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'AtlasCollectionType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[AtlasCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[AtlasCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasCollection':
        return cls(
            _from_json_data(AtlasCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(Dict[str, AtlasCollection], data.get("collections")),
            _from_json_data(Dict[str, AtlasEntry], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(AtlasCollectionType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[AtlasCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[AtlasCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["collections"] = _to_json_data(self.collections)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AtlasCollectionID:
    """
    A unique ID representing an AtlasCollection object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AtlasCollectionIDWildcard:
    """
    A wildcarded AtlasCollectionId that can be used to match multiple
    AtlasCollection objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasCollectionIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class AtlasEntryType(Enum):
    ATLAS_ENTRY = "atlas_entry"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntryType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AtlasEntry:
    """
    An atlas entry, like the Ironlands region entries found in classic
    Ironsworn.
    """

    id: 'AtlasEntryID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    description: 'MarkdownString'
    features: 'List[MarkdownString]'
    name: 'Label'
    type: 'AtlasEntryType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    quest_starter: 'Optional[MarkdownString]'
    replaces: 'Optional[List[AtlasEntryIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    tags: 'Optional[Tags]'
    your_truth: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntry':
        return cls(
            _from_json_data(AtlasEntryID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(AtlasEntryType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[MarkdownString], data.get("quest_starter")),
            _from_json_data(Optional[List[AtlasEntryIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[MarkdownString], data.get("your_truth")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["description"] = _to_json_data(self.description)
        data["features"] = _to_json_data(self.features)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.quest_starter is not None:
             data["quest_starter"] = _to_json_data(self.quest_starter)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.your_truth is not None:
             data["your_truth"] = _to_json_data(self.your_truth)
        return data

@dataclass
class AtlasEntryID:
    """
    A unique ID representing an AtlasEntry object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AtlasEntryIDWildcard:
    """
    A wildcarded AtlasEntryId that can be used to match multiple AtlasEntry
    objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntryIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class AttachedAssetControlValueRefUsing(Enum):
    """
    A reference to the value of an attached asset control. For example, a Module
    asset could use this to roll using the `integrity` control of an attached
    Vehicle.
    """

    ATTACHED_ASSET_CONTROL = "attached_asset_control"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AttachedAssetControlValueRefUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AttachedAssetControlValueRef:
    """
    A reference to the value of an attached asset control. For example, a Module
    asset could use this to roll using the `integrity` control of an attached
    Vehicle.
    """

    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    using: 'AttachedAssetControlValueRefUsing'
    """
    A reference to the value of an attached asset control. For example, a Module
    asset could use this to roll using the `integrity` control of an attached
    Vehicle.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AttachedAssetControlValueRef':
        return cls(
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(AttachedAssetControlValueRefUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["control"] = _to_json_data(self.control)
        data["using"] = _to_json_data(self.using)
        return data

class AttachedAssetOptionValueRefUsing(Enum):
    """
    A reference to the value of an attached asset option.
    """

    ATTACHED_ASSET_OPTION = "attached_asset_option"
    @classmethod
    def from_json_data(cls, data: Any) -> 'AttachedAssetOptionValueRefUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class AttachedAssetOptionValueRef:
    """
    A reference to the value of an attached asset option.
    """

    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """

    using: 'AttachedAssetOptionValueRefUsing'
    """
    A reference to the value of an attached asset option.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AttachedAssetOptionValueRef':
        return cls(
            _from_json_data(DictKey, data.get("option")),
            _from_json_data(AttachedAssetOptionValueRefUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["option"] = _to_json_data(self.option)
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class AuthorInfo:
    """
    Information on the original creator of this material.
    """

    name: 'Label'
    """
    The name of the author.
    """

    email: 'Optional[Email]'
    """
    An optional email contact for the author
    """

    url: 'Optional[WebURL]'
    """
    An optional URL for the author's website.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AuthorInfo':
        return cls(
            _from_json_data(Label, data.get("name")),
            _from_json_data(Optional[Email], data.get("email")),
            _from_json_data(Optional[WebURL], data.get("url")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        if self.email is not None:
             data["email"] = _to_json_data(self.email)
        if self.url is not None:
             data["url"] = _to_json_data(self.url)
        return data

@dataclass
class ChallengeRank:
    """
    Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
    """

    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ChallengeRank':
        return cls(_from_json_data(int, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class ClockFieldFieldType(Enum):
    CLOCK = "clock"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ClockFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ClockField:
    """
    A clock with 4 or more segments.
    """

    field_type: 'ClockFieldFieldType'
    label: 'Label'
    max: 'int'
    """
    The size of the clock -- in other words, the maximum number of filled clock
    segments. Standard clocks have 4, 6, 8, or 10 segments.
    """

    min: 'int'
    """
    The minimum number of filled clock segments. This is always 0.
    """

    rollable: 'bool'
    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ClockField':
        return cls(
            _from_json_data(ClockFieldFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

class CollectableType(Enum):
    ASSET = "asset"
    ATLAS_ENTRY = "atlas_entry"
    MOVE = "move"
    NPC = "npc"
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'CollectableType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class CollectionType(Enum):
    ASSET_COLLECTION = "asset_collection"
    ATLAS_COLLECTION = "atlas_collection"
    MOVE_CATEGORY = "move_category"
    NPC_COLLECTION = "npc_collection"
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'CollectionType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ConditionMeterFieldFieldType(Enum):
    CONDITION_METER = "condition_meter"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ConditionMeterField:
    """
    A meter with an integer value, bounded by a minimum and maximum.
    """

    field_type: 'ConditionMeterFieldFieldType'
    label: 'Label'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    rollable: 'bool'
    """
    Is this meter's `value` usable as a stat in an action roll?
    """

    value: 'int'
    """
    The current value of this meter.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterField':
        return cls(
            _from_json_data(ConditionMeterFieldFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class ConditionMeterKey:
    """
    A basic, rollable player character resource specified by the ruleset.
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterKey':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ConditionMeterRule:
    """
    Describes a standard player character condition meter.
    """

    description: 'MarkdownString'
    """
    A description of this condition meter.
    """

    label: 'Label'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    rollable: 'bool'
    """
    Is this meter's `value` usable as a stat in an action roll?
    """

    shared: 'bool'
    """
    Is this condition meter shared by all players?
    """

    value: 'int'
    """
    The current value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(bool, data.get("shared")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["shared"] = _to_json_data(self.shared)
        data["value"] = _to_json_data(self.value)
        return data

class ConditionMeterValueRefUsing(Enum):
    """
    A reference to the value of a standard player condition meter.
    """

    CONDITION_METER = "condition_meter"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterValueRefUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ConditionMeterValueRef:
    """
    A reference to the value of a standard player condition meter.
    """

    condition_meter: 'ConditionMeterKey'
    using: 'ConditionMeterValueRefUsing'
    """
    A reference to the value of a standard player condition meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterValueRef':
        return cls(
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
            _from_json_data(ConditionMeterValueRefUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["condition_meter"] = _to_json_data(self.condition_meter)
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class CoreTags:
    requires_allies: 'Optional[bool]'
    """
    This object requires allies to function, and is intended for co-op play, or
    guided play with allies. It is not appropriate for solo play.
    """

    supernatural: 'Optional[bool]'
    """
    This object is supernatural in nature, and is ideal for settings that
    feature supernatural or mythic powers.
    """

    technological: 'Optional[bool]'
    """
    This object is technological in nature, and is ideal for settings that
    feature remarkable technologies.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'CoreTags':
        return cls(
            _from_json_data(Optional[bool], data.get("requires_allies")),
            _from_json_data(Optional[bool], data.get("supernatural")),
            _from_json_data(Optional[bool], data.get("technological")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.requires_allies is not None:
             data["requires_allies"] = _to_json_data(self.requires_allies)
        if self.supernatural is not None:
             data["supernatural"] = _to_json_data(self.supernatural)
        if self.technological is not None:
             data["technological"] = _to_json_data(self.technological)
        return data

class CounterFieldFieldType(Enum):
    COUNTER = "counter"
    @classmethod
    def from_json_data(cls, data: Any) -> 'CounterFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class CounterField:
    """
    A basic counter representing a non-rollable integer value. They usually
    start at 0, and may or may not have a maximum.
    """

    field_type: 'CounterFieldFieldType'
    label: 'Label'
    max: 'int'
    min: 'int'
    """
    The (inclusive) minimum value.
    """

    rollable: 'bool'
    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'CounterField':
        return cls(
            _from_json_data(CounterFieldFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class CSSColor:
    """
    A CSS color value.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'CSSColor':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class CustomValueUsing(Enum):
    """
    An arbitrary static integer value with a label.
    """

    CUSTOM = "custom"
    @classmethod
    def from_json_data(cls, data: Any) -> 'CustomValueUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class CustomValue:
    """
    An arbitrary static integer value with a label.
    """

    label: 'Label'
    using: 'CustomValueUsing'
    """
    An arbitrary static integer value with a label.
    """

    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'CustomValue':
        return cls(
            _from_json_data(Label, data.get("label")),
            _from_json_data(CustomValueUsing, data.get("using")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["label"] = _to_json_data(self.label)
        data["using"] = _to_json_data(self.using)
        data["value"] = _to_json_data(self.value)
        return data

class DelveSiteType(Enum):
    DELVE_SITE = "delve_site"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSite:
    """
    A delve site with a theme, domain, and denizens.
    """

    id: 'DelveSiteID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    denizens: 'List[DelveSiteDenizen]'
    """
    Represents the delve site's denizen matrix as an array of objects.
    """

    description: 'MarkdownString'
    domain: 'DelveSiteDomainID'
    """
    The ID of the site's DelveSiteDomain card.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rank: 'ChallengeRank'
    theme: 'DelveSiteThemeID'
    """
    The ID of the site's DelveSiteTheme card.
    """

    type: 'DelveSiteType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    extra_card: 'Optional[str]'
    """
    An additional theme or domain card ID, for use with optional rules in
    Ironsworn: Delve.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    region: 'Optional[AtlasEntryID]'
    """
    The ID of an atlas entry representing the region in which this delve site
    is located.
    """

    replaces: 'Optional[List[DelveSiteIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSite':
        return cls(
            _from_json_data(DelveSiteID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(List[DelveSiteDenizen], data.get("denizens")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(DelveSiteDomainID, data.get("domain")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(DelveSiteThemeID, data.get("theme")),
            _from_json_data(DelveSiteType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[str], data.get("extra_card")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[AtlasEntryID], data.get("region")),
            _from_json_data(Optional[List[DelveSiteIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["denizens"] = _to_json_data(self.denizens)
        data["description"] = _to_json_data(self.description)
        data["domain"] = _to_json_data(self.domain)
        data["name"] = _to_json_data(self.name)
        data["rank"] = _to_json_data(self.rank)
        data["theme"] = _to_json_data(self.theme)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.extra_card is not None:
             data["extra_card"] = _to_json_data(self.extra_card)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.region is not None:
             data["region"] = _to_json_data(self.region)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class DelveSiteDenizen:
    """
    Represents an entry in a delve site denizen matrix. Denizen matrices are
    described in Ironsworn: Delve.
    """

    id: 'DelveSiteDenizenID'
    frequency: 'DelveSiteDenizenFrequency'
    roll: 'DiceRange'
    name: 'Optional[Label]'
    """
    A name for the denizen, if it's different than the `name` property of the
    NPC.
    """

    npc: 'Optional[NpcID]'
    """
    The ID of the relevant NPC entry, if one is specified.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizen':
        return cls(
            _from_json_data(DelveSiteDenizenID, data.get("_id")),
            _from_json_data(DelveSiteDenizenFrequency, data.get("frequency")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[NpcID], data.get("npc")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["frequency"] = _to_json_data(self.frequency)
        data["roll"] = _to_json_data(self.roll)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.npc is not None:
             data["npc"] = _to_json_data(self.npc)
        return data

class DelveSiteDenizenFrequency(Enum):
    COMMON = "common"
    RARE = "rare"
    UNCOMMON = "uncommon"
    UNFORESEEN = "unforeseen"
    VERY_COMMON = "very_common"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenFrequency':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteDenizenID:
    """
    A unique ID representing a DelveSiteDenizen object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDenizenIDWildcard:
    """
    A wildcarded DelveSiteDenizenId that can be used to match multiple
    DelveSiteDenizen objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class DelveSiteDomainType(Enum):
    DELVE_SITE_DOMAIN = "delve_site_domain"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteDomain:
    """
    A delve site Domain card.
    """

    id: 'DelveSiteDomainID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    dangers: 'List[DelveSiteDomainDanger]'
    description: 'MarkdownString'
    """
    The description text that appears below the title on the card.
    """

    features: 'List[DelveSiteDomainFeature]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'DelveSiteDomainType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    name_oracle: 'Optional[OracleRollableID]'
    """
    An oracle table ID containing place name elements. For examples, see
    oracle ID `oracle_rollable:delve/site_name/place/barrow`, and its siblings
    in oracle collection ID `oracle_collection:delve/site_name/place`.
    These oracles are used by the site name oracle from Ironsworn: Delve
    (`oracle_rollable:delve/site_name/format`) to create random names for delve
    sites.
    """

    replaces: 'Optional[List[DelveSiteDomainIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomain':
        return cls(
            _from_json_data(DelveSiteDomainID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(List[DelveSiteDomainDanger], data.get("dangers")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[DelveSiteDomainFeature], data.get("features")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(DelveSiteDomainType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleRollableID], data.get("name_oracle")),
            _from_json_data(Optional[List[DelveSiteDomainIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["dangers"] = _to_json_data(self.dangers)
        data["description"] = _to_json_data(self.description)
        data["features"] = _to_json_data(self.features)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.name_oracle is not None:
             data["name_oracle"] = _to_json_data(self.name_oracle)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class DelveSiteDomainDanger:
    """
    Represents a row in an oracle table, with a single text cell.
    """

    id: 'DelveSiteDomainDangerID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainDanger':
        return cls(
            _from_json_data(DelveSiteDomainDangerID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteDomainDangerID:
    """
    A unique ID representing a DelveSiteDomainDanger object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainDangerID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomainDangerIDWildcard:
    """
    A wildcarded DelveSiteDomainDangerId that can be used to match multiple
    DelveSiteDomainDanger objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainDangerIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomainFeature:
    """
    Represents a row in an oracle table, with a single text cell.
    """

    id: 'DelveSiteDomainFeatureID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainFeature':
        return cls(
            _from_json_data(DelveSiteDomainFeatureID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteDomainFeatureID:
    """
    A unique ID representing a DelveSiteDomainFeature object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainFeatureID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomainFeatureIDWildcard:
    """
    A wildcarded DelveSiteDomainFeatureId that can be used to match multiple
    DelveSiteDomainFeature objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainFeatureIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomainID:
    """
    A unique ID representing a DelveSiteDomain object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomainIDWildcard:
    """
    A wildcarded DelveSiteDomainId that can be used to match multiple
    DelveSiteDomain objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteID:
    """
    A unique ID representing a DelveSite object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteIDWildcard:
    """
    A wildcarded DelveSiteId that can be used to match multiple DelveSite
    objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class DelveSiteThemeType(Enum):
    DELVE_SITE_THEME = "delve_site_theme"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteTheme:
    """
    A delve site theme card.
    """

    id: 'DelveSiteThemeID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    dangers: 'List[DelveSiteThemeDanger]'
    description: 'MarkdownString'
    """
    The description text that appears below the title on the card.
    """

    features: 'List[DelveSiteThemeFeature]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'DelveSiteThemeType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[DelveSiteThemeIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteTheme':
        return cls(
            _from_json_data(DelveSiteThemeID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(List[DelveSiteThemeDanger], data.get("dangers")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[DelveSiteThemeFeature], data.get("features")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(DelveSiteThemeType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[DelveSiteThemeIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["dangers"] = _to_json_data(self.dangers)
        data["description"] = _to_json_data(self.description)
        data["features"] = _to_json_data(self.features)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class DelveSiteThemeDanger:
    """
    Represents a row in an oracle table, with a single text cell.
    """

    id: 'DelveSiteThemeDangerID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeDanger':
        return cls(
            _from_json_data(DelveSiteThemeDangerID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteThemeDangerID:
    """
    A unique ID representing a DelveSiteThemeDanger object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeDangerID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteThemeDangerIDWildcard:
    """
    A wildcarded DelveSiteThemeDangerId that can be used to match multiple
    DelveSiteThemeDanger objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeDangerIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteThemeFeature:
    """
    Represents a row in an oracle table, with a single text cell.
    """

    id: 'DelveSiteThemeFeatureID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeFeature':
        return cls(
            _from_json_data(DelveSiteThemeFeatureID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteThemeFeatureID:
    """
    A unique ID representing a DelveSiteThemeFeature object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeFeatureID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteThemeFeatureIDWildcard:
    """
    A wildcarded DelveSiteThemeFeatureId that can be used to match multiple
    DelveSiteThemeFeature objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeFeatureIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteThemeID:
    """
    A unique ID representing a DelveSiteTheme object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteThemeIDWildcard:
    """
    A wildcarded DelveSiteThemeId that can be used to match multiple
    DelveSiteTheme objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DiceExpression:
    """
    A simple dice roll expression with an optional (positive or negative)
    modifer.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DiceExpression':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DiceRange:
    """
    Represents a range of dice roll results, bounded by `min` and `max`
    (inclusive).
    """

    max: 'int'
    """
    High end of the dice range.
    """

    min: 'int'
    """
    Low end of the dice range.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'DiceRange':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class DictKey:
    """
    A `snake_case` key used in a Datasworn dictionary object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DictKey':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Documentation:
    """
    Implementation hints or other developer-facing comments on this node. These
    should be omitted when representing an object for gameplay.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Documentation':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Email:
    """
    An email address.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Email':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class EmbedOnlyType(Enum):
    ABILITY = "ability"
    DANGER = "danger"
    DENIZEN = "denizen"
    FEATURE = "feature"
    OPTION = "option"
    ROW = "row"
    VARIANT = "variant"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbedOnlyType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedActionRollMoveRollType(Enum):
    ACTION_ROLL = "action_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedActionRollMoveRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedActionRollMoveType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedActionRollMoveType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedActionRollMove:
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    roll_type: 'EmbeddedActionRollMoveRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerActionRoll'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedActionRollMoveType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedActionRollMove':
        return cls(
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(EmbeddedActionRollMoveRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerActionRoll, data.get("trigger")),
            _from_json_data(EmbeddedActionRollMoveType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedMove:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMove':
        variants: Dict[str, Type[EmbeddedMove]] = {
            "action_roll": EmbeddedMoveActionRoll,
            "no_roll": EmbeddedMoveNoRoll,
            "progress_roll": EmbeddedMoveProgressRoll,
            "special_track": EmbeddedMoveSpecialTrack,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class EmbeddedMoveActionRollType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveActionRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedMoveActionRoll(EmbeddedMove):
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerActionRoll'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedMoveActionRollType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveActionRoll':
        return cls(
            "action_roll",
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerActionRoll, data.get("trigger")),
            _from_json_data(EmbeddedMoveActionRollType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedMoveNoRollType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveNoRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedMoveNoRoll(EmbeddedMove):
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerNoRoll'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedMoveNoRollType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveNoRoll':
        return cls(
            "no_roll",
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerNoRoll, data.get("trigger")),
            _from_json_data(EmbeddedMoveNoRollType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedMoveProgressRollType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveProgressRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedMoveProgressRoll(EmbeddedMove):
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    tracks: 'ProgressTrackTypeInfo'
    """
    Describes the common features of progress tracks associated with this move.
    """

    trigger: 'TriggerProgressRoll'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedMoveProgressRollType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(ProgressTrackTypeInfo, data.get("tracks")),
            _from_json_data(TriggerProgressRoll, data.get("trigger")),
            _from_json_data(EmbeddedMoveProgressRollType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["text"] = _to_json_data(self.text)
        data["tracks"] = _to_json_data(self.tracks)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedMoveSpecialTrackType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveSpecialTrackType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedMoveSpecialTrack(EmbeddedMove):
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerSpecialTrack'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedMoveSpecialTrackType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveSpecialTrack':
        return cls(
            "special_track",
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerSpecialTrack, data.get("trigger")),
            _from_json_data(EmbeddedMoveSpecialTrackType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedMoveID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class EmbeddedMoveIDWildcard:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedMoveIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class EmbeddedNoRollMoveRollType(Enum):
    NO_ROLL = "no_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedNoRollMoveRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedNoRollMoveType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedNoRollMoveType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedNoRollMove:
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    roll_type: 'EmbeddedNoRollMoveRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerNoRoll'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedNoRollMoveType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedNoRollMove':
        return cls(
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedNoRollMoveRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerNoRoll, data.get("trigger")),
            _from_json_data(EmbeddedNoRollMoveType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedOracleColumnTextOracleType(Enum):
    COLUMN_TEXT = "column_text"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnTextOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedOracleColumnTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleColumnTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleColumnText:
    id: 'EmbeddedOracleRollableID'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'EmbeddedOracleColumnTextOracleType'
    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleColumnTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleColumnTextRecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText':
        return cls(
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedOracleColumnTextOracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(EmbeddedOracleColumnTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleColumnTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedOracleColumnText2OracleType(Enum):
    COLUMN_TEXT2 = "column_text2"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText2OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedOracleColumnText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleColumnText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleColumnText2:
    id: 'EmbeddedOracleRollableID'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'EmbeddedOracleColumnText2OracleType'
    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleColumnText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleColumnText2RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText2':
        return cls(
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedOracleColumnText2OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(EmbeddedOracleColumnText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleColumnText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedOracleColumnText3OracleType(Enum):
    COLUMN_TEXT3 = "column_text3"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText3OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedOracleColumnText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleColumnText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleColumnText3:
    id: 'EmbeddedOracleRollableID'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'EmbeddedOracleColumnText3OracleType'
    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleColumnText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleColumnText3RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleColumnText3':
        return cls(
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedOracleColumnText3OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(EmbeddedOracleColumnText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleColumnText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleRollable:
    oracle_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollable':
        variants: Dict[str, Type[EmbeddedOracleRollable]] = {
            "column_text": EmbeddedOracleRollableColumnText,
            "column_text2": EmbeddedOracleRollableColumnText2,
            "column_text3": EmbeddedOracleRollableColumnText3,
            "table_text": EmbeddedOracleRollableTableText,
            "table_text2": EmbeddedOracleRollableTableText2,
            "table_text3": EmbeddedOracleRollableTableText3,
        }

        return variants[data["oracle_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class EmbeddedOracleRollableColumnTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleRollableColumnTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleRollableColumnText(EmbeddedOracleRollable):
    id: 'EmbeddedOracleRollableID'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleRollableColumnTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleRollableColumnTextRecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText':
        return cls(
            "column_text",
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(EmbeddedOracleRollableColumnTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleRollableColumnTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "column_text" }
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedOracleRollableColumnText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleRollableColumnText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleRollableColumnText2(EmbeddedOracleRollable):
    id: 'EmbeddedOracleRollableID'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleRollableColumnText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleRollableColumnText2RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText2':
        return cls(
            "column_text2",
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(EmbeddedOracleRollableColumnText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleRollableColumnText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "column_text2" }
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedOracleRollableColumnText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleRollableColumnText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleRollableColumnText3(EmbeddedOracleRollable):
    id: 'EmbeddedOracleRollableID'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleRollableColumnText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleRollableColumnText3RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableColumnText3':
        return cls(
            "column_text3",
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(EmbeddedOracleRollableColumnText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleRollableColumnText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "column_text3" }
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleRollableTableTextColumnLabels:
    roll: 'Label'
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        return data

class EmbeddedOracleRollableTableTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleRollableTableTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleRollableTableText(EmbeddedOracleRollable):
    id: 'EmbeddedOracleRollableID'
    column_labels: 'EmbeddedOracleRollableTableTextColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleRollableTableTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleRollableTableTextRecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText':
        return cls(
            "table_text",
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(EmbeddedOracleRollableTableTextColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(EmbeddedOracleRollableTableTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleRollableTableTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text" }
        data["_id"] = _to_json_data(self.id)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleRollableTableText2ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class EmbeddedOracleRollableTableText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleRollableTableText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleRollableTableText2(EmbeddedOracleRollable):
    id: 'EmbeddedOracleRollableID'
    column_labels: 'EmbeddedOracleRollableTableText2ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleRollableTableText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleRollableTableText2RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText2':
        return cls(
            "table_text2",
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(EmbeddedOracleRollableTableText2ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(EmbeddedOracleRollableTableText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleRollableTableText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text2" }
        data["_id"] = _to_json_data(self.id)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleRollableTableText3ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class EmbeddedOracleRollableTableText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleRollableTableText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleRollableTableText3(EmbeddedOracleRollable):
    id: 'EmbeddedOracleRollableID'
    column_labels: 'EmbeddedOracleRollableTableText3ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleRollableTableText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleRollableTableText3RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableTableText3':
        return cls(
            "table_text3",
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(EmbeddedOracleRollableTableText3ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(EmbeddedOracleRollableTableText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleRollableTableText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text3" }
        data["_id"] = _to_json_data(self.id)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleRollableID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class EmbeddedOracleRollableIDWildcard:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleRollableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class EmbeddedOracleTableTextColumnLabels:
    roll: 'Label'
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        return data

class EmbeddedOracleTableTextOracleType(Enum):
    TABLE_TEXT = "table_text"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableTextOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedOracleTableTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleTableTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleTableText:
    id: 'EmbeddedOracleRollableID'
    column_labels: 'EmbeddedOracleTableTextColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'EmbeddedOracleTableTextOracleType'
    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleTableTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleTableTextRecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText':
        return cls(
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(EmbeddedOracleTableTextColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedOracleTableTextOracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(EmbeddedOracleTableTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleTableTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleTableText2ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class EmbeddedOracleTableText2OracleType(Enum):
    TABLE_TEXT2 = "table_text2"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText2OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedOracleTableText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleTableText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleTableText2:
    id: 'EmbeddedOracleRollableID'
    column_labels: 'EmbeddedOracleTableText2ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'EmbeddedOracleTableText2OracleType'
    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleTableText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleTableText2RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText2':
        return cls(
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(EmbeddedOracleTableText2ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedOracleTableText2OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(EmbeddedOracleTableText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleTableText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EmbeddedOracleTableText3ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class EmbeddedOracleTableText3OracleType(Enum):
    TABLE_TEXT3 = "table_text3"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText3OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedOracleTableText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedOracleTableText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class EmbeddedOracleTableText3:
    id: 'EmbeddedOracleRollableID'
    column_labels: 'EmbeddedOracleTableText3ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'EmbeddedOracleTableText3OracleType'
    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'EmbeddedOracleTableText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[EmbeddedOracleTableText3RecommendedRolls]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedOracleTableText3':
        return cls(
            _from_json_data(EmbeddedOracleRollableID, data.get("_id")),
            _from_json_data(EmbeddedOracleTableText3ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EmbeddedOracleTableText3OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(EmbeddedOracleTableText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[EmbeddedOracleTableText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedProgressRollMoveRollType(Enum):
    PROGRESS_ROLL = "progress_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedProgressRollMoveRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedProgressRollMoveType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedProgressRollMoveType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedProgressRollMove:
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    roll_type: 'EmbeddedProgressRollMoveRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    tracks: 'ProgressTrackTypeInfo'
    """
    Describes the common features of progress tracks associated with this move.
    """

    trigger: 'TriggerProgressRoll'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedProgressRollMoveType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedProgressRollMove':
        return cls(
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(EmbeddedProgressRollMoveRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(ProgressTrackTypeInfo, data.get("tracks")),
            _from_json_data(TriggerProgressRoll, data.get("trigger")),
            _from_json_data(EmbeddedProgressRollMoveType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["tracks"] = _to_json_data(self.tracks)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class EmbeddedSpecialTrackMoveRollType(Enum):
    SPECIAL_TRACK = "special_track"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedSpecialTrackMoveRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class EmbeddedSpecialTrackMoveType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedSpecialTrackMoveType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class EmbeddedSpecialTrackMove:
    id: 'EmbeddedMoveID'
    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    roll_type: 'EmbeddedSpecialTrackMoveRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerSpecialTrack'
    """
    Trigger conditions for this move.
    """

    type: 'EmbeddedSpecialTrackMoveType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EmbeddedSpecialTrackMove':
        return cls(
            _from_json_data(EmbeddedMoveID, data.get("_id")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(EmbeddedSpecialTrackMoveRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerSpecialTrack, data.get("trigger")),
            _from_json_data(EmbeddedSpecialTrackMoveType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class EntityPrompt:
    """
    This type is a placeholder and may see signficant changes in v0.2.0.
    """

    text: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EntityPrompt':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

class ExpansionDataswornVersion(Enum):
    """
    The version of the Datasworn format used by this data.
    """

    DEFAULT_NAME = "0.1.0"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ExpansionDataswornVersion':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ExpansionType(Enum):
    EXPANSION = "expansion"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ExpansionType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Expansion:
    """
    A Datasworn package that relies on an external package to provide its
    ruleset.
    """

    id: 'ExpansionID'
    assets: 'Dict[str, AssetCollection]'
    """
    A dictionary object containing asset collections, which contain assets.
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    datasworn_version: 'ExpansionDataswornVersion'
    """
    The version of the Datasworn format used by this data.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'WebURL'
    moves: 'Dict[str, MoveCategory]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    oracles: 'Dict[str, OracleTablesCollection]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    ruleset: 'RulesetID'
    title: 'Label'
    """
    The title of the source document.
    """

    type: 'ExpansionType'
    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    atlas: 'Optional[Dict[str, AtlasCollection]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    description: 'Optional[MarkdownString]'
    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    rules: 'Optional[RulesExpansion]'
    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Expansion':
        return cls(
            _from_json_data(ExpansionID, data.get("_id")),
            _from_json_data(Dict[str, AssetCollection], data.get("assets")),
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(ExpansionDataswornVersion, data.get("datasworn_version")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(WebURL, data.get("license")),
            _from_json_data(Dict[str, MoveCategory], data.get("moves")),
            _from_json_data(Dict[str, OracleTablesCollection], data.get("oracles")),
            _from_json_data(RulesetID, data.get("ruleset")),
            _from_json_data(Label, data.get("title")),
            _from_json_data(ExpansionType, data.get("type")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[Dict[str, AtlasCollection]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[RulesExpansion], data.get("rules")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["assets"] = _to_json_data(self.assets)
        data["authors"] = _to_json_data(self.authors)
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["moves"] = _to_json_data(self.moves)
        data["oracles"] = _to_json_data(self.oracles)
        data["ruleset"] = _to_json_data(self.ruleset)
        data["title"] = _to_json_data(self.title)
        data["type"] = _to_json_data(self.type)
        data["url"] = _to_json_data(self.url)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.rules is not None:
             data["rules"] = _to_json_data(self.rules)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

@dataclass
class ExpansionID:
    """
    The ID of a Datasworn package that relies on an external package to provide
    its ruleset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ExpansionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class I18nHint:
    part_of_speech: 'Optional[PartOfSpeech]'
    """
    The part of speech for this string.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHint':
        return cls(
            _from_json_data(Optional[PartOfSpeech], data.get("part_of_speech")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.part_of_speech is not None:
             data["part_of_speech"] = _to_json_data(self.part_of_speech)
        return data

@dataclass
class I18nHintsTemplate:
    text: 'Optional[I18nHint]'
    text2: 'Optional[I18nHint]'
    text3: 'Optional[I18nHint]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHintsTemplate':
        return cls(
            _from_json_data(Optional[I18nHint], data.get("text")),
            _from_json_data(Optional[I18nHint], data.get("text2")),
            _from_json_data(Optional[I18nHint], data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        if self.text2 is not None:
             data["text2"] = _to_json_data(self.text2)
        if self.text3 is not None:
             data["text3"] = _to_json_data(self.text3)
        return data

@dataclass
class I18nHints:
    """
    Internationalization/localization hints for the text content of this object.
    """

    template: 'Optional[I18nHintsTemplate]'
    text: 'Optional[I18nHint]'
    text2: 'Optional[I18nHint]'
    text3: 'Optional[I18nHint]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHints':
        return cls(
            _from_json_data(Optional[I18nHintsTemplate], data.get("template")),
            _from_json_data(Optional[I18nHint], data.get("text")),
            _from_json_data(Optional[I18nHint], data.get("text2")),
            _from_json_data(Optional[I18nHint], data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        if self.text2 is not None:
             data["text2"] = _to_json_data(self.text2)
        if self.text3 is not None:
             data["text3"] = _to_json_data(self.text3)
        return data

@dataclass
class ImpactCategory:
    """
    Describes a category of standard impacts/debilities.
    """

    contents: 'Dict[str, ImpactRule]'
    """
    A dictionary object of the Impacts in this category.
    """

    description: 'MarkdownString'
    """
    A description of this impact category.
    """

    label: 'Label'
    """
    A label for this impact category.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactCategory':
        return cls(
            _from_json_data(Dict[str, ImpactRule], data.get("contents")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(Label, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["contents"] = _to_json_data(self.contents)
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        return data

@dataclass
class ImpactRule:
    """
    Describes a standard impact/debility.
    """

    description: 'MarkdownString'
    """
    A description of this impact.
    """

    label: 'Label'
    """
    The label for this impact.
    """

    permanent: 'bool'
    """
    Is this impact permanent?
    """

    prevents_recovery: 'List[ConditionMeterKey]'
    """
    Any ruleset condition meters that can't recover when this impact is active.
    """

    shared: 'bool'
    """
    Is this impact applied to all players at once?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("permanent")),
            _from_json_data(List[ConditionMeterKey], data.get("prevents_recovery")),
            _from_json_data(bool, data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["permanent"] = _to_json_data(self.permanent)
        data["prevents_recovery"] = _to_json_data(self.prevents_recovery)
        data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class Label:
    """
    A localized, player-facing name or label, formatted as plain text. In some
    contexts it may be undesirable to render this text, but it should always be
    exposed to assistive technology (e.g. with `aria-label` in HTML).
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Label':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MarkdownString:
    """
    Localized, player-facing text, formatted in Markdown. It is *not* formatted
    for use "out of the box"; it uses some custom syntax, intended to be
    replaced in whatever way is most appropriate for your implementation.
    
    * `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to
    the identified object. The ID must conform to the `AnyId` type; no wildcards
    allowed.
    * `{{table>oracle_rollable:starforged/core/action}}`: the referenced
    oracle is rendered here in the source material. The ID must conform to the
    `AnyOracleRollableId` type; no wildcards allowed.
    * `{{table_columns>move:delve/delve/delve_the_depths}}`: Render
    *all* direct OracleRollable children of the identified node. This
    can be an OracleCollectionId, or the ID of anything that can have
    EmbeddedOracleRollables (such as a Move or TruthOption).
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MarkdownString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MarkdownTemplateString:
    """
    A rich text string in Markdown with replaced values from oracle roll
    results.
    
    The custom syntax `{{some_row_key>some_oracle_table_id}}` should be replaced
    by the `some_row_key` string of a rolled oracle table. This is usually the
    `text` key, for example `{{text>oracle_rollable:starforged/core/action}}`
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MarkdownTemplateString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Move:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Move':
        variants: Dict[str, Type[Move]] = {
            "action_roll": MoveActionRoll0,
            "no_roll": MoveNoRoll0,
            "progress_roll": MoveProgressRoll0,
            "special_track": MoveSpecialTrack0,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class MoveActionRollType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveActionRoll0(Move):
    """
    A move that makes an action roll.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerActionRoll'
    """
    Trigger conditions for this move.
    """

    type: 'MoveActionRollType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRoll0':
        return cls(
            "action_roll",
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerActionRoll, data.get("trigger")),
            _from_json_data(MoveActionRollType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveNoRollType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveNoRoll0(Move):
    """
    A move that makes no progress rolls or action rolls.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerNoRoll'
    """
    Trigger conditions for this move.
    """

    type: 'MoveNoRollType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRoll0':
        return cls(
            "no_roll",
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerNoRoll, data.get("trigger")),
            _from_json_data(MoveNoRollType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveProgressRollType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveProgressRoll0(Move):
    """
    A progress move that rolls on a standard progress track type (whose features
    are defined by this move object). For progress rolls that use special
    tracks, see MoveSpecialTrack.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    tracks: 'ProgressTrackTypeInfo'
    """
    Describes the common features of progress tracks associated with this move.
    """

    trigger: 'TriggerProgressRoll'
    """
    Trigger conditions for this move.
    """

    type: 'MoveProgressRollType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRoll0':
        return cls(
            "progress_roll",
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(ProgressTrackTypeInfo, data.get("tracks")),
            _from_json_data(TriggerProgressRoll, data.get("trigger")),
            _from_json_data(MoveProgressRollType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["text"] = _to_json_data(self.text)
        data["tracks"] = _to_json_data(self.tracks)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveSpecialTrackType(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrackType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveSpecialTrack0(Move):
    """
    A progress move that rolls on a special track, such as Legacies (Starforged)
    or Bonds (classic Ironsworn). For progress moves that use standard progress
    tracks, see MoveProgressRoll instead.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerSpecialTrack'
    """
    Trigger conditions for this move.
    """

    type: 'MoveSpecialTrackType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrack0':
        return cls(
            "special_track",
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerSpecialTrack, data.get("trigger")),
            _from_json_data(MoveSpecialTrackType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveActionRollRollType(Enum):
    ACTION_ROLL = "action_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRollRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class MoveActionRollType0(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRollType0':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveActionRoll:
    """
    A move that makes an action roll.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    roll_type: 'MoveActionRollRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerActionRoll'
    """
    Trigger conditions for this move.
    """

    type: 'MoveActionRollType0'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRoll':
        return cls(
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MoveActionRollRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerActionRoll, data.get("trigger")),
            _from_json_data(MoveActionRollType0, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveActionRollEnhancementRollType(Enum):
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    ACTION_ROLL = "action_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRollEnhancementRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveActionRollEnhancement:
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    roll_type: 'MoveActionRollEnhancementRollType'
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    trigger: 'Optional[TriggerActionRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRollEnhancement':
        return cls(
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(MoveActionRollEnhancementRollType, data.get("roll_type")),
            _from_json_data(Optional[TriggerActionRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enhances"] = _to_json_data(self.enhances)
        data["roll_type"] = _to_json_data(self.roll_type)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

class MoveCategoryType(Enum):
    MOVE_CATEGORY = "move_category"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategoryType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveCategory:
    id: 'MoveCategoryID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    collections: 'Dict[str, MoveCategory]'
    contents: 'Dict[str, Move]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'MoveCategoryType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[MoveCategoryIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[MoveCategoryIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategory':
        return cls(
            _from_json_data(MoveCategoryID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(Dict[str, MoveCategory], data.get("collections")),
            _from_json_data(Dict[str, Move], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveCategoryType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[MoveCategoryIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[MoveCategoryIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["collections"] = _to_json_data(self.collections)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class MoveCategoryID:
    """
    A unique ID representing a MoveCategory object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategoryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveCategoryIDWildcard:
    """
    A wildcarded MoveCategoryId that can be used to match multiple MoveCategory
    objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategoryIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveEnhancement:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancement':
        variants: Dict[str, Type[MoveEnhancement]] = {
            "action_roll": MoveEnhancementActionRoll,
            "no_roll": MoveEnhancementNoRoll,
            "progress_roll": MoveEnhancementProgressRoll,
            "special_track": MoveEnhancementSpecialTrack,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class MoveEnhancementActionRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    trigger: 'Optional[TriggerActionRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementActionRoll':
        return cls(
            "action_roll",
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerActionRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementNoRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    trigger: 'Optional[TriggerNoRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementNoRoll':
        return cls(
            "no_roll",
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerNoRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementProgressRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    trigger: 'Optional[TriggerProgressRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerProgressRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementSpecialTrack(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    trigger: 'Optional[TriggerSpecialTrackEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementSpecialTrack':
        return cls(
            "special_track",
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerSpecialTrackEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveID:
    """
    A unique ID representing a Move object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveIDWildcard:
    """
    A wildcarded MoveId that can be used to match multiple Move objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class MoveNoRollRollType(Enum):
    NO_ROLL = "no_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRollRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class MoveNoRollType0(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRollType0':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveNoRoll:
    """
    A move that makes no progress rolls or action rolls.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    roll_type: 'MoveNoRollRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerNoRoll'
    """
    Trigger conditions for this move.
    """

    type: 'MoveNoRollType0'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRoll':
        return cls(
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveNoRollRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerNoRoll, data.get("trigger")),
            _from_json_data(MoveNoRollType0, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveNoRollEnhancementRollType(Enum):
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    NO_ROLL = "no_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRollEnhancementRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveNoRollEnhancement:
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    roll_type: 'MoveNoRollEnhancementRollType'
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    trigger: 'Optional[TriggerNoRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRollEnhancement':
        return cls(
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(MoveNoRollEnhancementRollType, data.get("roll_type")),
            _from_json_data(Optional[TriggerNoRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enhances"] = _to_json_data(self.enhances)
        data["roll_type"] = _to_json_data(self.roll_type)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveOracleRollableID:
    """
    A unique ID representing a MoveOracleRollable object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOracleRollableIDWildcard:
    """
    A wildcarded MoveOracleRollableId that can be used to match multiple
    MoveOracleRollable objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOracleRollableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOracleRollableRowID:
    """
    A unique ID representing a MoveOracleRollableRow object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOracleRollableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOracleRollableRowIDWildcard:
    """
    A wildcarded MoveOracleRollableRowId that can be used to match multiple
    MoveOracleRollableRow objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOracleRollableRowIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOutcome:
    text: 'MarkdownString'
    oracle_rolls: 'Optional[List[OracleRoll]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcome':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        return data

@dataclass
class MoveOutcomes:
    """
    A standalone localized description for each move outcome (miss, weak hit,
    or strong hit). This is for for e.g. VTT implementations, where it's often
    useful to display only the rules text relevant to a roll result.
    
      This often requires light editorialization to create text that can stand
    alone without reference to the rest of the move. For example, 'as above'
    (in reference to another move outcome) shouldn't be used here; instead, the
    relevant text should be repeated.
    """

    miss: 'MoveOutcome'
    strong_hit: 'MoveOutcome'
    weak_hit: 'MoveOutcome'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomes':
        return cls(
            _from_json_data(MoveOutcome, data.get("miss")),
            _from_json_data(MoveOutcome, data.get("strong_hit")),
            _from_json_data(MoveOutcome, data.get("weak_hit")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["miss"] = _to_json_data(self.miss)
        data["strong_hit"] = _to_json_data(self.strong_hit)
        data["weak_hit"] = _to_json_data(self.weak_hit)
        return data

class MoveProgressRollRollType(Enum):
    PROGRESS_ROLL = "progress_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRollRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class MoveProgressRollType0(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRollType0':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveProgressRoll:
    """
    A progress move that rolls on a standard progress track type (whose features
    are defined by this move object). For progress rolls that use special
    tracks, see MoveSpecialTrack.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    roll_type: 'MoveProgressRollRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    tracks: 'ProgressTrackTypeInfo'
    """
    Describes the common features of progress tracks associated with this move.
    """

    trigger: 'TriggerProgressRoll'
    """
    Trigger conditions for this move.
    """

    type: 'MoveProgressRollType0'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRoll':
        return cls(
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MoveProgressRollRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(ProgressTrackTypeInfo, data.get("tracks")),
            _from_json_data(TriggerProgressRoll, data.get("trigger")),
            _from_json_data(MoveProgressRollType0, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["tracks"] = _to_json_data(self.tracks)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveProgressRollEnhancementRollType(Enum):
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    PROGRESS_ROLL = "progress_roll"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRollEnhancementRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveProgressRollEnhancement:
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    roll_type: 'MoveProgressRollEnhancementRollType'
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    trigger: 'Optional[TriggerProgressRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRollEnhancement':
        return cls(
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(MoveProgressRollEnhancementRollType, data.get("roll_type")),
            _from_json_data(Optional[TriggerProgressRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enhances"] = _to_json_data(self.enhances)
        data["roll_type"] = _to_json_data(self.roll_type)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

class MoveRollType(Enum):
    ACTION_ROLL = "action_roll"
    """
    A move that makes an action roll.
    """

    NO_ROLL = "no_roll"
    """
    A move that makes no action rolls or progress rolls.
    """

    PROGRESS_ROLL = "progress_roll"
    """
    A progress move that rolls on a standard progress track type (defined by
    this move).
    """

    SPECIAL_TRACK = "special_track"
    """
    A progress move that rolls on one or more special tracks, like Bonds
    (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class MoveSpecialTrackRollType(Enum):
    SPECIAL_TRACK = "special_track"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrackRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class MoveSpecialTrackType0(Enum):
    MOVE = "move"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrackType0':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveSpecialTrack:
    """
    A progress move that rolls on a special track, such as Legacies (Starforged)
    or Bonds (classic Ironsworn). For progress moves that use standard progress
    tracks, see MoveProgressRoll instead.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    allow_momentum_burn: 'bool'
    """
    Is burning momentum allowed for this move?
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    outcomes: 'MoveOutcomes'
    roll_type: 'MoveSpecialTrackRollType'
    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerSpecialTrack'
    """
    Trigger conditions for this move.
    """

    type: 'MoveSpecialTrackType0'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    replaces: 'Optional[List[MoveIDWildcard]]'
    """
    Indicates that this move replaces the identified moves. References to the
    replaced moves can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrack':
        return cls(
            _from_json_data(MoveID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(bool, data.get("allow_momentum_burn")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(MoveSpecialTrackRollType, data.get("roll_type")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerSpecialTrack, data.get("trigger")),
            _from_json_data(MoveSpecialTrackType0, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["allow_momentum_burn"] = _to_json_data(self.allow_momentum_burn)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["roll_type"] = _to_json_data(self.roll_type)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class MoveSpecialTrackEnhancementRollType(Enum):
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    SPECIAL_TRACK = "special_track"
    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrackEnhancementRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveSpecialTrackEnhancement:
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[AnyMoveIDWildcard]'
    roll_type: 'MoveSpecialTrackEnhancementRollType'
    """
    A move must have this `roll_type` to receive this enhancement. This is in
    addition to any other restrictions made by other properties.
    """

    trigger: 'Optional[TriggerSpecialTrackEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrackEnhancement':
        return cls(
            _from_json_data(List[AnyMoveIDWildcard], data.get("enhances")),
            _from_json_data(MoveSpecialTrackEnhancementRollType, data.get("roll_type")),
            _from_json_data(Optional[TriggerSpecialTrackEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enhances"] = _to_json_data(self.enhances)
        data["roll_type"] = _to_json_data(self.roll_type)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

class NonCollectableType(Enum):
    DELVE_SITE = "delve_site"
    DELVE_SITE_DOMAIN = "delve_site_domain"
    DELVE_SITE_THEME = "delve_site_theme"
    RARITY = "rarity"
    TRUTH = "truth"
    @classmethod
    def from_json_data(cls, data: Any) -> 'NonCollectableType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class NpcType(Enum):
    NPC = "npc"
    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Npc:
    """
    A non-player character entry, similar to those in Chapter 5 of the Ironsworn
    Rulebook, or Chapter 4 of Starforged.
    """

    id: 'NpcID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    description: 'MarkdownString'
    drives: 'List[MarkdownString]'
    features: 'List[MarkdownString]'
    name: 'Label'
    nature: 'NpcNature'
    rank: 'ChallengeRank'
    """
    The suggested challenge rank for this NPC.
    """

    tactics: 'List[MarkdownString]'
    type: 'NpcType'
    variants: 'Dict[str, NpcVariant]'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    quest_starter: 'Optional[MarkdownString]'
    replaces: 'Optional[List[NpcIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    tags: 'Optional[Tags]'
    your_truth: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Npc':
        return cls(
            _from_json_data(NpcID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("drives")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcNature, data.get("nature")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(List[MarkdownString], data.get("tactics")),
            _from_json_data(NpcType, data.get("type")),
            _from_json_data(Dict[str, NpcVariant], data.get("variants")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[MarkdownString], data.get("quest_starter")),
            _from_json_data(Optional[List[NpcIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[MarkdownString], data.get("your_truth")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["description"] = _to_json_data(self.description)
        data["drives"] = _to_json_data(self.drives)
        data["features"] = _to_json_data(self.features)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["rank"] = _to_json_data(self.rank)
        data["tactics"] = _to_json_data(self.tactics)
        data["type"] = _to_json_data(self.type)
        data["variants"] = _to_json_data(self.variants)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.quest_starter is not None:
             data["quest_starter"] = _to_json_data(self.quest_starter)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.your_truth is not None:
             data["your_truth"] = _to_json_data(self.your_truth)
        return data

class NpcCollectionType(Enum):
    NPC_COLLECTION = "npc_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollectionType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class NpcCollection:
    id: 'NpcCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    collections: 'Dict[str, NpcCollection]'
    contents: 'Dict[str, Npc]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'NpcCollectionType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[NpcCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[NpcCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollection':
        return cls(
            _from_json_data(NpcCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(Dict[str, NpcCollection], data.get("collections")),
            _from_json_data(Dict[str, Npc], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcCollectionType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[NpcCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[NpcCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["collections"] = _to_json_data(self.collections)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class NpcCollectionID:
    """
    A unique ID representing a NpcCollection object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcCollectionIDWildcard:
    """
    A wildcarded NpcCollectionId that can be used to match multiple
    NpcCollection objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollectionIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcID:
    """
    A unique ID representing a Npc object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcIDWildcard:
    """
    A wildcarded NpcId that can be used to match multiple Npc objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcNature:
    """
    A localized category label describing the nature of this NPC.
    
    In Ironsworn classic, this is probably the singular form of the parent
    collection's name.
    
    For Starforged, see the table on p. 258 for examples.
    """

    value: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcNature':
        return cls(_from_json_data(Label, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcVariant:
    id: 'NpcVariantID'
    """
    The unique Datasworn ID for this node.
    """

    description: 'MarkdownString'
    name: 'Label'
    nature: 'NpcNature'
    rank: 'ChallengeRank'
    """
    The suggested challenge rank for this NPC.
    """

    comment: 'Optional[Documentation]'
    summary: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariant':
        return cls(
            _from_json_data(NpcVariantID, data.get("_id")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcNature, data.get("nature")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["description"] = _to_json_data(self.description)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["rank"] = _to_json_data(self.rank)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class NpcVariantID:
    """
    A unique ID representing a NpcVariant object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariantID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcVariantIDWildcard:
    """
    A wildcarded NpcVariantId that can be used to match multiple NpcVariant
    objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariantIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleCollection:
    oracle_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollection':
        variants: Dict[str, Type[OracleCollection]] = {
            "table_shared_rolls": OracleCollectionTableSharedRolls,
            "table_shared_text": OracleCollectionTableSharedText,
            "table_shared_text2": OracleCollectionTableSharedText2,
            "table_shared_text3": OracleCollectionTableSharedText3,
            "tables": OracleCollectionTables,
        }

        return variants[data["oracle_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class OracleCollectionTableSharedRollsColumnLabels:
    """
    Provides column labels for this table. The `roll` key refers to the roll
    column showing the dice range (`min` and `max` on each table row). For all
    other column labels, see the `name` property of each child `OracleColumn`.
    """

    roll: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedRollsColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        return data

class OracleCollectionTableSharedRollsType(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedRollsType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollectionTableSharedRolls(OracleCollection):
    """
    An OracleCollection representing a single table with one roll column and
    multiple text columns.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleCollectionTableSharedRollsColumnLabels'
    """
    Provides column labels for this table. The `roll` key refers to the roll
    column showing the dice range (`min` and `max` on each table row). For all
    other column labels, see the `name` property of each child `OracleColumn`.
    """

    contents: 'Dict[str, OracleColumnText]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'OracleCollectionTableSharedRollsType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedRolls':
        return cls(
            "table_shared_rolls",
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleCollectionTableSharedRollsColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleCollectionTableSharedRollsType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_rolls" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionTableSharedTextColumnLabels:
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

class OracleCollectionTableSharedTextType(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollectionTableSharedText(OracleCollection):
    """
    An OracleCollection representing a single table with multiple roll columns
    and one text column.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleCollectionTableSharedTextColumnLabels'
    contents: 'Dict[str, OracleColumnText]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'OracleCollectionTableSharedTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText':
        return cls(
            "table_shared_text",
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleCollectionTableSharedTextColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleCollectionTableSharedTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_text" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionTableSharedText2ColumnLabels:
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class OracleCollectionTableSharedText2Type(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollectionTableSharedText2(OracleCollection):
    """
    An OracleCollection representing a single table with multiple roll columns,
    and 2 shared text columns.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleCollectionTableSharedText2ColumnLabels'
    contents: 'Dict[str, OracleColumnText2]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'OracleCollectionTableSharedText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText2':
        return cls(
            "table_shared_text2",
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleCollectionTableSharedText2ColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText2], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleCollectionTableSharedText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_text2" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionTableSharedText3ColumnLabels:
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class OracleCollectionTableSharedText3Type(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollectionTableSharedText3(OracleCollection):
    """
    An OracleCollection representing a single table with multiple roll columns,
    and 3 shared text columns.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleCollectionTableSharedText3ColumnLabels'
    contents: 'Dict[str, OracleColumnText3]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'OracleCollectionTableSharedText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedText3':
        return cls(
            "table_shared_text3",
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleCollectionTableSharedText3ColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText3], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleCollectionTableSharedText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_text3" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleCollectionTablesType(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTablesType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollectionTables(OracleCollection):
    """
    An OracleCollection that represents a category or grouping of tables, which
    may themselves be `OracleTablesCollection`s.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    collections: 'Dict[str, OracleCollection]'
    contents: 'Dict[str, OracleRollableTable]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'OracleCollectionTablesType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTables':
        return cls(
            "tables",
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(Dict[str, OracleCollection], data.get("collections")),
            _from_json_data(Dict[str, OracleRollableTable], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleCollectionTablesType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "tables" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["collections"] = _to_json_data(self.collections)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionID:
    """
    A unique ID representing an OracleCollection object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleCollectionIDWildcard:
    """
    A wildcarded OracleCollectionId that can be used to match multiple
    OracleCollection objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class OracleColumnTextOracleType(Enum):
    COLUMN_TEXT = "column_text"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnTextOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleColumnTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleColumnTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleColumnText:
    """
    Represents a single column in an OracleCollection.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleColumnTextOracleType'
    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleColumnTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleColumnTextRecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText':
        return cls(
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleColumnTextOracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(OracleColumnTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleColumnTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleColumnText2OracleType(Enum):
    COLUMN_TEXT2 = "column_text2"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText2OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleColumnText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleColumnText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleColumnText2:
    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleColumnText2OracleType'
    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleColumnText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleColumnText2RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText2':
        return cls(
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleColumnText2OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(OracleColumnText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleColumnText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleColumnText3OracleType(Enum):
    COLUMN_TEXT3 = "column_text3"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText3OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleColumnText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleColumnText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleColumnText3:
    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleColumnText3OracleType'
    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleColumnText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleColumnText3RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnText3':
        return cls(
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleColumnText3OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(OracleColumnText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleColumnText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleDuplicateBehavior(Enum):
    """
    Special roll instructions to use when rolling multiple times on a single
    oracle.
    """

    KEEP = "keep"
    """
    Duplicates results should be kept.
    """

    MAKE_IT_WORSE = "make_it_worse"
    """
    Duplicate results should be kept, and they compound to make things worse.
    """

    REROLL = "reroll"
    """
    Duplicate results should be re-rolled.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleDuplicateBehavior':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleMatchBehavior:
    text: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleMatchBehavior':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class OracleRoll:
    auto: 'bool'
    """
    Both Ironsworn and Starforged explicitly recommend *against* rolling
    all details at once. That said, some oracle results only provide useful
    information once a secondary roll occurs, such as "Action + Theme" or "Roll
    twice".
    """

    dice: 'DiceExpression'
    duplicates: 'OracleDuplicateBehavior'
    """
    Special rules on how to handle duplicate results, when rolling multiple
    times.
    """

    number_of_rolls: 'int'
    """
    The number of times to roll.
    """

    oracle: 'OracleRollableID'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRoll':
        return cls(
            _from_json_data(bool, data.get("auto")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleDuplicateBehavior, data.get("duplicates")),
            _from_json_data(int, data.get("number_of_rolls")),
            _from_json_data(OracleRollableID, data.get("oracle")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["auto"] = _to_json_data(self.auto)
        data["dice"] = _to_json_data(self.dice)
        data["duplicates"] = _to_json_data(self.duplicates)
        data["number_of_rolls"] = _to_json_data(self.number_of_rolls)
        data["oracle"] = _to_json_data(self.oracle)
        return data

@dataclass
class OracleRollTemplate:
    """
    Provides string templates that may be used in place of the static row
    text from `OracleRollableRow#text`, `OracleRollableRow#text2`, and
    `OracleRollableRow#text3`.
    
      These strings are formatted in Markdown, but use a special syntax
    for their placeholders: `{{text>some_oracle_rollable_id}}`. The
    placeholder should be replaced with the value of a rolled (or selected)
    `OracleRollableRow#text` from the target oracle rollable ID.
    """

    text: 'Optional[MarkdownTemplateString]'
    """
    A string template that may be used in place of OracleRollableRow#text.
    """

    text2: 'Optional[MarkdownTemplateString]'
    """
    A string template that may be used in place of OracleRollableRow#text2.
    """

    text3: 'Optional[MarkdownTemplateString]'
    """
    A string template that may be used in place of OracleRollableRow#text3.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollTemplate':
        return cls(
            _from_json_data(Optional[MarkdownTemplateString], data.get("text")),
            _from_json_data(Optional[MarkdownTemplateString], data.get("text2")),
            _from_json_data(Optional[MarkdownTemplateString], data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        if self.text2 is not None:
             data["text2"] = _to_json_data(self.text2)
        if self.text3 is not None:
             data["text3"] = _to_json_data(self.text3)
        return data

@dataclass
class OracleRollable:
    """
    A collection of table rows from which random results may be rolled. This may
    represent a standalone table, or a column in a larger table.
    """

    oracle_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollable':
        variants: Dict[str, Type[OracleRollable]] = {
            "column_text": OracleRollableColumnText,
            "column_text2": OracleRollableColumnText2,
            "column_text3": OracleRollableColumnText3,
            "table_text": OracleRollableTableText,
            "table_text2": OracleRollableTableText2,
            "table_text3": OracleRollableTableText3,
        }

        return variants[data["oracle_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class OracleRollableColumnTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableColumnTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableColumnText(OracleRollable):
    """
    Represents a single column in an OracleCollection.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableColumnTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableColumnTextRecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText':
        return cls(
            "column_text",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(OracleRollableColumnTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableColumnTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "column_text" }
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleRollableColumnText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableColumnText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableColumnText2(OracleRollable):
    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableColumnText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableColumnText2RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText2':
        return cls(
            "column_text2",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(OracleRollableColumnText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableColumnText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "column_text2" }
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleRollableColumnText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableColumnText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableColumnText3(OracleRollable):
    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableColumnText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableColumnText3RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableColumnText3':
        return cls(
            "column_text3",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(OracleRollableColumnText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableColumnText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "column_text3" }
        data["_id"] = _to_json_data(self.id)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleRollableTableTextColumnLabels:
    roll: 'Label'
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        return data

class OracleRollableTableTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableTableTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableTableText(OracleRollable):
    """
    Represents a basic rollable oracle table with one roll column and one text
    result column.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleRollableTableTextColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableTableTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableTableTextRecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText':
        return cls(
            "table_text",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleRollableTableTextColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(OracleRollableTableTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableTableTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleRollableTableText2ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class OracleRollableTableText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableTableText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableTableText2(OracleRollable):
    """
    A rollable oracle table with one roll column and two text columns.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleRollableTableText2ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableTableText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableTableText2RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText2':
        return cls(
            "table_text2",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleRollableTableText2ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(OracleRollableTableText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableTableText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text2" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleRollableTableText3ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class OracleRollableTableText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableTableText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableTableText3(OracleRollable):
    """
    A rollable oracle table with one roll column and 3 text columns.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleRollableTableText3ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableTableText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableTableText3RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableText3':
        return cls(
            "table_text3",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleRollableTableText3ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(OracleRollableTableText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableTableText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text3" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleRollableID:
    """
    A unique ID representing an OracleRollable object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleRollableIDWildcard:
    """
    A wildcarded OracleRollableId that can be used to match multiple
    OracleRollable objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleRollableRowID:
    """
    A unique ID representing an OracleRollableRow object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleRollableRowIDWildcard:
    """
    A wildcarded OracleRollableRowId that can be used to match multiple
    OracleRollableRow objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableRowIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleRollableRowText:
    """
    Represents a row in an oracle table, with a single text cell.
    """

    id: 'AnyOracleRollableRowID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableRowText':
        return cls(
            _from_json_data(AnyOracleRollableRowID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleRollableRowText2:
    """
    Represents a row in an oracle table that provides a secondary text field.
    """

    id: 'AnyOracleRollableRowID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    text2: 'MarkdownString'
    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableRowText2':
        return cls(
            _from_json_data(AnyOracleRollableRowID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(MarkdownString, data.get("text2")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleRollableRowText3:
    """
    Represents a row in an oracle table with 3 text cells.
    """

    id: 'AnyOracleRollableRowID'
    roll: 'DiceRange'
    text: 'MarkdownString'
    """
    The primary text content of this row.
    """

    text2: 'MarkdownString'
    text3: 'MarkdownString'
    i18n: 'Optional[I18nHints]'
    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableRowText3':
        return cls(
            _from_json_data(AnyOracleRollableRowID, data.get("_id")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(MarkdownString, data.get("text2")),
            _from_json_data(MarkdownString, data.get("text3")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleRollableTable:
    oracle_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTable':
        variants: Dict[str, Type[OracleRollableTable]] = {
            "table_text": OracleRollableTableTableText,
            "table_text2": OracleRollableTableTableText2,
            "table_text3": OracleRollableTableTableText3,
        }

        return variants[data["oracle_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class OracleRollableTableTableTextColumnLabels:
    roll: 'Label'
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        return data

class OracleRollableTableTableTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableTableTableTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableTableTableText(OracleRollableTable):
    """
    Represents a basic rollable oracle table with one roll column and one text
    result column.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleRollableTableTableTextColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableTableTableTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableTableTableTextRecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText':
        return cls(
            "table_text",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleRollableTableTableTextColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(OracleRollableTableTableTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableTableTableTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleRollableTableTableText2ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class OracleRollableTableTableText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableTableTableText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableTableTableText2(OracleRollableTable):
    """
    A rollable oracle table with one roll column and two text columns.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleRollableTableTableText2ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableTableTableText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableTableTableText2RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText2':
        return cls(
            "table_text2",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleRollableTableTableText2ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(OracleRollableTableTableText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableTableTableText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text2" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleRollableTableTableText3ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class OracleRollableTableTableText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollableTableTableText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleRollableTableTableText3(OracleRollableTable):
    """
    A rollable oracle table with one roll column and 3 text columns.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleRollableTableTableText3ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleRollableTableTableText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleRollableTableTableText3RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableTableTableText3':
        return cls(
            "table_text3",
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleRollableTableTableText3ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(OracleRollableTableTableText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableTableTableText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_text3" }
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableSharedRollsColumnLabels:
    """
    Provides column labels for this table. The `roll` key refers to the roll
    column showing the dice range (`min` and `max` on each table row). For all
    other column labels, see the `name` property of each child `OracleColumn`.
    """

    roll: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedRollsColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        return data

class OracleTableSharedRollsOracleType(Enum):
    TABLE_SHARED_ROLLS = "table_shared_rolls"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedRollsOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableSharedRollsType(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedRollsType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableSharedRolls:
    """
    An OracleCollection representing a single table with one roll column and
    multiple text columns.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableSharedRollsColumnLabels'
    """
    Provides column labels for this table. The `roll` key refers to the roll
    column showing the dice range (`min` and `max` on each table row). For all
    other column labels, see the `name` property of each child `OracleColumn`.
    """

    contents: 'Dict[str, OracleColumnText]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableSharedRollsOracleType'
    type: 'OracleTableSharedRollsType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedRolls':
        return cls(
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableSharedRollsColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableSharedRollsOracleType, data.get("oracle_type")),
            _from_json_data(OracleTableSharedRollsType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableSharedTextColumnLabels:
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

class OracleTableSharedTextOracleType(Enum):
    TABLE_SHARED_TEXT = "table_shared_text"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedTextOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableSharedTextType(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableSharedText:
    """
    An OracleCollection representing a single table with multiple roll columns
    and one text column.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableSharedTextColumnLabels'
    contents: 'Dict[str, OracleColumnText]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableSharedTextOracleType'
    type: 'OracleTableSharedTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText':
        return cls(
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableSharedTextColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableSharedTextOracleType, data.get("oracle_type")),
            _from_json_data(OracleTableSharedTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableSharedText2ColumnLabels:
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class OracleTableSharedText2OracleType(Enum):
    TABLE_SHARED_TEXT2 = "table_shared_text2"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText2OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableSharedText2Type(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableSharedText2:
    """
    An OracleCollection representing a single table with multiple roll columns,
    and 2 shared text columns.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableSharedText2ColumnLabels'
    contents: 'Dict[str, OracleColumnText2]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableSharedText2OracleType'
    type: 'OracleTableSharedText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText2':
        return cls(
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableSharedText2ColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText2], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableSharedText2OracleType, data.get("oracle_type")),
            _from_json_data(OracleTableSharedText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableSharedText3ColumnLabels:
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class OracleTableSharedText3OracleType(Enum):
    TABLE_SHARED_TEXT3 = "table_shared_text3"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText3OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableSharedText3Type(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableSharedText3:
    """
    An OracleCollection representing a single table with multiple roll columns,
    and 3 shared text columns.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableSharedText3ColumnLabels'
    contents: 'Dict[str, OracleColumnText3]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableSharedText3OracleType'
    type: 'OracleTableSharedText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableSharedText3':
        return cls(
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableSharedText3ColumnLabels, data.get("column_labels")),
            _from_json_data(Dict[str, OracleColumnText3], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableSharedText3OracleType, data.get("oracle_type")),
            _from_json_data(OracleTableSharedText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableTextColumnLabels:
    roll: 'Label'
    text: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableTextColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        return data

class OracleTableTextOracleType(Enum):
    TABLE_TEXT = "table_text"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableTextOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableTextType(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableTextType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableTextRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableTextRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleTableText:
    """
    Represents a basic rollable oracle table with one roll column and one text
    result column.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableTextColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableTextOracleType'
    rows: 'List[OracleRollableRowText]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleTableTextType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleTableTextRecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText':
        return cls(
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableTextColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableTextOracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText], data.get("rows")),
            _from_json_data(OracleTableTextType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableTextRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableText2ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText2ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        return data

class OracleTableText2OracleType(Enum):
    TABLE_TEXT2 = "table_text2"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText2OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableText2Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText2Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableText2RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText2RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleTableText2:
    """
    A rollable oracle table with one roll column and two text columns.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableText2ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableText2OracleType'
    rows: 'List[OracleRollableRowText2]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleTableText2Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleTableText2RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText2':
        return cls(
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableText2ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableText2OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText2], data.get("rows")),
            _from_json_data(OracleTableText2Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableText2RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableText3ColumnLabels:
    roll: 'Label'
    text: 'Label'
    text2: 'Label'
    text3: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText3ColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
            _from_json_data(Label, data.get("text")),
            _from_json_data(Label, data.get("text2")),
            _from_json_data(Label, data.get("text3")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        data["text"] = _to_json_data(self.text)
        data["text2"] = _to_json_data(self.text2)
        data["text3"] = _to_json_data(self.text3)
        return data

class OracleTableText3OracleType(Enum):
    TABLE_TEXT3 = "table_text3"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText3OracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTableText3Type(Enum):
    ORACLE_ROLLABLE = "oracle_rollable"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText3Type':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableText3RecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText3RecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleTableText3:
    """
    A rollable oracle table with one roll column and 3 text columns.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    column_labels: 'OracleTableText3ColumnLabels'
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTableText3OracleType'
    rows: 'List[OracleRollableRowText3]'
    """
    An array of objects, each representing a single row of the table.
    """

    type: 'OracleTableText3Type'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleTableText3RecommendedRolls]'
    replaces: 'Optional[List[OracleRollableIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableText3':
        return cls(
            _from_json_data(OracleRollableID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(OracleTableText3ColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTableText3OracleType, data.get("oracle_type")),
            _from_json_data(List[OracleRollableRowText3], data.get("rows")),
            _from_json_data(OracleTableText3Type, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableText3RecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[List[OracleRollableIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleTablesCollectionOracleType(Enum):
    TABLES = "tables"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTablesCollectionOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleTablesCollectionType(Enum):
    ORACLE_COLLECTION = "oracle_collection"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTablesCollectionType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTablesCollection:
    """
    An OracleCollection that represents a category or grouping of tables, which
    may themselves be `OracleTablesCollection`s.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    collections: 'Dict[str, OracleCollection]'
    contents: 'Dict[str, OracleRollableTable]'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    oracle_type: 'OracleTablesCollectionOracleType'
    type: 'OracleTablesCollectionType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node's content enhances all nodes that match these wildcards, rather
    than being a standalone item of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[OracleCollectionIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTablesCollection':
        return cls(
            _from_json_data(OracleCollectionID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(Dict[str, OracleCollection], data.get("collections")),
            _from_json_data(Dict[str, OracleRollableTable], data.get("contents")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTablesCollectionOracleType, data.get("oracle_type")),
            _from_json_data(OracleTablesCollectionType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[OracleCollectionIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["collections"] = _to_json_data(self.collections)
        data["contents"] = _to_json_data(self.contents)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class PageNumber:
    """
    Represents a page number in a book.
    """

    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'PageNumber':
        return cls(_from_json_data(int, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class PartOfSpeech(Enum):
    ADJECTIVE = "adjective"
    """
    An adjective.
    """

    ADJECTIVE_AS_PROPER_NOUN = "adjective_as_proper_noun"
    """
    An adjective used as a proper noun.
    """

    ADJUNCT_COMMON_NOUN = "adjunct_common_noun"
    """
    A common noun used as an adjective, to modify another noun.
    """

    ADJUNCT_PROPER_NOUN = "adjunct_proper_noun"
    """
    A proper noun used as an adjective, to modify another noun.
    """

    ATTRIBUTIVE_VERB = "attributive_verb"
    """
    A verb used as an adjective, to modify a noun.
    """

    COMMON_NOUN = "common_noun"
    """
    A common noun.
    """

    COMMON_NOUN_AS_PROPER_NOUN = "common_noun_as_proper_noun"
    """
    An common noun used as a proper noun.
    """

    GERUND = "gerund"
    """
    Gerund or present participle of a verb, e.g. "going", "seeing", "waving".
    Can function as a noun, an adjective, or a progressive verb.
    """

    PROPER_NOUN = "proper_noun"
    """
    A proper noun.
    """

    VERB = "verb"
    """
    A verb in present tense
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'PartOfSpeech':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressRollMethod(Enum):
    MISS = "miss"
    """
    An automatic miss.
    """

    PROGRESS_ROLL = "progress_roll"
    """
    Make a progress roll on a progress track associated with this move.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressRollOptionUsing(Enum):
    PROGRESS_TRACK = "progress_track"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollOptionUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ProgressRollOption:
    using: 'ProgressRollOptionUsing'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollOption':
        return cls(
            _from_json_data(ProgressRollOptionUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class ProgressTrackTypeInfo:
    """
    Describes the features of a type of progress track.
    """

    category: 'Label'
    """
    A category label for progress tracks of this type.
    """

    controls: 'Optional[Dict[str, Any]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressTrackTypeInfo':
        return cls(
            _from_json_data(Label, data.get("category")),
            _from_json_data(Optional[Dict[str, Any]], data.get("controls")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["category"] = _to_json_data(self.category)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        return data

class RarityType(Enum):
    RARITY = "rarity"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RarityType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Rarity:
    """
    A rarity, as described in Ironsworn: Delve.
    """

    id: 'RarityID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    asset: 'AssetID'
    """
    The asset augmented by this rarity.
    """

    name: 'Label'
    """
    The primary name/label for this node.
    """

    type: 'RarityType'
    xp_cost: 'int'
    """
    From Ironsworn: Delve, p. 174:
    
          Some assets will bring a rarity into play more often than others, so
    the experience point cost for a rarity will vary by the linked asset. These
    costs are shown in the tables on page 175.
    
          If you are playing solo, and aren’t concerned with the relative
    balance of rarity abilities, you can ignore these variable costs. If so,
    spend 3 experience points to purchase a rarity.
    """

    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[RarityIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Rarity':
        return cls(
            _from_json_data(RarityID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(AssetID, data.get("asset")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(RarityType, data.get("type")),
            _from_json_data(int, data.get("xp_cost")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[RarityIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["asset"] = _to_json_data(self.asset)
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        data["xp_cost"] = _to_json_data(self.xp_cost)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class RarityID:
    """
    A unique ID representing a Rarity object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RarityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class RarityIDWildcard:
    """
    A wildcarded RarityId that can be used to match multiple Rarity objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RarityIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class RollableValue:
    """
    Provides a value like a stat, condition meter, or other number (usually for
    use in an action roll). The expected value is an integer, or null.
    """

    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValue':
        variants: Dict[str, Type[RollableValue]] = {
            "asset_control": RollableValueAssetControl,
            "asset_option": RollableValueAssetOption,
            "attached_asset_control": RollableValueAttachedAssetControl,
            "attached_asset_option": RollableValueAttachedAssetOption,
            "condition_meter": RollableValueConditionMeter,
            "custom": RollableValueCustom,
            "stat": RollableValueStat,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class RollableValueAssetControl(RollableValue):
    """
    A reference to the value of an asset control.
    """

    assets: 'List[AssetIDWildcard]'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAssetControl':
        return cls(
            "asset_control",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("control")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_control" }
        data["assets"] = _to_json_data(self.assets)
        data["control"] = _to_json_data(self.control)
        return data

@dataclass
class RollableValueAssetOption(RollableValue):
    """
    A reference to the value of an asset option.
    """

    assets: 'List[AssetIDWildcard]'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAssetOption':
        return cls(
            "asset_option",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_option" }
        data["assets"] = _to_json_data(self.assets)
        data["option"] = _to_json_data(self.option)
        return data

@dataclass
class RollableValueAttachedAssetControl(RollableValue):
    """
    A reference to the value of an attached asset control. For example, a Module
    asset could use this to roll using the `integrity` control of an attached
    Vehicle.
    """

    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAttachedAssetControl':
        return cls(
            "attached_asset_control",
            _from_json_data(DictKey, data.get("control")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_control" }
        data["control"] = _to_json_data(self.control)
        return data

@dataclass
class RollableValueAttachedAssetOption(RollableValue):
    """
    A reference to the value of an attached asset option.
    """

    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAttachedAssetOption':
        return cls(
            "attached_asset_option",
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_option" }
        data["option"] = _to_json_data(self.option)
        return data

@dataclass
class RollableValueConditionMeter(RollableValue):
    """
    A reference to the value of a standard player condition meter.
    """

    condition_meter: 'ConditionMeterKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "condition_meter" }
        data["condition_meter"] = _to_json_data(self.condition_meter)
        return data

@dataclass
class RollableValueCustom(RollableValue):
    """
    An arbitrary static integer value with a label.
    """

    label: 'Label'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueCustom':
        return cls(
            "custom",
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class RollableValueStat(RollableValue):
    """
    A reference to the value of a standard player character stat.
    """

    stat: 'StatKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueStat':
        return cls(
            "stat",
            _from_json_data(StatKey, data.get("stat")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "stat" }
        data["stat"] = _to_json_data(self.stat)
        return data

@dataclass
class Rules:
    """
    Describes rules for player characters in this ruleset, such as stats and
    condition meters.
    """

    condition_meters: 'Dict[str, ConditionMeterRule]'
    """
    Describes the standard condition meters used by player characters in this
    ruleset.
    """

    impacts: 'Dict[str, ImpactCategory]'
    """
    Describes the standard impacts/debilities used by player characters in this
    ruleset.
    """

    special_tracks: 'Dict[str, SpecialTrackRule]'
    """
    Describes the special tracks used by player characters in this ruleset, like
    Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    stats: 'Dict[str, StatRule]'
    """
    Describes the standard stats used by player characters in this ruleset.
    """

    tags: 'Dict[str, TagRule]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Rules':
        return cls(
            _from_json_data(Dict[str, ConditionMeterRule], data.get("condition_meters")),
            _from_json_data(Dict[str, ImpactCategory], data.get("impacts")),
            _from_json_data(Dict[str, SpecialTrackRule], data.get("special_tracks")),
            _from_json_data(Dict[str, StatRule], data.get("stats")),
            _from_json_data(Dict[str, TagRule], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["condition_meters"] = _to_json_data(self.condition_meters)
        data["impacts"] = _to_json_data(self.impacts)
        data["special_tracks"] = _to_json_data(self.special_tracks)
        data["stats"] = _to_json_data(self.stats)
        data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class RulesExpansion:
    """
    Describes rules for player characters in this ruleset, such as stats and
    condition meters.
    """

    condition_meters: 'Optional[Dict[str, ConditionMeterRule]]'
    """
    Describes the standard condition meters used by player characters in this
    ruleset.
    """

    impacts: 'Optional[Dict[str, ImpactCategory]]'
    """
    Describes the standard impacts/debilities used by player characters in this
    ruleset.
    """

    special_tracks: 'Optional[Dict[str, SpecialTrackRule]]'
    """
    Describes the special tracks used by player characters in this ruleset, like
    Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    stats: 'Optional[Dict[str, StatRule]]'
    """
    Describes the standard stats used by player characters in this ruleset.
    """

    tags: 'Optional[Dict[str, TagRule]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesExpansion':
        return cls(
            _from_json_data(Optional[Dict[str, ConditionMeterRule]], data.get("condition_meters")),
            _from_json_data(Optional[Dict[str, ImpactCategory]], data.get("impacts")),
            _from_json_data(Optional[Dict[str, SpecialTrackRule]], data.get("special_tracks")),
            _from_json_data(Optional[Dict[str, StatRule]], data.get("stats")),
            _from_json_data(Optional[Dict[str, TagRule]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.condition_meters is not None:
             data["condition_meters"] = _to_json_data(self.condition_meters)
        if self.impacts is not None:
             data["impacts"] = _to_json_data(self.impacts)
        if self.special_tracks is not None:
             data["special_tracks"] = _to_json_data(self.special_tracks)
        if self.stats is not None:
             data["stats"] = _to_json_data(self.stats)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class RulesPackageID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class RulesetDataswornVersion(Enum):
    """
    The version of the Datasworn format used by this data.
    """

    DEFAULT_NAME = "0.1.0"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesetDataswornVersion':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class RulesetType(Enum):
    RULESET = "ruleset"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesetType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Ruleset:
    """
    A standalone Datasworn package that describes its own ruleset.
    """

    id: 'RulesetID'
    assets: 'Dict[str, AssetCollection]'
    """
    A dictionary object containing asset collections, which contain assets.
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    datasworn_version: 'RulesetDataswornVersion'
    """
    The version of the Datasworn format used by this data.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'WebURL'
    moves: 'Dict[str, MoveCategory]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    oracles: 'Dict[str, OracleTablesCollection]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    rules: 'Rules'
    title: 'Label'
    """
    The title of the source document.
    """

    type: 'RulesetType'
    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    atlas: 'Optional[Dict[str, AtlasCollection]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    description: 'Optional[MarkdownString]'
    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Ruleset':
        return cls(
            _from_json_data(RulesetID, data.get("_id")),
            _from_json_data(Dict[str, AssetCollection], data.get("assets")),
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(RulesetDataswornVersion, data.get("datasworn_version")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(WebURL, data.get("license")),
            _from_json_data(Dict[str, MoveCategory], data.get("moves")),
            _from_json_data(Dict[str, OracleTablesCollection], data.get("oracles")),
            _from_json_data(Rules, data.get("rules")),
            _from_json_data(Label, data.get("title")),
            _from_json_data(RulesetType, data.get("type")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[Dict[str, AtlasCollection]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["assets"] = _to_json_data(self.assets)
        data["authors"] = _to_json_data(self.authors)
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["moves"] = _to_json_data(self.moves)
        data["oracles"] = _to_json_data(self.oracles)
        data["rules"] = _to_json_data(self.rules)
        data["title"] = _to_json_data(self.title)
        data["type"] = _to_json_data(self.type)
        data["url"] = _to_json_data(self.url)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

@dataclass
class RulesetID:
    """
    The ID of standalone Datasworn package that describes its own ruleset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SelectEnhancementFieldChoice0:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoice0':
        variants: Dict[str, Type[SelectEnhancementFieldChoice0]] = {
            "choice": SelectEnhancementFieldChoiceChoice,
            "choice_group": SelectEnhancementFieldChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class SelectEnhancementFieldChoiceChoice(SelectEnhancementFieldChoice0):
    """
    Represents an option in a list of choices.
    """

    label: 'Label'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceChoice':
        return cls(
            "choice",
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class SelectEnhancementFieldChoiceChoiceGroup(SelectEnhancementFieldChoice0):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'Label'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(Label, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

class SelectEnhancementFieldFieldType(Enum):
    SELECT_ENHANCEMENT = "select_enhancement"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectEnhancementField:
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice0]'
    field_type: 'SelectEnhancementFieldFieldType'
    label: 'Label'
    value: 'DictKey'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementField':
        return cls(
            _from_json_data(Dict[str, SelectEnhancementFieldChoice0], data.get("choices")),
            _from_json_data(SelectEnhancementFieldFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["choices"] = _to_json_data(self.choices)
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

class SelectEnhancementFieldChoiceChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectEnhancementFieldChoice:
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectEnhancementFieldChoiceChoiceType'
    label: 'Label'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoice':
        return cls(
            _from_json_data(SelectEnhancementFieldChoiceChoiceType, data.get("choice_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

class SelectEnhancementFieldChoiceGroupChoiceType(Enum):
    CHOICE_GROUP = "choice_group"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceGroupChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectEnhancementFieldChoiceGroup:
    """
    Represents a grouping of options in a list of choices.
    """

    choice_type: 'SelectEnhancementFieldChoiceGroupChoiceType'
    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'Label'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceGroup':
        return cls(
            _from_json_data(SelectEnhancementFieldChoiceGroupChoiceType, data.get("choice_type")),
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(Label, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["choice_type"] = _to_json_data(self.choice_type)
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

class SelectValueFieldFieldType(Enum):
    SELECT_VALUE = "select_value"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueField:
    """
    Represents a list of mutually exclusive choices.
    """

    choices: 'Dict[str, SelectValueFieldChoice]'
    field_type: 'SelectValueFieldFieldType'
    label: 'Label'
    value: 'DictKey'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueField':
        return cls(
            _from_json_data(Dict[str, SelectValueFieldChoice], data.get("choices")),
            _from_json_data(SelectValueFieldFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["choices"] = _to_json_data(self.choices)
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class SelectValueFieldChoice:
    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoice':
        variants: Dict[str, Type[SelectValueFieldChoice]] = {
            "asset_control": SelectValueFieldChoiceAssetControl,
            "asset_option": SelectValueFieldChoiceAssetOption,
            "attached_asset_control": SelectValueFieldChoiceAttachedAssetControl,
            "attached_asset_option": SelectValueFieldChoiceAttachedAssetOption,
            "condition_meter": SelectValueFieldChoiceConditionMeter,
            "custom": SelectValueFieldChoiceCustom,
            "stat": SelectValueFieldChoiceStat,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class SelectValueFieldChoiceAssetControlChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetControlChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAssetControl(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    assets: 'List[AssetIDWildcard]'
    choice_type: 'SelectValueFieldChoiceAssetControlChoiceType'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    label: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetControl':
        return cls(
            "asset_control",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(SelectValueFieldChoiceAssetControlChoiceType, data.get("choice_type")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(Label, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_control" }
        data["assets"] = _to_json_data(self.assets)
        data["choice_type"] = _to_json_data(self.choice_type)
        data["control"] = _to_json_data(self.control)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceAssetOptionChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetOptionChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAssetOption(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    assets: 'List[AssetIDWildcard]'
    choice_type: 'SelectValueFieldChoiceAssetOptionChoiceType'
    label: 'Label'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetOption':
        return cls(
            "asset_option",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(SelectValueFieldChoiceAssetOptionChoiceType, data.get("choice_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_option" }
        data["assets"] = _to_json_data(self.assets)
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["option"] = _to_json_data(self.option)
        return data

class SelectValueFieldChoiceAttachedAssetControlChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetControlChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAttachedAssetControl(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceAttachedAssetControlChoiceType'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    label: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetControl':
        return cls(
            "attached_asset_control",
            _from_json_data(SelectValueFieldChoiceAttachedAssetControlChoiceType, data.get("choice_type")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(Label, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_control" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["control"] = _to_json_data(self.control)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceAttachedAssetOptionChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetOptionChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAttachedAssetOption(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceAttachedAssetOptionChoiceType'
    label: 'Label'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetOption':
        return cls(
            "attached_asset_option",
            _from_json_data(SelectValueFieldChoiceAttachedAssetOptionChoiceType, data.get("choice_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_option" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["option"] = _to_json_data(self.option)
        return data

class SelectValueFieldChoiceConditionMeterChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceConditionMeterChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceConditionMeter(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceConditionMeterChoiceType'
    condition_meter: 'ConditionMeterKey'
    label: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(SelectValueFieldChoiceConditionMeterChoiceType, data.get("choice_type")),
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
            _from_json_data(Label, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "condition_meter" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["condition_meter"] = _to_json_data(self.condition_meter)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceCustomChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceCustomChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceCustom(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceCustomChoiceType'
    label: 'Label'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceCustom':
        return cls(
            "custom",
            _from_json_data(SelectValueFieldChoiceCustomChoiceType, data.get("choice_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

class SelectValueFieldChoiceStatChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceStatChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceStat(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceStatChoiceType'
    label: 'Label'
    stat: 'StatKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceStat':
        return cls(
            "stat",
            _from_json_data(SelectValueFieldChoiceStatChoiceType, data.get("choice_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(StatKey, data.get("stat")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "stat" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["stat"] = _to_json_data(self.stat)
        return data

@dataclass
class SemanticVersion:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SemanticVersion':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SourceInfo:
    """
    Metadata describing the original source of this node
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'WebURL'
    title: 'Label'
    """
    The title of the source document.
    """

    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    page: 'Optional[PageNumber]'
    """
    The page number where this content is described in full.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SourceInfo':
        return cls(
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(WebURL, data.get("license")),
            _from_json_data(Label, data.get("title")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[PageNumber], data.get("page")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["authors"] = _to_json_data(self.authors)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.page is not None:
             data["page"] = _to_json_data(self.page)
        return data

class SpecialTrackRollMethod(Enum):
    ALL = "all"
    """
    Use _every_ roll option at once.
    """

    HIGHEST = "highest"
    """
    Use the roll option with the best/highest value.
    """

    LOWEST = "lowest"
    """
    Use the roll option with the worst/lowest value.
    """

    MISS = "miss"
    """
    An automatic miss.
    """

    PLAYER_CHOICE = "player_choice"
    """
    The player chooses which roll option to use.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SpecialTrackRule:
    """
    Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
    or Legacies (Starforged).
    """

    description: 'MarkdownString'
    """
    A description of this special track.
    """

    label: 'Label'
    """
    A label for this special track.
    """

    optional: 'bool'
    """
    Is this track an optional rule?
    """

    shared: 'bool'
    """
    Is this track shared by all players?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(bool, data.get("optional")),
            _from_json_data(bool, data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["optional"] = _to_json_data(self.optional)
        data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class SpecialTrackType:
    """
    Special, ruleset-specific progress tracks. Usually, one exists per player
    character, and they persist through the life of the player character.
    'Canonical' examples:
      * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
    legacy track, use `bonds_legacy` instead.
      * `failure_track`, described in Ironsworn: Delve
      * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
    Ironsworn: Starforged
    
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackType':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class StatKey:
    """
    A basic player character stat.
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StatKey':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class StatRule:
    """
    Describes a standard player character stat.
    """

    description: 'MarkdownString'
    """
    A description of this stat.
    """

    label: 'Label'
    """
    A label for this stat.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'StatRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(Label, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        return data

class StatValueRefUsing(Enum):
    """
    A reference to the value of a standard player character stat.
    """

    STAT = "stat"
    @classmethod
    def from_json_data(cls, data: Any) -> 'StatValueRefUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class StatValueRef:
    """
    A reference to the value of a standard player character stat.
    """

    stat: 'StatKey'
    using: 'StatValueRefUsing'
    """
    A reference to the value of a standard player character stat.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'StatValueRef':
        return cls(
            _from_json_data(StatKey, data.get("stat")),
            _from_json_data(StatValueRefUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["stat"] = _to_json_data(self.stat)
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class Suggestions:
    value: 'List[AnyIDWildcard]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Suggestions':
        return cls(_from_json_data(List[AnyIDWildcard], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SvgImageURL:
    """
    A relative (local) URL pointing to a vector image in the SVG format.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvgImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Tag:
    value: 'Any'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Tag':
        return cls(_from_json_data(Any, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TagRule:
    schema: 'TagSchema'
    """
    The JSON schema for this tag value.
    """

    node_types: 'List[TaggableNodeType]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRule':
        return cls(
            _from_json_data(TagSchema, data.get("$schema")),
            _from_json_data(List[TaggableNodeType], data.get("node_types")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["$schema"] = _to_json_data(self.schema)
        data["node_types"] = _to_json_data(self.node_types)
        return data

@dataclass
class TagSchema:
    """
    JSON schema used to validate the tag data, with a mandatory description.
    Only a subset of all possible JSON schema are allowed, including references
    to some Datasworn types.
    """

    value: 'Any'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TagSchema':
        return cls(_from_json_data(Any, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class TaggableNodeType(Enum):
    ABILITY = "ability"
    ASSET = "asset"
    ASSET_COLLECTION = "asset_collection"
    ATLAS_COLLECTION = "atlas_collection"
    ATLAS_ENTRY = "atlas_entry"
    DANGER = "danger"
    DELVE_SITE = "delve_site"
    DELVE_SITE_DOMAIN = "delve_site_domain"
    DELVE_SITE_THEME = "delve_site_theme"
    DENIZEN = "denizen"
    FEATURE = "feature"
    MOVE = "move"
    MOVE_CATEGORY = "move_category"
    NPC = "npc"
    NPC_COLLECTION = "npc_collection"
    OPTION = "option"
    ORACLE_COLLECTION = "oracle_collection"
    ORACLE_ROLLABLE = "oracle_rollable"
    RARITY = "rarity"
    ROW = "row"
    TRUTH = "truth"
    VARIANT = "variant"
    @classmethod
    def from_json_data(cls, data: Any) -> 'TaggableNodeType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Tags:
    """
    A dictionary of tags, keyed by the RulesPackageId that the tags are from.
    """

    value: 'Dict[str, Dict[str, Tag]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Tags':
        return cls(_from_json_data(Dict[str, Dict[str, Tag]], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class TextFieldFieldType(Enum):
    TEXT = "text"
    @classmethod
    def from_json_data(cls, data: Any) -> 'TextFieldFieldType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class TextField:
    """
    Represents an input that accepts plain text.
    """

    field_type: 'TextFieldFieldType'
    label: 'Label'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TextField':
        return cls(
            _from_json_data(TextFieldFieldType, data.get("field_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["field_type"] = _to_json_data(self.field_type)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class TriggerActionRoll:
    """
    Describes trigger conditions for a move that makes an action roll.
    """

    conditions: 'List[TriggerActionRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRoll':
        return cls(
            _from_json_data(List[TriggerActionRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollCondition:
    method: 'ActionRollMethod'
    roll_options: 'List[RollableValue]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollCondition':
        return cls(
            _from_json_data(ActionRollMethod, data.get("method")),
            _from_json_data(List[RollableValue], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollConditionEnhancement:
    method: 'ActionRollMethod'
    roll_options: 'List[RollableValue]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollConditionEnhancement':
        return cls(
            _from_json_data(ActionRollMethod, data.get("method")),
            _from_json_data(List[RollableValue], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerActionRollConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollEnhancement':
        return cls(
            _from_json_data(List[TriggerActionRollConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerBy:
    """
    Information on who can activate this trigger condition. Usually this is just
    the player, but some asset abilities can trigger from an ally's move.
    """

    ally: 'bool'
    """
    Can this trigger be activated by one of the player's allies?
    """

    player: 'bool'
    """
    Can this trigger be activated by the player who owns this?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerBy':
        return cls(
            _from_json_data(bool, data.get("ally")),
            _from_json_data(bool, data.get("player")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["ally"] = _to_json_data(self.ally)
        data["player"] = _to_json_data(self.player)
        return data

@dataclass
class TriggerNoRoll:
    """
    Describes trigger conditions for a move that makes no rolls.
    """

    conditions: 'List[TriggerNoRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRoll':
        return cls(
            _from_json_data(List[TriggerNoRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerNoRollCondition:
    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRollCondition':
        return cls(
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerNoRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerNoRollCondition]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRollEnhancement':
        return cls(
            _from_json_data(List[TriggerNoRollCondition], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerProgressRoll:
    conditions: 'List[TriggerProgressRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRoll':
        return cls(
            _from_json_data(List[TriggerProgressRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollCondition:
    method: 'ProgressRollMethod'
    roll_options: 'List[ProgressRollOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollCondition':
        return cls(
            _from_json_data(ProgressRollMethod, data.get("method")),
            _from_json_data(List[ProgressRollOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollConditionEnhancement:
    method: 'ProgressRollMethod'
    roll_options: 'List[ProgressRollOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollConditionEnhancement':
        return cls(
            _from_json_data(ProgressRollMethod, data.get("method")),
            _from_json_data(List[ProgressRollOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerProgressRollConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollEnhancement':
        return cls(
            _from_json_data(List[TriggerProgressRollConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerSpecialTrack:
    conditions: 'List[TriggerSpecialTrackCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrack':
        return cls(
            _from_json_data(List[TriggerSpecialTrackCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackCondition:
    method: 'SpecialTrackRollMethod'
    roll_options: 'List[TriggerSpecialTrackConditionOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackCondition':
        return cls(
            _from_json_data(SpecialTrackRollMethod, data.get("method")),
            _from_json_data(List[TriggerSpecialTrackConditionOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackConditionEnhancement:
    """
    A progress move that rolls on one or more special tracks, like Bonds
    (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
    """

    method: 'SpecialTrackRollMethod'
    roll_options: 'List[TriggerSpecialTrackConditionOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackConditionEnhancement':
        return cls(
            _from_json_data(SpecialTrackRollMethod, data.get("method")),
            _from_json_data(List[TriggerSpecialTrackConditionOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackConditionOption:
    using: 'SpecialTrackType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackConditionOption':
        return cls(
            _from_json_data(SpecialTrackType, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class TriggerSpecialTrackEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerSpecialTrackConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackEnhancement':
        return cls(
            _from_json_data(List[TriggerSpecialTrackConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

class TruthType(Enum):
    TRUTH = "truth"
    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Truth:
    """
    A setting truth category.
    """

    id: 'TruthID'
    """
    The unique Datasworn ID for this node.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    node, including the author and licensing information.
    """

    dice: 'DiceExpression'
    name: 'Label'
    """
    The primary name/label for this node.
    """

    options: 'List[TruthOption]'
    type: 'TruthType'
    comment: 'Optional[Documentation]'
    canonical_name: 'Optional[Label]'
    """
    The name of this node as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this node.
    """

    factions: 'Optional[List[EntityPrompt]]'
    """
    Prompts for factions related to this truth, like those presented in standard
    isles. This is presented as a single paragraph in the original text;
    Datasworn uses an array (one faction prompt per string) to represent them in
    order to make them more suitable for programmatic use.
    
    This property is a placeholder and may see signficant changes in v0.2.0.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[List[TruthIDWildcard]]'
    """
    This node replaces all nodes that match these wildcards. References to the
    replaced nodes can be considered equivalent to this node.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Tags]'
    your_character: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Truth':
        return cls(
            _from_json_data(TruthID, data.get("_id")),
            _from_json_data(SourceInfo, data.get("_source")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[TruthOption], data.get("options")),
            _from_json_data(TruthType, data.get("type")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[List[EntityPrompt]], data.get("factions")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[List[TruthIDWildcard]], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Tags], data.get("tags")),
            _from_json_data(Optional[MarkdownString], data.get("your_character")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["_source"] = _to_json_data(self.source)
        data["dice"] = _to_json_data(self.dice)
        data["name"] = _to_json_data(self.name)
        data["options"] = _to_json_data(self.options)
        data["type"] = _to_json_data(self.type)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.factions is not None:
             data["factions"] = _to_json_data(self.factions)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.your_character is not None:
             data["your_character"] = _to_json_data(self.your_character)
        return data

@dataclass
class TruthID:
    """
    A unique ID representing a Truth object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthIDWildcard:
    """
    A wildcarded TruthId that can be used to match multiple Truth objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOption:
    id: 'TruthOptionID'
    """
    The unique Datasworn ID for this node.
    """

    description: 'MarkdownString'
    quest_starter: 'MarkdownString'
    roll: 'DiceRange'
    comment: 'Optional[Documentation]'
    oracles: 'Optional[Dict[str, EmbeddedOracleRollable]]'
    summary: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOption':
        return cls(
            _from_json_data(TruthOptionID, data.get("_id")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(DiceRange, data.get("roll")),
            _from_json_data(Optional[Documentation], data.get("_comment")),
            _from_json_data(Optional[Dict[str, EmbeddedOracleRollable]], data.get("oracles")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["_id"] = _to_json_data(self.id)
        data["description"] = _to_json_data(self.description)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        data["roll"] = _to_json_data(self.roll)
        if self.comment is not None:
             data["_comment"] = _to_json_data(self.comment)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class TruthOptionID:
    """
    A unique ID representing a TruthOption object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionIDWildcard:
    """
    A wildcarded TruthOptionId that can be used to match multiple TruthOption
    objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionOracleRollableID:
    """
    A unique ID representing a TruthOptionOracleRollable object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionOracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionOracleRollableIDWildcard:
    """
    A wildcarded TruthOptionOracleRollableId that can be used to match multiple
    TruthOptionOracleRollable objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionOracleRollableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionOracleRollableRowID:
    """
    A unique ID representing a TruthOptionOracleRollableRow object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionOracleRollableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionOracleRollableRowIDWildcard:
    """
    A wildcarded TruthOptionOracleRollableRowId that can be used to match
    multiple TruthOptionOracleRollableRow objects.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionOracleRollableRowIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class WebURL:
    """
    An absolute URL pointing to a website.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WebURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class WebpImageURL:
    """
    A relative (local) URL pointing to a raster image in the WEBP format.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WebpImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            

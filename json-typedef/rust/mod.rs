// Code generated by jtd-codegen for Rust v0.2.1

use chrono::{DateTime, FixedOffset};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Describes game rules compatible with the Ironsworn tabletop role-playing
/// game by Shawn Tomkin.
#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum RulesPackage {
    #[serde(rename = "expansion")]
    Expansion(RulesPackageExpansion),

    #[serde(rename = "ruleset")]
    Ruleset(RulesPackageRuleset),
}

/// The version of the Datasworn format used by this data.
#[derive(Serialize, Deserialize)]
pub enum RulesPackageExpansionDataswornVersion {
    #[serde(rename = "0.1.0")]
    DefaultName,
}

/// A Datasworn package that relies on an external package to provide its
/// ruleset.
#[derive(Serialize, Deserialize)]
pub struct RulesPackageExpansion {
    #[serde(rename = "_id")]
    pub id: ExpansionId,

    /// A dictionary object containing asset collections, which contain assets.
    #[serde(rename = "assets")]
    pub assets: HashMap<String, AssetCollection>,

    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: RulesPackageExpansionDataswornVersion,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: WebUrl,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    pub moves: HashMap<String, MoveCategory>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    pub oracles: HashMap<String, OracleTablesCollection>,

    #[serde(rename = "ruleset")]
    pub ruleset: RulesetId,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: Label,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, AtlasCollection>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Box<RulesExpansion>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

/// The version of the Datasworn format used by this data.
#[derive(Serialize, Deserialize)]
pub enum RulesPackageRulesetDataswornVersion {
    #[serde(rename = "0.1.0")]
    DefaultName,
}

/// A standalone Datasworn package that describes its own ruleset.
#[derive(Serialize, Deserialize)]
pub struct RulesPackageRuleset {
    #[serde(rename = "_id")]
    pub id: RulesetId,

    /// A dictionary object containing asset collections, which contain assets.
    #[serde(rename = "assets")]
    pub assets: HashMap<String, AssetCollection>,

    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: RulesPackageRulesetDataswornVersion,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: WebUrl,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    pub moves: HashMap<String, MoveCategory>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    pub oracles: HashMap<String, OracleTablesCollection>,

    #[serde(rename = "rules")]
    pub rules: Rules,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: Label,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, AtlasCollection>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

#[derive(Serialize, Deserialize)]
pub enum ActionRollMethod {
    /// Use _every_ roll option at once.
    #[serde(rename = "all")]
    All,

    /// Use the roll option with the best/highest value.
    #[serde(rename = "highest")]
    Highest,

    /// Use the roll option with the worst/lowest value.
    #[serde(rename = "lowest")]
    Lowest,

    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// The player chooses which roll option to use.
    #[serde(rename = "player_choice")]
    PlayerChoice,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

/// Represents any kind of non-wildcard ID, including IDs of embedded objects.
pub type AnyId = String;

/// Represents any kind of wildcard ID, including IDs of embedded objects.
pub type AnyIdWildcard = String;

pub type AnyMoveId = String;

pub type AnyMoveIdWildcard = String;

pub type AnyOracleRollableId = String;

pub type AnyOracleRollableIdWildcard = String;

pub type AnyOracleRollableRowId = String;

pub type AnyOracleRollableRowIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum AssetType {
    #[serde(rename = "asset")]
    Asset,
}

#[derive(Serialize, Deserialize)]
pub struct Asset {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: AssetId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "abilities")]
    pub abilities: Vec<AssetAbility>,

    /// A localized category label for this asset. This is the surtitle above
    /// the asset's name on the card.
    #[serde(rename = "category")]
    pub category: Label,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    pub countAsImpact: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// Options are input fields set when the player purchases the asset.
    /// They're likely to remain the same through the life of the asset.
    /// Typically, they are rendered at the top of the asset card.
    #[serde(rename = "options")]
    pub options: HashMap<String, AssetOptionField>,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    pub shared: bool,

    #[serde(rename = "type")]
    pub type_: AssetType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlField>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<AssetIdWildcard>>>,

    /// Describes prerequisites for purchasing or using this asset.
    #[serde(rename = "requirement")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirement: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// An asset ability: one of the purchasable features of an asset. Most assets
/// have three.
#[derive(Serialize, Deserialize)]
pub struct AssetAbility {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: AssetAbilityId,

    /// Is this asset ability enabled?
    #[serde(rename = "enabled")]
    pub enabled: bool,

    /// The complete rules text of this asset ability.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// Fields whose values are expected to change over the life of the asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetAbilityControlField>>>,

    /// Changes made to the asset, when this ability is enabled.
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    /// Describes changes made to various moves by this asset ability. Usually
    /// these require specific trigger conditions.
    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,

    /// Unique moves added by this asset ability.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, EmbeddedMove>>>,

    /// A handful of asset abilities have a label/name, for instance classic
    /// Ironsworn companion assets. Most canonical assets omit this property.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// Fields that are expected to be set once and remain the same through the
    /// life of the asset.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetAbilityOptionField>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityControlField {
    #[serde(rename = "checkbox")]
    Checkbox(AssetAbilityControlFieldCheckbox),

    #[serde(rename = "clock")]
    Clock(AssetAbilityControlFieldClock),

    #[serde(rename = "counter")]
    Counter(AssetAbilityControlFieldCounter),

    #[serde(rename = "text")]
    Text(AssetAbilityControlFieldText),
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A clock with 4 or more segments.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldClock {
    #[serde(rename = "label")]
    pub label: Label,

    /// The size of the clock -- in other words, the maximum number of filled
    /// clock segments. Standard clocks have 4, 6, 8, or 10 segments.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum number of filled clock segments. This is always 0.
    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A basic counter representing a non-rollable integer value. They usually
/// start at 0, and may or may not have a maximum.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCounter {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "max")]
    pub max: i16,

    /// The (inclusive) minimum value.
    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldText {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A unique ID representing an AssetAbility object.
pub type AssetAbilityId = String;

/// A wildcarded AssetAbilityId that can be used to match multiple AssetAbility
/// objects.
pub type AssetAbilityIdWildcard = String;

/// A unique ID representing an AssetAbilityMove object.
pub type AssetAbilityMoveId = String;

/// A wildcarded AssetAbilityMoveId that can be used to match multiple
/// AssetAbilityMove objects.
pub type AssetAbilityMoveIdWildcard = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityOptionField {
    #[serde(rename = "text")]
    Text(AssetAbilityOptionFieldText),
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityOptionFieldText {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A unique ID representing an AssetAbilityOracleRollable object.
pub type AssetAbilityOracleRollableId = String;

/// A wildcarded AssetAbilityOracleRollableId that can be used to match multiple
/// AssetAbilityOracleRollable objects.
pub type AssetAbilityOracleRollableIdWildcard = String;

/// A unique ID representing an AssetAbilityOracleRollableRow object.
pub type AssetAbilityOracleRollableRowId = String;

/// A wildcarded AssetAbilityOracleRollableRowId that can be used to match
/// multiple AssetAbilityOracleRollableRow objects.
pub type AssetAbilityOracleRollableRowIdWildcard = String;

/// Describes which assets can be attached to this asset. Example: Starforged's
/// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
/// Starforged for more info.
#[derive(Serialize, Deserialize)]
pub struct AssetAttachment {
    /// Asset IDs (which may be wildcards) that may be attached to this asset
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "max")]
    pub max: i16,
}

#[derive(Serialize, Deserialize)]
pub enum AssetCardFlipFieldFieldType {
    #[serde(rename = "card_flip")]
    CardFlip,
}

#[derive(Serialize, Deserialize)]
pub struct AssetCardFlipField {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "field_type")]
    pub fieldType: AssetCardFlipFieldFieldType,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetCheckboxFieldFieldType {
    #[serde(rename = "checkbox")]
    Checkbox,
}

#[derive(Serialize, Deserialize)]
pub struct AssetCheckboxField {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "field_type")]
    pub fieldType: AssetCheckboxFieldFieldType,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetCollectionType {
    #[serde(rename = "asset_collection")]
    AssetCollection,
}

#[derive(Serialize, Deserialize)]
pub struct AssetCollection {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: AssetCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "collections")]
    pub collections: HashMap<String, AssetCollection>,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, Asset>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: AssetCollectionType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<AssetCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<AssetCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing an AssetCollection object.
pub type AssetCollectionId = String;

/// A wildcarded AssetCollectionId that can be used to match multiple
/// AssetCollection objects.
pub type AssetCollectionIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum AssetConditionMeterFieldType {
    #[serde(rename = "condition_meter")]
    ConditionMeter,
}

/// Provides hints for moves that interact with this condition meter, such as
/// suffer and recovery moves.
#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterMoves {
    /// The ID(s) of recovery moves associated with this meter.
    #[serde(rename = "recover")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recover: Option<Box<Vec<AnyMoveIdWildcard>>>,

    /// The ID(s) of suffer moves associated with the condition meter. If the
    /// suffer move makes an action roll, this condition meter value should be
    /// made available as a roll option.
    #[serde(rename = "suffer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffer: Option<Box<Vec<AnyMoveIdWildcard>>>,
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeter {
    /// Checkbox controls rendered as part of the condition meter.
    #[serde(rename = "controls")]
    pub controls: HashMap<String, AssetConditionMeterControlField>,

    #[serde(rename = "field_type")]
    pub fieldType: AssetConditionMeterFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this meter's `value` usable as a stat in an action roll?
    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Provides hints for moves that interact with this condition meter, such
    /// as suffer and recovery moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<AssetConditionMeterMoves>>,
}

/// A checkbox control field, rendered as part of an asset condition meter.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetConditionMeterControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetConditionMeterControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetConditionMeterControlFieldCheckbox),
}

#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetConditionMeterEnhancementFieldType {
    #[serde(rename = "condition_meter")]
    ConditionMeter,
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterEnhancement {
    #[serde(rename = "field_type")]
    pub fieldType: AssetConditionMeterEnhancementFieldType,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetControlFieldCheckbox),

    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldConditionMeter),

    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetControlFieldSelectEnhancement),
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Provides hints for moves that interact with this condition meter, such as
/// suffer and recovery moves.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeterMoves {
    /// The ID(s) of recovery moves associated with this meter.
    #[serde(rename = "recover")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recover: Option<Box<Vec<AnyMoveIdWildcard>>>,

    /// The ID(s) of suffer moves associated with the condition meter. If the
    /// suffer move makes an action roll, this condition meter value should be
    /// made available as a roll option.
    #[serde(rename = "suffer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffer: Option<Box<Vec<AnyMoveIdWildcard>>>,
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeter {
    /// Checkbox controls rendered as part of the condition meter.
    #[serde(rename = "controls")]
    pub controls: HashMap<String, AssetConditionMeterControlField>,

    #[serde(rename = "label")]
    pub label: Label,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this meter's `value` usable as a stat in an action roll?
    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Provides hints for moves that interact with this condition meter, such
    /// as suffer and recovery moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<AssetControlFieldConditionMeterMoves>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "choice_type")]
pub enum AssetControlFieldSelectEnhancementChoice {
    #[serde(rename = "choice")]
    Choice(AssetControlFieldSelectEnhancementChoiceChoice),

    #[serde(rename = "choice_group")]
    ChoiceGroup(AssetControlFieldSelectEnhancementChoiceChoiceGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceChoice {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceChoiceGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldSelectEnhancementChoice>,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlFieldEnhancement {
    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldEnhancementConditionMeter),
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldEnhancementConditionMeter {
    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,
}

/// A reference to the value of an asset control.
#[derive(Serialize, Deserialize)]
pub enum AssetControlValueRefUsing {
    #[serde(rename = "asset_control")]
    AssetControl,
}

/// A reference to the value of an asset control.
#[derive(Serialize, Deserialize)]
pub struct AssetControlValueRef {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    /// A reference to the value of an asset control.
    #[serde(rename = "using")]
    pub using: AssetControlValueRefUsing,
}

/// Describes enhancements made to this asset in a partial asset object. The
/// changes should be applied recursively; only the values that are specified
/// should be changed.
#[derive(Serialize, Deserialize)]
pub struct AssetEnhancement {
    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlFieldEnhancement>>>,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared: Option<Box<bool>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A unique ID representing an Asset object.
pub type AssetId = String;

/// A wildcarded AssetId that can be used to match multiple Asset objects.
pub type AssetIdWildcard = String;

/// Options are asset input fields which are set once, usually when the
/// character takes the asset. The most common example is the "name" field on
/// companion assets. A more complex example is the choice of a god's stat for
/// the Devotant asset.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetOptionField {
    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetOptionFieldSelectEnhancement),

    #[serde(rename = "select_value")]
    SelectValue(AssetOptionFieldSelectValue),

    #[serde(rename = "text")]
    Text(AssetOptionFieldText),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "choice_type")]
pub enum AssetOptionFieldSelectEnhancementChoice {
    #[serde(rename = "choice")]
    Choice(AssetOptionFieldSelectEnhancementChoiceChoice),

    #[serde(rename = "choice_group")]
    ChoiceGroup(AssetOptionFieldSelectEnhancementChoiceChoiceGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceChoice {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceChoiceGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectEnhancementChoice>,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Represents a list of mutually exclusive choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValue {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectValueFieldChoice>,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldText {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A reference to the value of an asset option.
#[derive(Serialize, Deserialize)]
pub enum AssetOptionValueRefUsing {
    #[serde(rename = "asset_option")]
    AssetOption,
}

/// A reference to the value of an asset option.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionValueRef {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,

    /// A reference to the value of an asset option.
    #[serde(rename = "using")]
    pub using: AssetOptionValueRefUsing,
}

#[derive(Serialize, Deserialize)]
pub enum AtlasCollectionType {
    #[serde(rename = "atlas_collection")]
    AtlasCollection,
}

#[derive(Serialize, Deserialize)]
pub struct AtlasCollection {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: AtlasCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "collections")]
    pub collections: HashMap<String, AtlasCollection>,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, AtlasEntry>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: AtlasCollectionType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<AtlasCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<AtlasCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing an AtlasCollection object.
pub type AtlasCollectionId = String;

/// A wildcarded AtlasCollectionId that can be used to match multiple
/// AtlasCollection objects.
pub type AtlasCollectionIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum AtlasEntryType {
    #[serde(rename = "atlas_entry")]
    AtlasEntry,
}

/// An atlas entry, like the Ironlands region entries found in classic
/// Ironsworn.
#[derive(Serialize, Deserialize)]
pub struct AtlasEntry {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: AtlasEntryId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: AtlasEntryType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "quest_starter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub questStarter: Option<Box<MarkdownString>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<AtlasEntryIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

/// A unique ID representing an AtlasEntry object.
pub type AtlasEntryId = String;

/// A wildcarded AtlasEntryId that can be used to match multiple AtlasEntry
/// objects.
pub type AtlasEntryIdWildcard = String;

/// A reference to the value of an attached asset control. For example, a Module
/// asset could use this to roll using the `integrity` control of an attached
/// Vehicle.
#[derive(Serialize, Deserialize)]
pub enum AttachedAssetControlValueRefUsing {
    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl,
}

/// A reference to the value of an attached asset control. For example, a Module
/// asset could use this to roll using the `integrity` control of an attached
/// Vehicle.
#[derive(Serialize, Deserialize)]
pub struct AttachedAssetControlValueRef {
    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    /// A reference to the value of an attached asset control. For example, a
    /// Module asset could use this to roll using the `integrity` control of an
    /// attached Vehicle.
    #[serde(rename = "using")]
    pub using: AttachedAssetControlValueRefUsing,
}

/// A reference to the value of an attached asset option.
#[derive(Serialize, Deserialize)]
pub enum AttachedAssetOptionValueRefUsing {
    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption,
}

/// A reference to the value of an attached asset option.
#[derive(Serialize, Deserialize)]
pub struct AttachedAssetOptionValueRef {
    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,

    /// A reference to the value of an attached asset option.
    #[serde(rename = "using")]
    pub using: AttachedAssetOptionValueRefUsing,
}

/// Information on the original creator of this material.
#[derive(Serialize, Deserialize)]
pub struct AuthorInfo {
    /// The name of the author.
    #[serde(rename = "name")]
    pub name: Label,

    /// An optional email contact for the author
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Box<Email>>,

    /// An optional URL for the author's website.
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Box<WebUrl>>,
}

/// Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
pub type ChallengeRank = u8;

#[derive(Serialize, Deserialize)]
pub enum ClockFieldFieldType {
    #[serde(rename = "clock")]
    Clock,
}

/// A clock with 4 or more segments.
#[derive(Serialize, Deserialize)]
pub struct ClockField {
    #[serde(rename = "field_type")]
    pub fieldType: ClockFieldFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    /// The size of the clock -- in other words, the maximum number of filled
    /// clock segments. Standard clocks have 4, 6, 8, or 10 segments.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum number of filled clock segments. This is always 0.
    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub enum CollectableType {
    #[serde(rename = "asset")]
    Asset,

    #[serde(rename = "atlas_entry")]
    AtlasEntry,

    #[serde(rename = "move")]
    Move,

    #[serde(rename = "npc")]
    Npc,

    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub enum CollectionType {
    #[serde(rename = "asset_collection")]
    AssetCollection,

    #[serde(rename = "atlas_collection")]
    AtlasCollection,

    #[serde(rename = "move_category")]
    MoveCategory,

    #[serde(rename = "npc_collection")]
    NpcCollection,

    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

#[derive(Serialize, Deserialize)]
pub enum ConditionMeterFieldFieldType {
    #[serde(rename = "condition_meter")]
    ConditionMeter,
}

/// A meter with an integer value, bounded by a minimum and maximum.
#[derive(Serialize, Deserialize)]
pub struct ConditionMeterField {
    #[serde(rename = "field_type")]
    pub fieldType: ConditionMeterFieldFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this meter's `value` usable as a stat in an action roll?
    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A basic, rollable player character resource specified by the ruleset.
pub type ConditionMeterKey = DictKey;

/// Describes a standard player character condition meter.
#[derive(Serialize, Deserialize)]
pub struct ConditionMeterRule {
    /// A description of this condition meter.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "label")]
    pub label: Label,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this meter's `value` usable as a stat in an action roll?
    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// Is this condition meter shared by all players?
    #[serde(rename = "shared")]
    pub shared: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,
}

/// A reference to the value of a standard player condition meter.
#[derive(Serialize, Deserialize)]
pub enum ConditionMeterValueRefUsing {
    #[serde(rename = "condition_meter")]
    ConditionMeter,
}

/// A reference to the value of a standard player condition meter.
#[derive(Serialize, Deserialize)]
pub struct ConditionMeterValueRef {
    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,

    /// A reference to the value of a standard player condition meter.
    #[serde(rename = "using")]
    pub using: ConditionMeterValueRefUsing,
}

#[derive(Serialize, Deserialize)]
pub struct CoreTags {
    /// This object requires allies to function, and is intended for co-op play,
    /// or guided play with allies. It is not appropriate for solo play.
    #[serde(rename = "requires_allies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requiresAllies: Option<Box<bool>>,

    /// This object is supernatural in nature, and is ideal for settings that
    /// feature supernatural or mythic powers.
    #[serde(rename = "supernatural")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supernatural: Option<Box<bool>>,

    /// This object is technological in nature, and is ideal for settings that
    /// feature remarkable technologies.
    #[serde(rename = "technological")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub technological: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub enum CounterFieldFieldType {
    #[serde(rename = "counter")]
    Counter,
}

/// A basic counter representing a non-rollable integer value. They usually
/// start at 0, and may or may not have a maximum.
#[derive(Serialize, Deserialize)]
pub struct CounterField {
    #[serde(rename = "field_type")]
    pub fieldType: CounterFieldFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "max")]
    pub max: i16,

    /// The (inclusive) minimum value.
    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A CSS color value.
pub type CssColor = String;

/// An arbitrary static integer value with a label.
#[derive(Serialize, Deserialize)]
pub enum CustomValueUsing {
    #[serde(rename = "custom")]
    Custom,
}

/// An arbitrary static integer value with a label.
#[derive(Serialize, Deserialize)]
pub struct CustomValue {
    #[serde(rename = "label")]
    pub label: Label,

    /// An arbitrary static integer value with a label.
    #[serde(rename = "using")]
    pub using: CustomValueUsing,

    #[serde(rename = "value")]
    pub value: i16,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteType {
    #[serde(rename = "delve_site")]
    DelveSite,
}

/// A delve site with a theme, domain, and denizens.
#[derive(Serialize, Deserialize)]
pub struct DelveSite {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: DelveSiteId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Represents the delve site's denizen matrix as an array of objects.
    #[serde(rename = "denizens")]
    pub denizens: Vec<DelveSiteDenizen>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The ID of the site's DelveSiteDomain card.
    #[serde(rename = "domain")]
    pub domain: DelveSiteDomainId,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    /// The ID of the site's DelveSiteTheme card.
    #[serde(rename = "theme")]
    pub theme: DelveSiteThemeId,

    #[serde(rename = "type")]
    pub type_: DelveSiteType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An additional theme or domain card ID, for use with optional rules in
    /// Ironsworn: Delve.
    #[serde(rename = "extra_card")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extraCard: Option<Box<String>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// The ID of an atlas entry representing the region in which this delve
    /// site is located.
    #[serde(rename = "region")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub region: Option<Box<AtlasEntryId>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<DelveSiteIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// Represents an entry in a delve site denizen matrix. Denizen matrices are
/// described in Ironsworn: Delve.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDenizen {
    #[serde(rename = "_id")]
    pub id: DelveSiteDenizenId,

    #[serde(rename = "frequency")]
    pub frequency: DelveSiteDenizenFrequency,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// A name for the denizen, if it's different than the `name` property of
    /// the NPC.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// The ID of the relevant NPC entry, if one is specified.
    #[serde(rename = "npc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npc: Option<Box<NpcId>>,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDenizenFrequency {
    #[serde(rename = "common")]
    Common,

    #[serde(rename = "rare")]
    Rare,

    #[serde(rename = "uncommon")]
    Uncommon,

    #[serde(rename = "unforeseen")]
    Unforeseen,

    #[serde(rename = "very_common")]
    VeryCommon,
}

/// A unique ID representing a DelveSiteDenizen object.
pub type DelveSiteDenizenId = String;

/// A wildcarded DelveSiteDenizenId that can be used to match multiple
/// DelveSiteDenizen objects.
pub type DelveSiteDenizenIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDomainType {
    #[serde(rename = "delve_site_domain")]
    DelveSiteDomain,
}

/// A delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomain {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: DelveSiteDomainId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteDomainDanger>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteDomainFeature>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: DelveSiteDomainType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// An oracle table ID containing place name elements. For examples,
    /// see oracle ID `oracle_rollable:delve/site_name/place/barrow`,
    /// and its siblings in oracle collection ID
    /// `oracle_collection:delve/site_name/place`. These oracles
    /// are used by the site name oracle from Ironsworn: Delve
    /// (`oracle_rollable:delve/site_name/format`) to create random names for
    /// delve sites.
    #[serde(rename = "name_oracle")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nameOracle: Option<Box<OracleRollableId>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<DelveSiteDomainIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainDanger {
    #[serde(rename = "_id")]
    pub id: DelveSiteDomainDangerId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID representing a DelveSiteDomainDanger object.
pub type DelveSiteDomainDangerId = String;

/// A wildcarded DelveSiteDomainDangerId that can be used to match multiple
/// DelveSiteDomainDanger objects.
pub type DelveSiteDomainDangerIdWildcard = String;

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainFeature {
    #[serde(rename = "_id")]
    pub id: DelveSiteDomainFeatureId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID representing a DelveSiteDomainFeature object.
pub type DelveSiteDomainFeatureId = String;

/// A wildcarded DelveSiteDomainFeatureId that can be used to match multiple
/// DelveSiteDomainFeature objects.
pub type DelveSiteDomainFeatureIdWildcard = String;

/// A unique ID representing a DelveSiteDomain object.
pub type DelveSiteDomainId = String;

/// A wildcarded DelveSiteDomainId that can be used to match multiple
/// DelveSiteDomain objects.
pub type DelveSiteDomainIdWildcard = String;

/// A unique ID representing a DelveSite object.
pub type DelveSiteId = String;

/// A wildcarded DelveSiteId that can be used to match multiple DelveSite
/// objects.
pub type DelveSiteIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum DelveSiteThemeType {
    #[serde(rename = "delve_site_theme")]
    DelveSiteTheme,
}

/// A delve site theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteTheme {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: DelveSiteThemeId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteThemeDanger>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteThemeFeature>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: DelveSiteThemeType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<DelveSiteThemeIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeDanger {
    #[serde(rename = "_id")]
    pub id: DelveSiteThemeDangerId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID representing a DelveSiteThemeDanger object.
pub type DelveSiteThemeDangerId = String;

/// A wildcarded DelveSiteThemeDangerId that can be used to match multiple
/// DelveSiteThemeDanger objects.
pub type DelveSiteThemeDangerIdWildcard = String;

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeFeature {
    #[serde(rename = "_id")]
    pub id: DelveSiteThemeFeatureId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID representing a DelveSiteThemeFeature object.
pub type DelveSiteThemeFeatureId = String;

/// A wildcarded DelveSiteThemeFeatureId that can be used to match multiple
/// DelveSiteThemeFeature objects.
pub type DelveSiteThemeFeatureIdWildcard = String;

/// A unique ID representing a DelveSiteTheme object.
pub type DelveSiteThemeId = String;

/// A wildcarded DelveSiteThemeId that can be used to match multiple
/// DelveSiteTheme objects.
pub type DelveSiteThemeIdWildcard = String;

/// A simple dice roll expression with an optional (positive or negative)
/// modifer.
pub type DiceExpression = String;

/// Represents a range of dice roll results, bounded by `min` and `max`
/// (inclusive).
#[derive(Serialize, Deserialize)]
pub struct DiceRange {
    /// High end of the dice range.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range.
    #[serde(rename = "min")]
    pub min: i16,
}

/// A `snake_case` key used in a Datasworn dictionary object.
pub type DictKey = String;

/// Implementation hints or other developer-facing comments on this node. These
/// should be omitted when representing an object for gameplay.
pub type Documentation = String;

/// An email address.
pub type Email = String;

#[derive(Serialize, Deserialize)]
pub enum EmbedOnlyType {
    #[serde(rename = "ability")]
    Ability,

    #[serde(rename = "danger")]
    Danger,

    #[serde(rename = "denizen")]
    Denizen,

    #[serde(rename = "feature")]
    Feature,

    #[serde(rename = "option")]
    Option,

    #[serde(rename = "row")]
    Row,

    #[serde(rename = "variant")]
    Variant,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedActionRollMoveRollType {
    #[serde(rename = "action_roll")]
    ActionRoll,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedActionRollMoveType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedActionRollMove {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "roll_type")]
    pub rollType: EmbeddedActionRollMoveRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    #[serde(rename = "type")]
    pub type_: EmbeddedActionRollMoveType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum EmbeddedMove {
    #[serde(rename = "action_roll")]
    ActionRoll(EmbeddedMoveActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(EmbeddedMoveNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(EmbeddedMoveProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(EmbeddedMoveSpecialTrack),
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedMoveActionRollType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedMoveActionRoll {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    #[serde(rename = "type")]
    pub type_: EmbeddedMoveActionRollType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedMoveNoRollType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedMoveNoRoll {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    #[serde(rename = "type")]
    pub type_: EmbeddedMoveNoRollType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedMoveProgressRollType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedMoveProgressRoll {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Describes the common features of progress tracks associated with this
    /// move.
    #[serde(rename = "tracks")]
    pub tracks: ProgressTrackTypeInfo,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    #[serde(rename = "type")]
    pub type_: EmbeddedMoveProgressRollType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedMoveSpecialTrackType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedMoveSpecialTrack {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    #[serde(rename = "type")]
    pub type_: EmbeddedMoveSpecialTrackType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

pub type EmbeddedMoveId = String;

pub type EmbeddedMoveIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum EmbeddedNoRollMoveRollType {
    #[serde(rename = "no_roll")]
    NoRoll,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedNoRollMoveType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedNoRollMove {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "roll_type")]
    pub rollType: EmbeddedNoRollMoveRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    #[serde(rename = "type")]
    pub type_: EmbeddedNoRollMoveType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleColumnTextOracleType {
    #[serde(rename = "column_text")]
    ColumnText,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleColumnTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleColumnTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleColumnText {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: EmbeddedOracleColumnTextOracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleColumnTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleColumnTextRecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleColumnText2OracleType {
    #[serde(rename = "column_text2")]
    ColumnText2,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleColumnText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleColumnText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleColumnText2 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: EmbeddedOracleColumnText2OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleColumnText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleColumnText2RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleColumnText3OracleType {
    #[serde(rename = "column_text3")]
    ColumnText3,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleColumnText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleColumnText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleColumnText3 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: EmbeddedOracleColumnText3OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleColumnText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleColumnText3RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "oracle_type")]
pub enum EmbeddedOracleRollable {
    #[serde(rename = "column_text")]
    ColumnText(EmbeddedOracleRollableColumnText),

    #[serde(rename = "column_text2")]
    ColumnText2(EmbeddedOracleRollableColumnText2),

    #[serde(rename = "column_text3")]
    ColumnText3(EmbeddedOracleRollableColumnText3),

    #[serde(rename = "table_text")]
    TableText(EmbeddedOracleRollableTableText),

    #[serde(rename = "table_text2")]
    TableText2(EmbeddedOracleRollableTableText2),

    #[serde(rename = "table_text3")]
    TableText3(EmbeddedOracleRollableTableText3),
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleRollableColumnTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableColumnTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableColumnText {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleRollableColumnTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleRollableColumnTextRecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleRollableColumnText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableColumnText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableColumnText2 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleRollableColumnText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleRollableColumnText2RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleRollableColumnText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableColumnText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableColumnText3 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleRollableColumnText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleRollableColumnText3RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableTextColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleRollableTableTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    #[serde(rename = "column_labels")]
    pub columnLabels: EmbeddedOracleRollableTableTextColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleRollableTableTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleRollableTableTextRecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText2ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleRollableTableText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText2 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    #[serde(rename = "column_labels")]
    pub columnLabels: EmbeddedOracleRollableTableText2ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleRollableTableText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleRollableTableText2RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText3ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleRollableTableText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleRollableTableText3 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    #[serde(rename = "column_labels")]
    pub columnLabels: EmbeddedOracleRollableTableText3ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleRollableTableText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleRollableTableText3RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

pub type EmbeddedOracleRollableId = String;

pub type EmbeddedOracleRollableIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableTextColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleTableTextOracleType {
    #[serde(rename = "table_text")]
    TableText,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleTableTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    #[serde(rename = "column_labels")]
    pub columnLabels: EmbeddedOracleTableTextColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: EmbeddedOracleTableTextOracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleTableTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleTableTextRecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText2ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleTableText2OracleType {
    #[serde(rename = "table_text2")]
    TableText2,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleTableText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText2 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    #[serde(rename = "column_labels")]
    pub columnLabels: EmbeddedOracleTableText2ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: EmbeddedOracleTableText2OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleTableText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleTableText2RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText3ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleTableText3OracleType {
    #[serde(rename = "table_text3")]
    TableText3,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedOracleTableText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedOracleTableText3 {
    #[serde(rename = "_id")]
    pub id: EmbeddedOracleRollableId,

    #[serde(rename = "column_labels")]
    pub columnLabels: EmbeddedOracleTableText3ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: EmbeddedOracleTableText3OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: EmbeddedOracleTableText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<EmbeddedOracleTableText3RecommendedRolls>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedProgressRollMoveRollType {
    #[serde(rename = "progress_roll")]
    ProgressRoll,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedProgressRollMoveType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedProgressRollMove {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "roll_type")]
    pub rollType: EmbeddedProgressRollMoveRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Describes the common features of progress tracks associated with this
    /// move.
    #[serde(rename = "tracks")]
    pub tracks: ProgressTrackTypeInfo,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    #[serde(rename = "type")]
    pub type_: EmbeddedProgressRollMoveType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedSpecialTrackMoveRollType {
    #[serde(rename = "special_track")]
    SpecialTrack,
}

#[derive(Serialize, Deserialize)]
pub enum EmbeddedSpecialTrackMoveType {
    #[serde(rename = "move")]
    Move,
}

#[derive(Serialize, Deserialize)]
pub struct EmbeddedSpecialTrackMove {
    #[serde(rename = "_id")]
    pub id: EmbeddedMoveId,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "roll_type")]
    pub rollType: EmbeddedSpecialTrackMoveRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    #[serde(rename = "type")]
    pub type_: EmbeddedSpecialTrackMoveType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// This type is a placeholder and may see signficant changes in v0.2.0.
#[derive(Serialize, Deserialize)]
pub struct EntityPrompt {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

/// The version of the Datasworn format used by this data.
#[derive(Serialize, Deserialize)]
pub enum ExpansionDataswornVersion {
    #[serde(rename = "0.1.0")]
    DefaultName,
}

#[derive(Serialize, Deserialize)]
pub enum ExpansionType {
    #[serde(rename = "expansion")]
    Expansion,
}

/// A Datasworn package that relies on an external package to provide its
/// ruleset.
#[derive(Serialize, Deserialize)]
pub struct Expansion {
    #[serde(rename = "_id")]
    pub id: ExpansionId,

    /// A dictionary object containing asset collections, which contain assets.
    #[serde(rename = "assets")]
    pub assets: HashMap<String, AssetCollection>,

    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: ExpansionDataswornVersion,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: WebUrl,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    pub moves: HashMap<String, MoveCategory>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    pub oracles: HashMap<String, OracleTablesCollection>,

    #[serde(rename = "ruleset")]
    pub ruleset: RulesetId,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: Label,

    #[serde(rename = "type")]
    pub type_: ExpansionType,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, AtlasCollection>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Box<RulesExpansion>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

/// The ID of a Datasworn package that relies on an external package to provide
/// its ruleset.
pub type ExpansionId = String;

#[derive(Serialize, Deserialize)]
pub struct I18nHint {
    /// The part of speech for this string.
    #[serde(rename = "part_of_speech")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partOfSpeech: Option<Box<PartOfSpeech>>,
}

#[derive(Serialize, Deserialize)]
pub struct I18nHintsTemplate {
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<I18nHint>>,

    #[serde(rename = "text2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text2: Option<Box<I18nHint>>,

    #[serde(rename = "text3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text3: Option<Box<I18nHint>>,
}

/// Internationalization/localization hints for the text content of this object.
#[derive(Serialize, Deserialize)]
pub struct I18nHints {
    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<I18nHintsTemplate>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<I18nHint>>,

    #[serde(rename = "text2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text2: Option<Box<I18nHint>>,

    #[serde(rename = "text3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text3: Option<Box<I18nHint>>,
}

/// Describes a category of standard impacts/debilities.
#[derive(Serialize, Deserialize)]
pub struct ImpactCategory {
    /// A dictionary object of the Impacts in this category.
    #[serde(rename = "contents")]
    pub contents: HashMap<String, ImpactRule>,

    /// A description of this impact category.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this impact category.
    #[serde(rename = "label")]
    pub label: Label,
}

/// Describes a standard impact/debility.
#[derive(Serialize, Deserialize)]
pub struct ImpactRule {
    /// A description of this impact.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The label for this impact.
    #[serde(rename = "label")]
    pub label: Label,

    /// Is this impact permanent?
    #[serde(rename = "permanent")]
    pub permanent: bool,

    /// Any ruleset condition meters that can't recover when this impact is
    /// active.
    #[serde(rename = "prevents_recovery")]
    pub preventsRecovery: Vec<ConditionMeterKey>,

    /// Is this impact applied to all players at once?
    #[serde(rename = "shared")]
    pub shared: bool,
}

/// A localized, player-facing name or label, formatted as plain text. In some
/// contexts it may be undesirable to render this text, but it should always be
/// exposed to assistive technology (e.g. with `aria-label` in HTML).
pub type Label = String;

/// Localized, player-facing text, formatted in Markdown. It is *not* formatted
/// for use "out of the box"; it uses some custom syntax, intended to be
/// replaced in whatever way is most appropriate for your implementation.
/// 
/// * `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to
/// the identified object. The ID must conform to the `AnyId` type; no wildcards
/// allowed.
/// * `{{table>oracle_rollable:starforged/core/action}}`: the referenced
/// oracle is rendered here in the source material. The ID must conform to the
/// `AnyOracleRollableId` type; no wildcards allowed.
/// * `{{table_columns>move:delve/delve/delve_the_depths}}`: Render
/// *all* direct OracleRollable children of the identified node. This
/// can be an OracleCollectionId, or the ID of anything that can have
/// EmbeddedOracleRollables (such as a Move or TruthOption).
pub type MarkdownString = String;

/// A rich text string in Markdown with replaced values from oracle roll
/// results.
/// 
/// The custom syntax `{{some_row_key>some_oracle_table_id}}` should be replaced
/// by the `some_row_key` string of a rolled oracle table. This is usually the
/// `text` key, for example `{{text>oracle_rollable:starforged/core/action}}`
pub type MarkdownTemplateString = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum Move {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveActionRoll0),

    #[serde(rename = "no_roll")]
    NoRoll(MoveNoRoll0),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveProgressRoll0),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveSpecialTrack0),
}

#[derive(Serialize, Deserialize)]
pub enum MoveActionRollType {
    #[serde(rename = "move")]
    Move,
}

/// A move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct MoveActionRoll0 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    #[serde(rename = "type")]
    pub type_: MoveActionRollType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveNoRollType {
    #[serde(rename = "move")]
    Move,
}

/// A move that makes no progress rolls or action rolls.
#[derive(Serialize, Deserialize)]
pub struct MoveNoRoll0 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    #[serde(rename = "type")]
    pub type_: MoveNoRollType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveProgressRollType {
    #[serde(rename = "move")]
    Move,
}

/// A progress move that rolls on a standard progress track type (whose features
/// are defined by this move object). For progress rolls that use special
/// tracks, see MoveSpecialTrack.
#[derive(Serialize, Deserialize)]
pub struct MoveProgressRoll0 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Describes the common features of progress tracks associated with this
    /// move.
    #[serde(rename = "tracks")]
    pub tracks: ProgressTrackTypeInfo,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    #[serde(rename = "type")]
    pub type_: MoveProgressRollType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveSpecialTrackType {
    #[serde(rename = "move")]
    Move,
}

/// A progress move that rolls on a special track, such as Legacies (Starforged)
/// or Bonds (classic Ironsworn). For progress moves that use standard progress
/// tracks, see MoveProgressRoll instead.
#[derive(Serialize, Deserialize)]
pub struct MoveSpecialTrack0 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    #[serde(rename = "type")]
    pub type_: MoveSpecialTrackType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveActionRollRollType {
    #[serde(rename = "action_roll")]
    ActionRoll,
}

#[derive(Serialize, Deserialize)]
pub enum MoveActionRollType0 {
    #[serde(rename = "move")]
    Move,
}

/// A move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct MoveActionRoll {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "roll_type")]
    pub rollType: MoveActionRollRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    #[serde(rename = "type")]
    pub type_: MoveActionRollType0,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A move must have this `roll_type` to receive this enhancement. This is in
/// addition to any other restrictions made by other properties.
#[derive(Serialize, Deserialize)]
pub enum MoveActionRollEnhancementRollType {
    #[serde(rename = "action_roll")]
    ActionRoll,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveActionRollEnhancement {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    /// A move must have this `roll_type` to receive this enhancement. This is
    /// in addition to any other restrictions made by other properties.
    #[serde(rename = "roll_type")]
    pub rollType: MoveActionRollEnhancementRollType,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerActionRollEnhancement>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveCategoryType {
    #[serde(rename = "move_category")]
    MoveCategory,
}

#[derive(Serialize, Deserialize)]
pub struct MoveCategory {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveCategoryId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "collections")]
    pub collections: HashMap<String, MoveCategory>,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, Move>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: MoveCategoryType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<MoveCategoryIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveCategoryIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing a MoveCategory object.
pub type MoveCategoryId = String;

/// A wildcarded MoveCategoryId that can be used to match multiple MoveCategory
/// objects.
pub type MoveCategoryIdWildcard = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum MoveEnhancement {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveEnhancementActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveEnhancementNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveEnhancementProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveEnhancementSpecialTrack),
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementActionRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerActionRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementNoRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerNoRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementProgressRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerProgressRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementSpecialTrack {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerSpecialTrackEnhancement>>,
}

/// A unique ID representing a Move object.
pub type MoveId = String;

/// A wildcarded MoveId that can be used to match multiple Move objects.
pub type MoveIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum MoveNoRollRollType {
    #[serde(rename = "no_roll")]
    NoRoll,
}

#[derive(Serialize, Deserialize)]
pub enum MoveNoRollType0 {
    #[serde(rename = "move")]
    Move,
}

/// A move that makes no progress rolls or action rolls.
#[derive(Serialize, Deserialize)]
pub struct MoveNoRoll {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "roll_type")]
    pub rollType: MoveNoRollRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    #[serde(rename = "type")]
    pub type_: MoveNoRollType0,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A move must have this `roll_type` to receive this enhancement. This is in
/// addition to any other restrictions made by other properties.
#[derive(Serialize, Deserialize)]
pub enum MoveNoRollEnhancementRollType {
    #[serde(rename = "no_roll")]
    NoRoll,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveNoRollEnhancement {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    /// A move must have this `roll_type` to receive this enhancement. This is
    /// in addition to any other restrictions made by other properties.
    #[serde(rename = "roll_type")]
    pub rollType: MoveNoRollEnhancementRollType,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerNoRollEnhancement>>,
}

/// A unique ID representing a MoveOracleRollable object.
pub type MoveOracleRollableId = String;

/// A wildcarded MoveOracleRollableId that can be used to match multiple
/// MoveOracleRollable objects.
pub type MoveOracleRollableIdWildcard = String;

/// A unique ID representing a MoveOracleRollableRow object.
pub type MoveOracleRollableRowId = String;

/// A wildcarded MoveOracleRollableRowId that can be used to match multiple
/// MoveOracleRollableRow objects.
pub type MoveOracleRollableRowIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct MoveOutcome {
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,
}

/// A standalone localized description for each move outcome (miss, weak hit,
/// or strong hit). This is for for e.g. VTT implementations, where it's often
/// useful to display only the rules text relevant to a roll result.
/// 
///   This often requires light editorialization to create text that can stand
/// alone without reference to the rest of the move. For example, 'as above'
/// (in reference to another move outcome) shouldn't be used here; instead, the
/// relevant text should be repeated.
#[derive(Serialize, Deserialize)]
pub struct MoveOutcomes {
    #[serde(rename = "miss")]
    pub miss: MoveOutcome,

    #[serde(rename = "strong_hit")]
    pub strongHit: MoveOutcome,

    #[serde(rename = "weak_hit")]
    pub weakHit: MoveOutcome,
}

#[derive(Serialize, Deserialize)]
pub enum MoveProgressRollRollType {
    #[serde(rename = "progress_roll")]
    ProgressRoll,
}

#[derive(Serialize, Deserialize)]
pub enum MoveProgressRollType0 {
    #[serde(rename = "move")]
    Move,
}

/// A progress move that rolls on a standard progress track type (whose features
/// are defined by this move object). For progress rolls that use special
/// tracks, see MoveSpecialTrack.
#[derive(Serialize, Deserialize)]
pub struct MoveProgressRoll {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "roll_type")]
    pub rollType: MoveProgressRollRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Describes the common features of progress tracks associated with this
    /// move.
    #[serde(rename = "tracks")]
    pub tracks: ProgressTrackTypeInfo,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    #[serde(rename = "type")]
    pub type_: MoveProgressRollType0,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A move must have this `roll_type` to receive this enhancement. This is in
/// addition to any other restrictions made by other properties.
#[derive(Serialize, Deserialize)]
pub enum MoveProgressRollEnhancementRollType {
    #[serde(rename = "progress_roll")]
    ProgressRoll,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveProgressRollEnhancement {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    /// A move must have this `roll_type` to receive this enhancement. This is
    /// in addition to any other restrictions made by other properties.
    #[serde(rename = "roll_type")]
    pub rollType: MoveProgressRollEnhancementRollType,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerProgressRollEnhancement>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveRollType {
    /// A move that makes an action roll.
    #[serde(rename = "action_roll")]
    ActionRoll,

    /// A move that makes no action rolls or progress rolls.
    #[serde(rename = "no_roll")]
    NoRoll,

    /// A progress move that rolls on a standard progress track type (defined by
    /// this move).
    #[serde(rename = "progress_roll")]
    ProgressRoll,

    /// A progress move that rolls on one or more special tracks, like Bonds
    /// (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    #[serde(rename = "special_track")]
    SpecialTrack,
}

#[derive(Serialize, Deserialize)]
pub enum MoveSpecialTrackRollType {
    #[serde(rename = "special_track")]
    SpecialTrack,
}

#[derive(Serialize, Deserialize)]
pub enum MoveSpecialTrackType0 {
    #[serde(rename = "move")]
    Move,
}

/// A progress move that rolls on a special track, such as Legacies (Starforged)
/// or Bonds (classic Ironsworn). For progress moves that use standard progress
/// tracks, see MoveProgressRoll instead.
#[derive(Serialize, Deserialize)]
pub struct MoveSpecialTrack {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Is burning momentum allowed for this move?
    #[serde(rename = "allow_momentum_burn")]
    pub allowMomentumBurn: bool,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "roll_type")]
    pub rollType: MoveSpecialTrackRollType,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    #[serde(rename = "type")]
    pub type_: MoveSpecialTrackType0,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    /// Indicates that this move replaces the identified moves. References to
    /// the replaced moves can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<MoveIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A move must have this `roll_type` to receive this enhancement. This is in
/// addition to any other restrictions made by other properties.
#[derive(Serialize, Deserialize)]
pub enum MoveSpecialTrackEnhancementRollType {
    #[serde(rename = "special_track")]
    SpecialTrack,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveSpecialTrackEnhancement {
    #[serde(rename = "enhances")]
    pub enhances: Vec<AnyMoveIdWildcard>,

    /// A move must have this `roll_type` to receive this enhancement. This is
    /// in addition to any other restrictions made by other properties.
    #[serde(rename = "roll_type")]
    pub rollType: MoveSpecialTrackEnhancementRollType,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerSpecialTrackEnhancement>>,
}

#[derive(Serialize, Deserialize)]
pub enum NonCollectableType {
    #[serde(rename = "delve_site")]
    DelveSite,

    #[serde(rename = "delve_site_domain")]
    DelveSiteDomain,

    #[serde(rename = "delve_site_theme")]
    DelveSiteTheme,

    #[serde(rename = "rarity")]
    Rarity,

    #[serde(rename = "truth")]
    Truth,
}

#[derive(Serialize, Deserialize)]
pub enum NpcType {
    #[serde(rename = "npc")]
    Npc,
}

/// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
/// Rulebook, or Chapter 4 of Starforged.
#[derive(Serialize, Deserialize)]
pub struct Npc {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: NpcId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "drives")]
    pub drives: Vec<MarkdownString>,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    /// The suggested challenge rank for this NPC.
    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "tactics")]
    pub tactics: Vec<MarkdownString>,

    #[serde(rename = "type")]
    pub type_: NpcType,

    #[serde(rename = "variants")]
    pub variants: HashMap<String, NpcVariant>,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "quest_starter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub questStarter: Option<Box<MarkdownString>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<NpcIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub enum NpcCollectionType {
    #[serde(rename = "npc_collection")]
    NpcCollection,
}

#[derive(Serialize, Deserialize)]
pub struct NpcCollection {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: NpcCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "collections")]
    pub collections: HashMap<String, NpcCollection>,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, Npc>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: NpcCollectionType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<NpcCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<NpcCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing a NpcCollection object.
pub type NpcCollectionId = String;

/// A wildcarded NpcCollectionId that can be used to match multiple
/// NpcCollection objects.
pub type NpcCollectionIdWildcard = String;

/// A unique ID representing a Npc object.
pub type NpcId = String;

/// A wildcarded NpcId that can be used to match multiple Npc objects.
pub type NpcIdWildcard = String;

/// A localized category label describing the nature of this NPC.
/// 
/// In Ironsworn classic, this is probably the singular form of the parent
/// collection's name.
/// 
/// For Starforged, see the table on p. 258 for examples.
pub type NpcNature = Label;

#[derive(Serialize, Deserialize)]
pub struct NpcVariant {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: NpcVariantId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    /// The suggested challenge rank for this NPC.
    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID representing a NpcVariant object.
pub type NpcVariantId = String;

/// A wildcarded NpcVariantId that can be used to match multiple NpcVariant
/// objects.
pub type NpcVariantIdWildcard = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "oracle_type")]
pub enum OracleCollection {
    #[serde(rename = "table_shared_rolls")]
    TableSharedRolls(OracleCollectionTableSharedRolls),

    #[serde(rename = "table_shared_text")]
    TableSharedText(OracleCollectionTableSharedText),

    #[serde(rename = "table_shared_text2")]
    TableSharedText2(OracleCollectionTableSharedText2),

    #[serde(rename = "table_shared_text3")]
    TableSharedText3(OracleCollectionTableSharedText3),

    #[serde(rename = "tables")]
    Tables(OracleCollectionTables),
}

/// Provides column labels for this table. The `roll` key refers to the roll
/// column showing the dice range (`min` and `max` on each table row). For all
/// other column labels, see the `name` property of each child `OracleColumn`.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedRollsColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionTableSharedRollsType {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with one roll column and
/// multiple text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedRolls {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Provides column labels for this table. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    /// For all other column labels, see the `name` property of each child
    /// `OracleColumn`.
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedRollsColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: OracleCollectionTableSharedRollsType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedTextColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionTableSharedTextType {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with multiple roll columns
/// and one text column.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedTextColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: OracleCollectionTableSharedTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText2ColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionTableSharedText2Type {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with multiple roll columns,
/// and 2 shared text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedText2ColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText2>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: OracleCollectionTableSharedText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText3ColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionTableSharedText3Type {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with multiple roll columns,
/// and 3 shared text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedText3ColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText3>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: OracleCollectionTableSharedText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionTablesType {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection that represents a category or grouping of tables, which
/// may themselves be `OracleTablesCollection`s.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTables {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "collections")]
    pub collections: HashMap<String, OracleCollection>,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleRollableTable>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: OracleCollectionTablesType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing an OracleCollection object.
pub type OracleCollectionId = String;

/// A wildcarded OracleCollectionId that can be used to match multiple
/// OracleCollection objects.
pub type OracleCollectionIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub enum OracleColumnTextOracleType {
    #[serde(rename = "column_text")]
    ColumnText,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleColumnTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// Represents a single column in an OracleCollection.
#[derive(Serialize, Deserialize)]
pub struct OracleColumnText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleColumnTextOracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: OracleColumnTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleColumnTextRecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnText2OracleType {
    #[serde(rename = "column_text2")]
    ColumnText2,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleColumnText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct OracleColumnText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleColumnText2OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: OracleColumnText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleColumnText2RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnText3OracleType {
    #[serde(rename = "column_text3")]
    ColumnText3,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleColumnText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct OracleColumnText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleColumnText3OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: OracleColumnText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleColumnText3RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// Special roll instructions to use when rolling multiple times on a single
/// oracle.
#[derive(Serialize, Deserialize)]
pub enum OracleDuplicateBehavior {
    /// Duplicates results should be kept.
    #[serde(rename = "keep")]
    Keep,

    /// Duplicate results should be kept, and they compound to make things
    /// worse.
    #[serde(rename = "make_it_worse")]
    MakeItWorse,

    /// Duplicate results should be re-rolled.
    #[serde(rename = "reroll")]
    Reroll,
}

#[derive(Serialize, Deserialize)]
pub struct OracleMatchBehavior {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRoll {
    /// Both Ironsworn and Starforged explicitly recommend *against* rolling
    /// all details at once. That said, some oracle results only provide useful
    /// information once a secondary roll occurs, such as "Action + Theme" or
    /// "Roll twice".
    #[serde(rename = "auto")]
    pub auto: bool,

    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// Special rules on how to handle duplicate results, when rolling multiple
    /// times.
    #[serde(rename = "duplicates")]
    pub duplicates: OracleDuplicateBehavior,

    /// The number of times to roll.
    #[serde(rename = "number_of_rolls")]
    pub numberOfRolls: i16,

    #[serde(rename = "oracle")]
    pub oracle: OracleRollableId,
}

/// Provides string templates that may be used in place of the static row
/// text from `OracleRollableRow#text`, `OracleRollableRow#text2`, and
/// `OracleRollableRow#text3`.
/// 
///   These strings are formatted in Markdown, but use a special syntax
/// for their placeholders: `{{text>some_oracle_rollable_id}}`. The
/// placeholder should be replaced with the value of a rolled (or selected)
/// `OracleRollableRow#text` from the target oracle rollable ID.
#[derive(Serialize, Deserialize)]
pub struct OracleRollTemplate {
    /// A string template that may be used in place of OracleRollableRow#text.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownTemplateString>>,

    /// A string template that may be used in place of OracleRollableRow#text2.
    #[serde(rename = "text2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text2: Option<Box<MarkdownTemplateString>>,

    /// A string template that may be used in place of OracleRollableRow#text3.
    #[serde(rename = "text3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text3: Option<Box<MarkdownTemplateString>>,
}

/// A collection of table rows from which random results may be rolled. This may
/// represent a standalone table, or a column in a larger table.
#[derive(Serialize, Deserialize)]
#[serde(tag = "oracle_type")]
pub enum OracleRollable {
    #[serde(rename = "column_text")]
    ColumnText(OracleRollableColumnText),

    #[serde(rename = "column_text2")]
    ColumnText2(OracleRollableColumnText2),

    #[serde(rename = "column_text3")]
    ColumnText3(OracleRollableColumnText3),

    #[serde(rename = "table_text")]
    TableText(OracleRollableTableText),

    #[serde(rename = "table_text2")]
    TableText2(OracleRollableTableText2),

    #[serde(rename = "table_text3")]
    TableText3(OracleRollableTableText3),
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableColumnTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableColumnTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// Represents a single column in an OracleCollection.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableColumnText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: OracleRollableColumnTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableColumnTextRecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableColumnText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableColumnText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableColumnText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: OracleRollableColumnText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableColumnText2RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableColumnText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableColumnText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableColumnText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: OracleRollableColumnText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableColumnText3RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTextColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableTableTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// Represents a basic rollable oracle table with one roll column and one text
/// result column.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleRollableTableTextColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: OracleRollableTableTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableTableTextRecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText2ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableTableText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and two text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleRollableTableText2ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: OracleRollableTableText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableTableText2RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText3ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableTableText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and 3 text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleRollableTableText3ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: OracleRollableTableText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableTableText3RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing an OracleRollable object.
pub type OracleRollableId = String;

/// A wildcarded OracleRollableId that can be used to match multiple
/// OracleRollable objects.
pub type OracleRollableIdWildcard = String;

/// A unique ID representing an OracleRollableRow object.
pub type OracleRollableRowId = String;

/// A wildcarded OracleRollableRowId that can be used to match multiple
/// OracleRollableRow objects.
pub type OracleRollableRowIdWildcard = String;

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableRowText {
    #[serde(rename = "_id")]
    pub id: AnyOracleRollableRowId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a row in an oracle table that provides a secondary text field.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableRowText2 {
    #[serde(rename = "_id")]
    pub id: AnyOracleRollableRowId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "text2")]
    pub text2: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a row in an oracle table with 3 text cells.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableRowText3 {
    #[serde(rename = "_id")]
    pub id: AnyOracleRollableRowId,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "text2")]
    pub text2: MarkdownString,

    #[serde(rename = "text3")]
    pub text3: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "oracle_type")]
pub enum OracleRollableTable {
    #[serde(rename = "table_text")]
    TableText(OracleRollableTableTableText),

    #[serde(rename = "table_text2")]
    TableText2(OracleRollableTableTableText2),

    #[serde(rename = "table_text3")]
    TableText3(OracleRollableTableTableText3),
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableTextColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableTableTableTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// Represents a basic rollable oracle table with one roll column and one text
/// result column.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleRollableTableTableTextColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: OracleRollableTableTableTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableTableTableTextRecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText2ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableTableTableText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and two text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleRollableTableTableText2ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: OracleRollableTableTableText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableTableTableText2RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText3ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleRollableTableTableText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and 3 text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleRollableTableTableText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleRollableTableTableText3ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: OracleRollableTableTableText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleRollableTableTableText3RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// Provides column labels for this table. The `roll` key refers to the roll
/// column showing the dice range (`min` and `max` on each table row). For all
/// other column labels, see the `name` property of each child `OracleColumn`.
#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedRollsColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedRollsOracleType {
    #[serde(rename = "table_shared_rolls")]
    TableSharedRolls,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedRollsType {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with one roll column and
/// multiple text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedRolls {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Provides column labels for this table. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    /// For all other column labels, see the `name` property of each child
    /// `OracleColumn`.
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableSharedRollsColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableSharedRollsOracleType,

    #[serde(rename = "type")]
    pub type_: OracleTableSharedRollsType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedTextColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedTextOracleType {
    #[serde(rename = "table_shared_text")]
    TableSharedText,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedTextType {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with multiple roll columns
/// and one text column.
#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableSharedTextColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableSharedTextOracleType,

    #[serde(rename = "type")]
    pub type_: OracleTableSharedTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedText2ColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedText2OracleType {
    #[serde(rename = "table_shared_text2")]
    TableSharedText2,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedText2Type {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with multiple roll columns,
/// and 2 shared text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableSharedText2ColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText2>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableSharedText2OracleType,

    #[serde(rename = "type")]
    pub type_: OracleTableSharedText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedText3ColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedText3OracleType {
    #[serde(rename = "table_shared_text3")]
    TableSharedText3,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableSharedText3Type {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection representing a single table with multiple roll columns,
/// and 3 shared text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableSharedText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableSharedText3ColumnLabels,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleColumnText3>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableSharedText3OracleType,

    #[serde(rename = "type")]
    pub type_: OracleTableSharedText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableTextColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableTextOracleType {
    #[serde(rename = "table_text")]
    TableText,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableTextType {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// Represents a basic rollable oracle table with one roll column and one text
/// result column.
#[derive(Serialize, Deserialize)]
pub struct OracleTableText {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableTextColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableTextOracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText>,

    #[serde(rename = "type")]
    pub type_: OracleTableTextType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleTableTextRecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableText2ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableText2OracleType {
    #[serde(rename = "table_text2")]
    TableText2,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableText2Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and two text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableText2 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableText2ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableText2OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText2>,

    #[serde(rename = "type")]
    pub type_: OracleTableText2Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleTableText2RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableText3ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableText3OracleType {
    #[serde(rename = "table_text3")]
    TableText3,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableText3Type {
    #[serde(rename = "oracle_rollable")]
    OracleRollable,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and 3 text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableText3 {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableText3ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTableText3OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleRollableRowText3>,

    #[serde(rename = "type")]
    pub type_: OracleTableText3Type,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleTableText3RecommendedRolls>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleRollableIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTablesCollectionOracleType {
    #[serde(rename = "tables")]
    Tables,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTablesCollectionType {
    #[serde(rename = "oracle_collection")]
    OracleCollection,
}

/// An OracleCollection that represents a category or grouping of tables, which
/// may themselves be `OracleTablesCollection`s.
#[derive(Serialize, Deserialize)]
pub struct OracleTablesCollection {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "collections")]
    pub collections: HashMap<String, OracleCollection>,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleRollableTable>,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTablesCollectionOracleType,

    #[serde(rename = "type")]
    pub type_: OracleTablesCollectionType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This node's content enhances all nodes that match these wildcards,
    /// rather than being a standalone item of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<OracleCollectionIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// Represents a page number in a book.
pub type PageNumber = u16;

#[derive(Serialize, Deserialize)]
pub enum PartOfSpeech {
    /// An adjective.
    #[serde(rename = "adjective")]
    Adjective,

    /// An adjective used as a proper noun.
    #[serde(rename = "adjective_as_proper_noun")]
    AdjectiveAsProperNoun,

    /// A common noun used as an adjective, to modify another noun.
    #[serde(rename = "adjunct_common_noun")]
    AdjunctCommonNoun,

    /// A proper noun used as an adjective, to modify another noun.
    #[serde(rename = "adjunct_proper_noun")]
    AdjunctProperNoun,

    /// A verb used as an adjective, to modify a noun.
    #[serde(rename = "attributive_verb")]
    AttributiveVerb,

    /// A common noun.
    #[serde(rename = "common_noun")]
    CommonNoun,

    /// An common noun used as a proper noun.
    #[serde(rename = "common_noun_as_proper_noun")]
    CommonNounAsProperNoun,

    /// Gerund or present participle of a verb, e.g. "going", "seeing",
    /// "waving". Can function as a noun, an adjective, or a progressive verb.
    #[serde(rename = "gerund")]
    Gerund,

    /// A proper noun.
    #[serde(rename = "proper_noun")]
    ProperNoun,

    /// A verb in present tense
    #[serde(rename = "verb")]
    Verb,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollMethod {
    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// Make a progress roll on a progress track associated with this move.
    #[serde(rename = "progress_roll")]
    ProgressRoll,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollOptionUsing {
    #[serde(rename = "progress_track")]
    ProgressTrack,
}

#[derive(Serialize, Deserialize)]
pub struct ProgressRollOption {
    #[serde(rename = "using")]
    pub using: ProgressRollOptionUsing,
}

/// Describes the features of a type of progress track.
#[derive(Serialize, Deserialize)]
pub struct ProgressTrackTypeInfo {
    /// A category label for progress tracks of this type.
    #[serde(rename = "category")]
    pub category: Label,

    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, Option<Value>>>>,
}

#[derive(Serialize, Deserialize)]
pub enum RarityType {
    #[serde(rename = "rarity")]
    Rarity,
}

/// A rarity, as described in Ironsworn: Delve.
#[derive(Serialize, Deserialize)]
pub struct Rarity {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: RarityId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The asset augmented by this rarity.
    #[serde(rename = "asset")]
    pub asset: AssetId,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "type")]
    pub type_: RarityType,

    /// From Ironsworn: Delve, p. 174:
    /// 
    ///       Some assets will bring a rarity into play more often than others,
    /// so the experience point cost for a rarity will vary by the linked asset.
    /// These costs are shown in the tables on page 175.
    /// 
    ///       If you are playing solo, and aren’t concerned with the relative
    /// balance of rarity abilities, you can ignore these variable costs. If so,
    /// spend 3 experience points to purchase a rarity.
    #[serde(rename = "xp_cost")]
    pub xpCost: i16,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<RarityIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,
}

/// A unique ID representing a Rarity object.
pub type RarityId = String;

/// A wildcarded RarityId that can be used to match multiple Rarity objects.
pub type RarityIdWildcard = String;

/// Provides a value like a stat, condition meter, or other number (usually for
/// use in an action roll). The expected value is an integer, or null.
#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum RollableValue {
    #[serde(rename = "asset_control")]
    AssetControl(RollableValueAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(RollableValueAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(RollableValueAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(RollableValueAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(RollableValueConditionMeter),

    #[serde(rename = "custom")]
    Custom(RollableValueCustom),

    #[serde(rename = "stat")]
    Stat(RollableValueStat),
}

/// A reference to the value of an asset control.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAssetControl {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

/// A reference to the value of an asset option.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAssetOption {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

/// A reference to the value of an attached asset control. For example, a Module
/// asset could use this to roll using the `integrity` control of an attached
/// Vehicle.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAttachedAssetControl {
    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

/// A reference to the value of an attached asset option.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAttachedAssetOption {
    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

/// A reference to the value of a standard player condition meter.
#[derive(Serialize, Deserialize)]
pub struct RollableValueConditionMeter {
    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,
}

/// An arbitrary static integer value with a label.
#[derive(Serialize, Deserialize)]
pub struct RollableValueCustom {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: i16,
}

/// A reference to the value of a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct RollableValueStat {
    #[serde(rename = "stat")]
    pub stat: StatKey,
}

/// Describes rules for player characters in this ruleset, such as stats and
/// condition meters.
#[derive(Serialize, Deserialize)]
pub struct Rules {
    /// Describes the standard condition meters used by player characters in
    /// this ruleset.
    #[serde(rename = "condition_meters")]
    pub conditionMeters: HashMap<String, ConditionMeterRule>,

    /// Describes the standard impacts/debilities used by player characters in
    /// this ruleset.
    #[serde(rename = "impacts")]
    pub impacts: HashMap<String, ImpactCategory>,

    /// Describes the special tracks used by player characters in this
    /// ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies
    /// (Starforged).
    #[serde(rename = "special_tracks")]
    pub specialTracks: HashMap<String, SpecialTrackRule>,

    /// Describes the standard stats used by player characters in this ruleset.
    #[serde(rename = "stats")]
    pub stats: HashMap<String, StatRule>,

    #[serde(rename = "tags")]
    pub tags: HashMap<String, TagRule>,
}

/// Describes rules for player characters in this ruleset, such as stats and
/// condition meters.
#[derive(Serialize, Deserialize)]
pub struct RulesExpansion {
    /// Describes the standard condition meters used by player characters in
    /// this ruleset.
    #[serde(rename = "condition_meters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditionMeters: Option<Box<HashMap<String, ConditionMeterRule>>>,

    /// Describes the standard impacts/debilities used by player characters in
    /// this ruleset.
    #[serde(rename = "impacts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impacts: Option<Box<HashMap<String, ImpactCategory>>>,

    /// Describes the special tracks used by player characters in this
    /// ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies
    /// (Starforged).
    #[serde(rename = "special_tracks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub specialTracks: Option<Box<HashMap<String, SpecialTrackRule>>>,

    /// Describes the standard stats used by player characters in this ruleset.
    #[serde(rename = "stats")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stats: Option<Box<HashMap<String, StatRule>>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, TagRule>>>,
}

pub type RulesPackageId = String;

/// The version of the Datasworn format used by this data.
#[derive(Serialize, Deserialize)]
pub enum RulesetDataswornVersion {
    #[serde(rename = "0.1.0")]
    DefaultName,
}

#[derive(Serialize, Deserialize)]
pub enum RulesetType {
    #[serde(rename = "ruleset")]
    Ruleset,
}

/// A standalone Datasworn package that describes its own ruleset.
#[derive(Serialize, Deserialize)]
pub struct Ruleset {
    #[serde(rename = "_id")]
    pub id: RulesetId,

    /// A dictionary object containing asset collections, which contain assets.
    #[serde(rename = "assets")]
    pub assets: HashMap<String, AssetCollection>,

    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: RulesetDataswornVersion,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: WebUrl,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    pub moves: HashMap<String, MoveCategory>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    pub oracles: HashMap<String, OracleTablesCollection>,

    #[serde(rename = "rules")]
    pub rules: Rules,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: Label,

    #[serde(rename = "type")]
    pub type_: RulesetType,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, AtlasCollection>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

/// The ID of standalone Datasworn package that describes its own ruleset.
pub type RulesetId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "choice_type")]
pub enum SelectEnhancementFieldChoice0 {
    #[serde(rename = "choice")]
    Choice(SelectEnhancementFieldChoiceChoice),

    #[serde(rename = "choice_group")]
    ChoiceGroup(SelectEnhancementFieldChoiceChoiceGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectEnhancementFieldChoiceChoice {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectEnhancementFieldChoiceChoiceGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

#[derive(Serialize, Deserialize)]
pub enum SelectEnhancementFieldFieldType {
    #[serde(rename = "select_enhancement")]
    SelectEnhancement,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct SelectEnhancementField {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice0>,

    #[serde(rename = "field_type")]
    pub fieldType: SelectEnhancementFieldFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub enum SelectEnhancementFieldChoiceChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectEnhancementFieldChoice {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectEnhancementFieldChoiceChoiceType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

#[derive(Serialize, Deserialize)]
pub enum SelectEnhancementFieldChoiceGroupChoiceType {
    #[serde(rename = "choice_group")]
    ChoiceGroup,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectEnhancementFieldChoiceGroup {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectEnhancementFieldChoiceGroupChoiceType,

    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldFieldType {
    #[serde(rename = "select_value")]
    SelectValue,
}

/// Represents a list of mutually exclusive choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueField {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectValueFieldChoice>,

    #[serde(rename = "field_type")]
    pub fieldType: SelectValueFieldFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum SelectValueFieldChoice {
    #[serde(rename = "asset_control")]
    AssetControl(SelectValueFieldChoiceAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(SelectValueFieldChoiceAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(SelectValueFieldChoiceAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(SelectValueFieldChoiceAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(SelectValueFieldChoiceConditionMeter),

    #[serde(rename = "custom")]
    Custom(SelectValueFieldChoiceCustom),

    #[serde(rename = "stat")]
    Stat(SelectValueFieldChoiceStat),
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAssetControlChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAssetControl {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAssetControlChoiceType,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAssetOptionChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAssetOption {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAssetOptionChoiceType,

    #[serde(rename = "label")]
    pub label: Label,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAttachedAssetControlChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAttachedAssetControl {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAttachedAssetControlChoiceType,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAttachedAssetOptionChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAttachedAssetOption {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAttachedAssetOptionChoiceType,

    #[serde(rename = "label")]
    pub label: Label,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceConditionMeterChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceConditionMeter {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceConditionMeterChoiceType,

    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceCustomChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceCustom {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceCustomChoiceType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: i16,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceStatChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceStat {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceStatChoiceType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "stat")]
    pub stat: StatKey,
}

pub type SemanticVersion = String;

/// Metadata describing the original source of this node
#[derive(Serialize, Deserialize)]
pub struct SourceInfo {
    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: WebUrl,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: Label,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// The page number where this content is described in full.
    #[serde(rename = "page")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page: Option<Box<PageNumber>>,
}

#[derive(Serialize, Deserialize)]
pub enum SpecialTrackRollMethod {
    /// Use _every_ roll option at once.
    #[serde(rename = "all")]
    All,

    /// Use the roll option with the best/highest value.
    #[serde(rename = "highest")]
    Highest,

    /// Use the roll option with the worst/lowest value.
    #[serde(rename = "lowest")]
    Lowest,

    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// The player chooses which roll option to use.
    #[serde(rename = "player_choice")]
    PlayerChoice,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

/// Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
/// or Legacies (Starforged).
#[derive(Serialize, Deserialize)]
pub struct SpecialTrackRule {
    /// A description of this special track.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this special track.
    #[serde(rename = "label")]
    pub label: Label,

    /// Is this track an optional rule?
    #[serde(rename = "optional")]
    pub optional: bool,

    /// Is this track shared by all players?
    #[serde(rename = "shared")]
    pub shared: bool,
}

/// Special, ruleset-specific progress tracks. Usually, one exists per player
/// character, and they persist through the life of the player character.
/// 'Canonical' examples:
///   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
/// legacy track, use `bonds_legacy` instead.
///   * `failure_track`, described in Ironsworn: Delve
///   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
/// Ironsworn: Starforged
/// 
pub type SpecialTrackType = DictKey;

/// A basic player character stat.
pub type StatKey = DictKey;

/// Describes a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct StatRule {
    /// A description of this stat.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this stat.
    #[serde(rename = "label")]
    pub label: Label,
}

/// A reference to the value of a standard player character stat.
#[derive(Serialize, Deserialize)]
pub enum StatValueRefUsing {
    #[serde(rename = "stat")]
    Stat,
}

/// A reference to the value of a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct StatValueRef {
    #[serde(rename = "stat")]
    pub stat: StatKey,

    /// A reference to the value of a standard player character stat.
    #[serde(rename = "using")]
    pub using: StatValueRefUsing,
}

pub type Suggestions = Vec<AnyIdWildcard>;

/// A relative (local) URL pointing to a vector image in the SVG format.
pub type SvgImageUrl = String;

pub type Tag = Option<Value>;

#[derive(Serialize, Deserialize)]
pub struct TagRule {
    #[serde(rename = "$schema")]
    pub schema: TagSchema,

    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<TaggableNodeType>,
}

/// A JSON schema used to validate the tag data.
pub type TagSchema = Option<Value>;

#[derive(Serialize, Deserialize)]
pub enum TaggableNodeType {
    #[serde(rename = "ability")]
    Ability,

    #[serde(rename = "asset")]
    Asset,

    #[serde(rename = "asset_collection")]
    AssetCollection,

    #[serde(rename = "atlas_collection")]
    AtlasCollection,

    #[serde(rename = "atlas_entry")]
    AtlasEntry,

    #[serde(rename = "danger")]
    Danger,

    #[serde(rename = "delve_site")]
    DelveSite,

    #[serde(rename = "delve_site_domain")]
    DelveSiteDomain,

    #[serde(rename = "delve_site_theme")]
    DelveSiteTheme,

    #[serde(rename = "denizen")]
    Denizen,

    #[serde(rename = "feature")]
    Feature,

    #[serde(rename = "move")]
    Move,

    #[serde(rename = "move_category")]
    MoveCategory,

    #[serde(rename = "npc")]
    Npc,

    #[serde(rename = "npc_collection")]
    NpcCollection,

    #[serde(rename = "option")]
    Option,

    #[serde(rename = "oracle_collection")]
    OracleCollection,

    #[serde(rename = "oracle_rollable")]
    OracleRollable,

    #[serde(rename = "rarity")]
    Rarity,

    #[serde(rename = "row")]
    Row,

    #[serde(rename = "truth")]
    Truth,

    #[serde(rename = "variant")]
    Variant,
}

/// A dictionary of tags, keyed by the RulesPackageId that the tags are from.
pub type Tags = HashMap<String, HashMap<String, Tag>>;

#[derive(Serialize, Deserialize)]
pub enum TextFieldFieldType {
    #[serde(rename = "text")]
    Text,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct TextField {
    #[serde(rename = "field_type")]
    pub fieldType: TextFieldFieldType,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Describes trigger conditions for a move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct TriggerActionRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollCondition {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<RollableValue>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<RollableValue>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollConditionEnhancement>,
}

/// Information on who can activate this trigger condition. Usually this is just
/// the player, but some asset abilities can trigger from an ally's move.
#[derive(Serialize, Deserialize)]
pub struct TriggerBy {
    /// Can this trigger be activated by one of the player's allies?
    #[serde(rename = "ally")]
    pub ally: bool,

    /// Can this trigger be activated by the player who owns this?
    #[serde(rename = "player")]
    pub player: bool,
}

/// Describes trigger conditions for a move that makes no rolls.
#[derive(Serialize, Deserialize)]
pub struct TriggerNoRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollCondition {
    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollCondition {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrack {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackCondition {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// A progress move that rolls on one or more special tracks, like Bonds
/// (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionEnhancement {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionOption {
    #[serde(rename = "using")]
    pub using: SpecialTrackType,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub enum TruthType {
    #[serde(rename = "truth")]
    Truth,
}

/// A setting truth category.
#[derive(Serialize, Deserialize)]
pub struct Truth {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: TruthId,

    /// Attribution for the original source (such as a book or website) of this
    /// node, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this node.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "options")]
    pub options: Vec<TruthOption>,

    #[serde(rename = "type")]
    pub type_: TruthType,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    /// The name of this node as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this node.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// Prompts for factions related to this truth, like those presented in
    /// standard isles. This is presented as a single paragraph in the original
    /// text; Datasworn uses an array (one faction prompt per string) to
    /// represent them in order to make them more suitable for programmatic use.
    /// 
    /// This property is a placeholder and may see signficant changes in v0.2.0.
    #[serde(rename = "factions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub factions: Option<Box<Vec<EntityPrompt>>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This node replaces all nodes that match these wildcards. References to
    /// the replaced nodes can be considered equivalent to this node.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<Vec<TruthIdWildcard>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<Tags>>,

    #[serde(rename = "your_character")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourCharacter: Option<Box<MarkdownString>>,
}

/// A unique ID representing a Truth object.
pub type TruthId = String;

/// A wildcarded TruthId that can be used to match multiple Truth objects.
pub type TruthIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct TruthOption {
    /// The unique Datasworn ID for this node.
    #[serde(rename = "_id")]
    pub id: TruthOptionId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "roll")]
    pub roll: DiceRange,

    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<Documentation>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, EmbeddedOracleRollable>>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID representing a TruthOption object.
pub type TruthOptionId = String;

/// A wildcarded TruthOptionId that can be used to match multiple TruthOption
/// objects.
pub type TruthOptionIdWildcard = String;

/// A unique ID representing a TruthOptionOracleRollable object.
pub type TruthOptionOracleRollableId = String;

/// A wildcarded TruthOptionOracleRollableId that can be used to match multiple
/// TruthOptionOracleRollable objects.
pub type TruthOptionOracleRollableIdWildcard = String;

/// A unique ID representing a TruthOptionOracleRollableRow object.
pub type TruthOptionOracleRollableRowId = String;

/// A wildcarded TruthOptionOracleRollableRowId that can be used to match
/// multiple TruthOptionOracleRollableRow objects.
pub type TruthOptionOracleRollableRowIdWildcard = String;

/// An absolute URL pointing to a website.
pub type WebUrl = String;

/// A relative (local) URL pointing to a raster image in the WEBP format.
pub type WebpImageUrl = String;

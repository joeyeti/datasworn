# Code generated by jtd-codegen for Ruby v0.1.1

require 'json'
require 'time'

module Datasworn

  # Describes game rules compatible with the Ironsworn tabletop role-playing
  # game by Shawn Tomkin.
  class RulesPackage
    attr_accessor :type

    def self.from_json_data(data)
      {
        "expansion" => RulesPackageExpansion,
        "ruleset" => RulesPackageRuleset,
      }[data["type"]].from_json_data(data)
    end
  end

  # The version of the Datasworn format used by this data.
  class RulesPackageExpansionDataswornVersion
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DEFAULT_NAME = new("0.1.0")

    def self.from_json_data(data)
      {
        "0.1.0" => DEFAULT_NAME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A Datasworn package that relies on an external package to provide its
  # ruleset.
  class RulesPackageExpansion < RulesPackage
    attr_accessor :id
    attr_accessor :assets
    attr_accessor :authors
    attr_accessor :datasworn_version
    attr_accessor :date
    attr_accessor :license
    attr_accessor :moves
    attr_accessor :oracles
    attr_accessor :ruleset
    attr_accessor :title
    attr_accessor :url
    attr_accessor :atlas
    attr_accessor :delve_sites
    attr_accessor :description
    attr_accessor :npcs
    attr_accessor :rarities
    attr_accessor :rules
    attr_accessor :site_domains
    attr_accessor :site_themes
    attr_accessor :truths

    def self.from_json_data(data)
      out = RulesPackageExpansion.new
      out.type = "expansion"
      out.id = Datasworn::from_json_data(ExpansionID, data["_id"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetCollection], data["assets"])
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.datasworn_version = Datasworn::from_json_data(RulesPackageExpansionDataswornVersion, data["datasworn_version"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(WebURL, data["license"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleTablesCollection], data["oracles"])
      out.ruleset = Datasworn::from_json_data(RulesetID, data["ruleset"])
      out.title = Datasworn::from_json_data(Label, data["title"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.atlas = Datasworn::from_json_data(Hash[String, AtlasCollection], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.rules = Datasworn::from_json_data(RulesExpansion, data["rules"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = { "type" => "expansion" }
      data["_id"] = Datasworn::to_json_data(id)
      data["assets"] = Datasworn::to_json_data(assets)
      data["authors"] = Datasworn::to_json_data(authors)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["moves"] = Datasworn::to_json_data(moves)
      data["oracles"] = Datasworn::to_json_data(oracles)
      data["ruleset"] = Datasworn::to_json_data(ruleset)
      data["title"] = Datasworn::to_json_data(title)
      data["url"] = Datasworn::to_json_data(url)
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["rules"] = Datasworn::to_json_data(rules) unless rules.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  # The version of the Datasworn format used by this data.
  class RulesPackageRulesetDataswornVersion
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DEFAULT_NAME = new("0.1.0")

    def self.from_json_data(data)
      {
        "0.1.0" => DEFAULT_NAME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standalone Datasworn package that describes its own ruleset.
  class RulesPackageRuleset < RulesPackage
    attr_accessor :id
    attr_accessor :assets
    attr_accessor :authors
    attr_accessor :datasworn_version
    attr_accessor :date
    attr_accessor :license
    attr_accessor :moves
    attr_accessor :oracles
    attr_accessor :rules
    attr_accessor :title
    attr_accessor :url
    attr_accessor :atlas
    attr_accessor :delve_sites
    attr_accessor :description
    attr_accessor :npcs
    attr_accessor :rarities
    attr_accessor :site_domains
    attr_accessor :site_themes
    attr_accessor :truths

    def self.from_json_data(data)
      out = RulesPackageRuleset.new
      out.type = "ruleset"
      out.id = Datasworn::from_json_data(RulesetID, data["_id"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetCollection], data["assets"])
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.datasworn_version = Datasworn::from_json_data(RulesPackageRulesetDataswornVersion, data["datasworn_version"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(WebURL, data["license"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleTablesCollection], data["oracles"])
      out.rules = Datasworn::from_json_data(Rules, data["rules"])
      out.title = Datasworn::from_json_data(Label, data["title"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.atlas = Datasworn::from_json_data(Hash[String, AtlasCollection], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = { "type" => "ruleset" }
      data["_id"] = Datasworn::to_json_data(id)
      data["assets"] = Datasworn::to_json_data(assets)
      data["authors"] = Datasworn::to_json_data(authors)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["moves"] = Datasworn::to_json_data(moves)
      data["oracles"] = Datasworn::to_json_data(oracles)
      data["rules"] = Datasworn::to_json_data(rules)
      data["title"] = Datasworn::to_json_data(title)
      data["url"] = Datasworn::to_json_data(url)
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  class ActionRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Use _every_ roll option at once.
    ALL = new("all")

    # Use the roll option with the best/highest value.
    HIGHEST = new("highest")

    # Use the roll option with the worst/lowest value.
    LOWEST = new("lowest")

    # An automatic miss.
    MISS = new("miss")

    # The player chooses which roll option to use.
    PLAYER_CHOICE = new("player_choice")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "player_choice" => PLAYER_CHOICE,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents any kind of non-wildcard ID, including IDs of embedded objects.
  class AnyID
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Represents any kind of wildcard ID, including IDs of embedded objects.
  class AnyIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AnyMoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyMoveID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AnyMoveIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyMoveIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AnyOracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyOracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AnyOracleRollableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyOracleRollableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AnyOracleRollableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyOracleRollableRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AnyOracleRollableRowIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AnyOracleRollableRowIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET = new("asset")

    def self.from_json_data(data)
      {
        "asset" => ASSET,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class Asset
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :abilities

    # A localized category label for this asset. This is the surtitle above the
    # asset's name on the card.
    attr_accessor :category

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact

    # The primary name/label for this node.
    attr_accessor :name

    # Options are input fields set when the player purchases the asset. They're
    # likely to remain the same through the life of the asset. Typically, they
    # are rendered at the top of the asset card.
    attr_accessor :options

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :attachments

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # Controls are condition meters, clocks, counters, and other asset input
    # fields whose values are expected to change throughout the life of the
    # asset.
    attr_accessor :controls

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces

    # Describes prerequisites for purchasing or using this asset.
    attr_accessor :requirement
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = Asset.new
      out.id = Datasworn::from_json_data(AssetID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.abilities = Datasworn::from_json_data(Array[AssetAbility], data["abilities"])
      out.category = Datasworn::from_json_data(Label, data["category"])
      out.count_as_impact = Datasworn::from_json_data(TrueClass, data["count_as_impact"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Hash[String, AssetOptionField], data["options"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.type = Datasworn::from_json_data(AssetType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.attachments = Datasworn::from_json_data(AssetAttachment, data["attachments"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetControlField], data["controls"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[AssetIDWildcard], data["replaces"])
      out.requirement = Datasworn::from_json_data(MarkdownString, data["requirement"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["abilities"] = Datasworn::to_json_data(abilities)
      data["category"] = Datasworn::to_json_data(category)
      data["count_as_impact"] = Datasworn::to_json_data(count_as_impact)
      data["name"] = Datasworn::to_json_data(name)
      data["options"] = Datasworn::to_json_data(options)
      data["shared"] = Datasworn::to_json_data(shared)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["attachments"] = Datasworn::to_json_data(attachments) unless attachments.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["requirement"] = Datasworn::to_json_data(requirement) unless requirement.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # An asset ability: one of the purchasable features of an asset. Most assets
  # have three.
  class AssetAbility
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Is this asset ability enabled?
    attr_accessor :enabled

    # The complete rules text of this asset ability.
    attr_accessor :text
    attr_accessor :comment

    # Fields whose values are expected to change over the life of the asset.
    attr_accessor :controls

    # Changes made to the asset, when this ability is enabled.
    attr_accessor :enhance_asset

    # Describes changes made to various moves by this asset ability. Usually
    # these require specific trigger conditions.
    attr_accessor :enhance_moves

    # Unique moves added by this asset ability.
    attr_accessor :moves

    # A handful of asset abilities have a label/name, for instance classic
    # Ironsworn companion assets. Most canonical assets omit this property.
    attr_accessor :name

    # Fields that are expected to be set once and remain the same through the
    # life of the asset.
    attr_accessor :options
    attr_accessor :oracles
    attr_accessor :tags

    def self.from_json_data(data)
      out = AssetAbility.new
      out.id = Datasworn::from_json_data(AssetAbilityID, data["_id"])
      out.enabled = Datasworn::from_json_data(TrueClass, data["enabled"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetAbilityControlField], data["controls"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out.moves = Datasworn::from_json_data(Hash[String, EmbeddedMove], data["moves"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Hash[String, AssetAbilityOptionField], data["options"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["enabled"] = Datasworn::to_json_data(enabled)
      data["text"] = Datasworn::to_json_data(text)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["name"] = Datasworn::to_json_data(name) unless name.nil?
      data["options"] = Datasworn::to_json_data(options) unless options.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class AssetAbilityControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "checkbox" => AssetAbilityControlFieldCheckbox,
        "clock" => AssetAbilityControlFieldClock,
        "counter" => AssetAbilityControlFieldCounter,
        "text" => AssetAbilityControlFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetAbilityControlFieldCheckbox < AssetAbilityControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A clock with 4 or more segments.
  class AssetAbilityControlFieldClock < AssetAbilityControlField
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :rollable
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldClock.new
      out.field_type = "clock"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "clock" }
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A basic counter representing a non-rollable integer value. They usually
  # start at 0, and may or may not have a maximum.
  class AssetAbilityControlFieldCounter < AssetAbilityControlField
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :rollable
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCounter.new
      out.field_type = "counter"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "counter" }
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents an input that accepts plain text.
  class AssetAbilityControlFieldText < AssetAbilityControlField
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldText.new
      out.field_type = "text"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID representing an AssetAbility object.
  class AssetAbilityID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AssetAbilityId that can be used to match multiple AssetAbility
  # objects.
  class AssetAbilityIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing an AssetAbilityMove object.
  class AssetAbilityMoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityMoveID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AssetAbilityMoveId that can be used to match multiple
  # AssetAbilityMove objects.
  class AssetAbilityMoveIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityMoveIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetAbilityOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "text" => AssetAbilityOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Represents an input that accepts plain text.
  class AssetAbilityOptionFieldText < AssetAbilityOptionField
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityOptionFieldText.new
      out.field_type = "text"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID representing an AssetAbilityOracleRollable object.
  class AssetAbilityOracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityOracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AssetAbilityOracleRollableId that can be used to match multiple
  # AssetAbilityOracleRollable objects.
  class AssetAbilityOracleRollableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityOracleRollableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing an AssetAbilityOracleRollableRow object.
  class AssetAbilityOracleRollableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityOracleRollableRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AssetAbilityOracleRollableRowId that can be used to match
  # multiple AssetAbilityOracleRollableRow objects.
  class AssetAbilityOracleRollableRowIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityOracleRollableRowIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes which assets can be attached to this asset. Example: Starforged's
  # Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
  # Starforged for more info.
  class AssetAttachment
    # Asset IDs (which may be wildcards) that may be attached to this asset
    attr_accessor :assets
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetAttachment.new
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets)
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  class AssetCardFlipFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CARD_FLIP = new("card_flip")

    def self.from_json_data(data)
      {
        "card_flip" => CARD_FLIP,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AssetCardFlipField
    # Does this field disable the asset when its value is set to `true`?
    attr_accessor :disables_asset
    attr_accessor :field_type

    # Does this field count as an impact (Starforged) or debility (Ironsworn
    # classic) when its value is set to `true`?
    attr_accessor :is_impact
    attr_accessor :label

    # Is the card flipped over?
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetCardFlipField.new
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.field_type = Datasworn::from_json_data(AssetCardFlipFieldFieldType, data["field_type"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetCheckboxFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHECKBOX = new("checkbox")

    def self.from_json_data(data)
      {
        "checkbox" => CHECKBOX,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AssetCheckboxField
    # Does this field disable the asset when its value is set to `true`?
    attr_accessor :disables_asset
    attr_accessor :field_type

    # Does this field count as an impact (Starforged) or debility (Ironsworn
    # classic) when its value is set to `true`?
    attr_accessor :is_impact
    attr_accessor :label

    # Is the box checked?
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetCheckboxField.new
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.field_type = Datasworn::from_json_data(AssetCheckboxFieldFieldType, data["field_type"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET_COLLECTION = new("asset_collection")

    def self.from_json_data(data)
      {
        "asset_collection" => ASSET_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AssetCollection
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :collections
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = AssetCollection.new
      out.id = Datasworn::from_json_data(AssetCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.collections = Datasworn::from_json_data(Hash[String, AssetCollection], data["collections"])
      out.contents = Datasworn::from_json_data(Hash[String, Asset], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(AssetCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[AssetCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[AssetCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["collections"] = Datasworn::to_json_data(collections)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing an AssetCollection object.
  class AssetCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AssetCollectionId that can be used to match multiple
  # AssetCollection objects.
  class AssetCollectionIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetCollectionIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetConditionMeterFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CONDITION_METER = new("condition_meter")

    def self.from_json_data(data)
      {
        "condition_meter" => CONDITION_METER,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Provides hints for moves that interact with this condition meter, such as
  # suffer and recovery moves.
  class AssetConditionMeterMoves
    # The ID(s) of recovery moves associated with this meter.
    attr_accessor :recover

    # The ID(s) of suffer moves associated with the condition meter. If the
    # suffer move makes an action roll, this condition meter value should be
    # made available as a roll option.
    attr_accessor :suffer

    def self.from_json_data(data)
      out = AssetConditionMeterMoves.new
      out.recover = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["recover"])
      out.suffer = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["suffer"])
      out
    end

    def to_json_data
      data = {}
      data["recover"] = Datasworn::to_json_data(recover) unless recover.nil?
      data["suffer"] = Datasworn::to_json_data(suffer) unless suffer.nil?
      data
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetConditionMeter
    # Checkbox controls rendered as part of the condition meter.
    attr_accessor :controls
    attr_accessor :field_type
    attr_accessor :label

    # The maximum value of this meter.
    attr_accessor :max

    # The minimum value of this meter.
    attr_accessor :min

    # Is this meter's `value` usable as a stat in an action roll?
    attr_accessor :rollable

    # The current value of this meter.
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    # Provides hints for moves that interact with this condition meter, such as
    # suffer and recovery moves.
    attr_accessor :moves

    def self.from_json_data(data)
      out = AssetConditionMeter.new
      out.controls = Datasworn::from_json_data(Hash[String, AssetConditionMeterControlField], data["controls"])
      out.field_type = Datasworn::from_json_data(AssetConditionMeterFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.moves = Datasworn::from_json_data(AssetConditionMeterMoves, data["moves"])
      out
    end

    def to_json_data
      data = {}
      data["controls"] = Datasworn::to_json_data(controls)
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data
    end
  end

  # A checkbox control field, rendered as part of an asset condition meter.
  class AssetConditionMeterControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "card_flip" => AssetConditionMeterControlFieldCardFlip,
        "checkbox" => AssetConditionMeterControlFieldCheckbox,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetConditionMeterControlFieldCardFlip < AssetConditionMeterControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldCardFlip.new
      out.field_type = "card_flip"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "card_flip" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetConditionMeterControlFieldCheckbox < AssetConditionMeterControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetConditionMeterEnhancementFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CONDITION_METER = new("condition_meter")

    def self.from_json_data(data)
      {
        "condition_meter" => CONDITION_METER,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetConditionMeterEnhancement
    attr_accessor :field_type

    # The maximum value of this meter.
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetConditionMeterEnhancement.new
      out.field_type = Datasworn::from_json_data(AssetConditionMeterEnhancementFieldType, data["field_type"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = {}
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  class AssetControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "card_flip" => AssetControlFieldCardFlip,
        "checkbox" => AssetControlFieldCheckbox,
        "condition_meter" => AssetControlFieldConditionMeter,
        "select_enhancement" => AssetControlFieldSelectEnhancement,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetControlFieldCardFlip < AssetControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldCardFlip.new
      out.field_type = "card_flip"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "card_flip" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetControlFieldCheckbox < AssetControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Provides hints for moves that interact with this condition meter, such as
  # suffer and recovery moves.
  class AssetControlFieldConditionMeterMoves
    # The ID(s) of recovery moves associated with this meter.
    attr_accessor :recover

    # The ID(s) of suffer moves associated with the condition meter. If the
    # suffer move makes an action roll, this condition meter value should be
    # made available as a roll option.
    attr_accessor :suffer

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeterMoves.new
      out.recover = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["recover"])
      out.suffer = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["suffer"])
      out
    end

    def to_json_data
      data = {}
      data["recover"] = Datasworn::to_json_data(recover) unless recover.nil?
      data["suffer"] = Datasworn::to_json_data(suffer) unless suffer.nil?
      data
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetControlFieldConditionMeter < AssetControlField
    attr_accessor :controls
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :rollable
    attr_accessor :value
    attr_accessor :icon
    attr_accessor :moves

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeter.new
      out.field_type = "condition_meter"
      out.controls = Datasworn::from_json_data(Hash[String, AssetConditionMeterControlField], data["controls"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.moves = Datasworn::from_json_data(AssetControlFieldConditionMeterMoves, data["moves"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["controls"] = Datasworn::to_json_data(controls)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data
    end
  end

  class AssetControlFieldSelectEnhancementChoice
    attr_accessor :choice_type

    def self.from_json_data(data)
      {
        "choice" => AssetControlFieldSelectEnhancementChoiceChoice,
        "choice_group" => AssetControlFieldSelectEnhancementChoiceChoiceGroup,
      }[data["choice_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceChoice < AssetControlFieldSelectEnhancementChoice
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceChoice.new
      out.choice_type = "choice"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceChoiceGroup < AssetControlFieldSelectEnhancementChoice
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceChoiceGroup.new
      out.choice_type = "choice_group"
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice], data["choices"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class AssetControlFieldSelectEnhancement < AssetControlField
    attr_accessor :choices
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancement.new
      out.field_type = "select_enhancement"
      out.choices = Datasworn::from_json_data(Hash[String, AssetControlFieldSelectEnhancementChoice], data["choices"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_enhancement" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetControlFieldEnhancement
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "condition_meter" => AssetControlFieldEnhancementConditionMeter,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetControlFieldEnhancementConditionMeter < AssetControlFieldEnhancement
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetControlFieldEnhancementConditionMeter.new
      out.field_type = "condition_meter"
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  # A reference to the value of an asset control.
  class AssetControlValueRefUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET_CONTROL = new("asset_control")

    def self.from_json_data(data)
      {
        "asset_control" => ASSET_CONTROL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A reference to the value of an asset control.
  class AssetControlValueRef
    attr_accessor :assets

    # The dictionary key of the asset control field.
    attr_accessor :control

    # A reference to the value of an asset control.
    attr_accessor :using

    def self.from_json_data(data)
      out = AssetControlValueRef.new
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.using = Datasworn::from_json_data(AssetControlValueRefUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets)
      data["control"] = Datasworn::to_json_data(control)
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes enhancements made to this asset in a partial asset object. The
  # changes should be applied recursively; only the values that are specified
  # should be changed.
  class AssetEnhancement
    attr_accessor :attachments

    # Controls are condition meters, clocks, counters, and other asset input
    # fields whose values are expected to change throughout the life of the
    # asset.
    attr_accessor :controls

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = AssetEnhancement.new
      out.attachments = Datasworn::from_json_data(AssetAttachment, data["attachments"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetControlFieldEnhancement], data["controls"])
      out.count_as_impact = Datasworn::from_json_data(TrueClass, data["count_as_impact"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["attachments"] = Datasworn::to_json_data(attachments) unless attachments.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["count_as_impact"] = Datasworn::to_json_data(count_as_impact) unless count_as_impact.nil?
      data["shared"] = Datasworn::to_json_data(shared) unless shared.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A unique ID representing an Asset object.
  class AssetID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AssetId that can be used to match multiple Asset objects.
  class AssetIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Options are asset input fields which are set once, usually when the
  # character takes the asset. The most common example is the "name" field on
  # companion assets. A more complex example is the choice of a god's stat for
  # the Devotant asset.
  class AssetOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "select_enhancement" => AssetOptionFieldSelectEnhancement,
        "select_value" => AssetOptionFieldSelectValue,
        "text" => AssetOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetOptionFieldSelectEnhancementChoice
    attr_accessor :choice_type

    def self.from_json_data(data)
      {
        "choice" => AssetOptionFieldSelectEnhancementChoiceChoice,
        "choice_group" => AssetOptionFieldSelectEnhancementChoiceChoiceGroup,
      }[data["choice_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceChoice < AssetOptionFieldSelectEnhancementChoice
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceChoice.new
      out.choice_type = "choice"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceChoiceGroup < AssetOptionFieldSelectEnhancementChoice
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceChoiceGroup.new
      out.choice_type = "choice_group"
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice], data["choices"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class AssetOptionFieldSelectEnhancement < AssetOptionField
    attr_accessor :choices
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancement.new
      out.field_type = "select_enhancement"
      out.choices = Datasworn::from_json_data(Hash[String, AssetOptionFieldSelectEnhancementChoice], data["choices"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_enhancement" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents a list of mutually exclusive choices.
  class AssetOptionFieldSelectValue < AssetOptionField
    attr_accessor :choices
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValue.new
      out.field_type = "select_value"
      out.choices = Datasworn::from_json_data(Hash[String, SelectValueFieldChoice], data["choices"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_value" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents an input that accepts plain text.
  class AssetOptionFieldText < AssetOptionField
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldText.new
      out.field_type = "text"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A reference to the value of an asset option.
  class AssetOptionValueRefUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET_OPTION = new("asset_option")

    def self.from_json_data(data)
      {
        "asset_option" => ASSET_OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A reference to the value of an asset option.
  class AssetOptionValueRef
    attr_accessor :assets

    # The dictionary key of the asset option field.
    attr_accessor :option

    # A reference to the value of an asset option.
    attr_accessor :using

    def self.from_json_data(data)
      out = AssetOptionValueRef.new
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out.using = Datasworn::from_json_data(AssetOptionValueRefUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets)
      data["option"] = Datasworn::to_json_data(option)
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  class AtlasCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ATLAS_COLLECTION = new("atlas_collection")

    def self.from_json_data(data)
      {
        "atlas_collection" => ATLAS_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AtlasCollection
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :collections
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = AtlasCollection.new
      out.id = Datasworn::from_json_data(AtlasCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.collections = Datasworn::from_json_data(Hash[String, AtlasCollection], data["collections"])
      out.contents = Datasworn::from_json_data(Hash[String, AtlasEntry], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(AtlasCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[AtlasCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[AtlasCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["collections"] = Datasworn::to_json_data(collections)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing an AtlasCollection object.
  class AtlasCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AtlasCollectionId that can be used to match multiple
  # AtlasCollection objects.
  class AtlasCollectionIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasCollectionIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AtlasEntryType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ATLAS_ENTRY = new("atlas_entry")

    def self.from_json_data(data)
      {
        "atlas_entry" => ATLAS_ENTRY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An atlas entry, like the Ironlands region entries found in classic
  # Ironsworn.
  class AtlasEntry
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :description
    attr_accessor :features
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :quest_starter

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags
    attr_accessor :your_truth

    def self.from_json_data(data)
      out = AtlasEntry.new
      out.id = Datasworn::from_json_data(AtlasEntryID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.features = Datasworn::from_json_data(Array[MarkdownString], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(AtlasEntryType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.replaces = Datasworn::from_json_data(Array[AtlasEntryIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.your_truth = Datasworn::from_json_data(MarkdownString, data["your_truth"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["description"] = Datasworn::to_json_data(description)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["quest_starter"] = Datasworn::to_json_data(quest_starter) unless quest_starter.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["your_truth"] = Datasworn::to_json_data(your_truth) unless your_truth.nil?
      data
    end
  end

  # A unique ID representing an AtlasEntry object.
  class AtlasEntryID
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasEntryID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded AtlasEntryId that can be used to match multiple AtlasEntry
  # objects.
  class AtlasEntryIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasEntryIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A reference to the value of an attached asset control. For example, a Module
  # asset could use this to roll using the `integrity` control of an attached
  # Vehicle.
  class AttachedAssetControlValueRefUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ATTACHED_ASSET_CONTROL = new("attached_asset_control")

    def self.from_json_data(data)
      {
        "attached_asset_control" => ATTACHED_ASSET_CONTROL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A reference to the value of an attached asset control. For example, a Module
  # asset could use this to roll using the `integrity` control of an attached
  # Vehicle.
  class AttachedAssetControlValueRef
    # The dictionary key of the asset control field.
    attr_accessor :control

    # A reference to the value of an attached asset control. For example, a
    # Module asset could use this to roll using the `integrity` control of an
    # attached Vehicle.
    attr_accessor :using

    def self.from_json_data(data)
      out = AttachedAssetControlValueRef.new
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.using = Datasworn::from_json_data(AttachedAssetControlValueRefUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["control"] = Datasworn::to_json_data(control)
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # A reference to the value of an attached asset option.
  class AttachedAssetOptionValueRefUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ATTACHED_ASSET_OPTION = new("attached_asset_option")

    def self.from_json_data(data)
      {
        "attached_asset_option" => ATTACHED_ASSET_OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A reference to the value of an attached asset option.
  class AttachedAssetOptionValueRef
    # The dictionary key of the asset option field.
    attr_accessor :option

    # A reference to the value of an attached asset option.
    attr_accessor :using

    def self.from_json_data(data)
      out = AttachedAssetOptionValueRef.new
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out.using = Datasworn::from_json_data(AttachedAssetOptionValueRefUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["option"] = Datasworn::to_json_data(option)
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Information on the original creator of this material.
  class AuthorInfo
    # The name of the author.
    attr_accessor :name

    # An optional email contact for the author
    attr_accessor :email

    # An optional URL for the author's website.
    attr_accessor :url

    def self.from_json_data(data)
      out = AuthorInfo.new
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.email = Datasworn::from_json_data(Email, data["email"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out
    end

    def to_json_data
      data = {}
      data["name"] = Datasworn::to_json_data(name)
      data["email"] = Datasworn::to_json_data(email) unless email.nil?
      data["url"] = Datasworn::to_json_data(url) unless url.nil?
      data
    end
  end

  # Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
  class ChallengeRank
    attr_accessor :value

    def self.from_json_data(data)
      out = ChallengeRank.new
      out.value = Datasworn.from_json_data(Integer, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class ClockFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CLOCK = new("clock")

    def self.from_json_data(data)
      {
        "clock" => CLOCK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A clock with 4 or more segments.
  class ClockField
    attr_accessor :field_type
    attr_accessor :label

    # The size of the clock -- in other words, the maximum number of filled
    # clock segments. Standard clocks have 4, 6, 8, or 10 segments.
    attr_accessor :max

    # The minimum number of filled clock segments. This is always 0.
    attr_accessor :min
    attr_accessor :rollable

    # The current value of this input.
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = ClockField.new
      out.field_type = Datasworn::from_json_data(ClockFieldFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class CollectableType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET = new("asset")
    ATLAS_ENTRY = new("atlas_entry")
    MOVE = new("move")
    NPC = new("npc")
    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "asset" => ASSET,
        "atlas_entry" => ATLAS_ENTRY,
        "move" => MOVE,
        "npc" => NPC,
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class CollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET_COLLECTION = new("asset_collection")
    ATLAS_COLLECTION = new("atlas_collection")
    MOVE_CATEGORY = new("move_category")
    NPC_COLLECTION = new("npc_collection")
    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "asset_collection" => ASSET_COLLECTION,
        "atlas_collection" => ATLAS_COLLECTION,
        "move_category" => MOVE_CATEGORY,
        "npc_collection" => NPC_COLLECTION,
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ConditionMeterFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CONDITION_METER = new("condition_meter")

    def self.from_json_data(data)
      {
        "condition_meter" => CONDITION_METER,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A meter with an integer value, bounded by a minimum and maximum.
  class ConditionMeterField
    attr_accessor :field_type
    attr_accessor :label

    # The maximum value of this meter.
    attr_accessor :max

    # The minimum value of this meter.
    attr_accessor :min

    # Is this meter's `value` usable as a stat in an action roll?
    attr_accessor :rollable

    # The current value of this meter.
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = ConditionMeterField.new
      out.field_type = Datasworn::from_json_data(ConditionMeterFieldFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A basic, rollable player character resource specified by the ruleset.
  class ConditionMeterKey
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterKey.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes a standard player character condition meter.
  class ConditionMeterRule
    # A description of this condition meter.
    attr_accessor :description
    attr_accessor :label

    # The maximum value of this meter.
    attr_accessor :max

    # The minimum value of this meter.
    attr_accessor :min

    # Is this meter's `value` usable as a stat in an action roll?
    attr_accessor :rollable

    # Is this condition meter shared by all players?
    attr_accessor :shared

    # The current value of this meter.
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["shared"] = Datasworn::to_json_data(shared)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  # A reference to the value of a standard player condition meter.
  class ConditionMeterValueRefUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CONDITION_METER = new("condition_meter")

    def self.from_json_data(data)
      {
        "condition_meter" => CONDITION_METER,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A reference to the value of a standard player condition meter.
  class ConditionMeterValueRef
    attr_accessor :condition_meter

    # A reference to the value of a standard player condition meter.
    attr_accessor :using

    def self.from_json_data(data)
      out = ConditionMeterValueRef.new
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out.using = Datasworn::from_json_data(ConditionMeterValueRefUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  class CoreTags
    # This object requires allies to function, and is intended for co-op play,
    # or guided play with allies. It is not appropriate for solo play.
    attr_accessor :requires_allies

    # This object is supernatural in nature, and is ideal for settings that
    # feature supernatural or mythic powers.
    attr_accessor :supernatural

    # This object is technological in nature, and is ideal for settings that
    # feature remarkable technologies.
    attr_accessor :technological

    def self.from_json_data(data)
      out = CoreTags.new
      out.requires_allies = Datasworn::from_json_data(TrueClass, data["requires_allies"])
      out.supernatural = Datasworn::from_json_data(TrueClass, data["supernatural"])
      out.technological = Datasworn::from_json_data(TrueClass, data["technological"])
      out
    end

    def to_json_data
      data = {}
      data["requires_allies"] = Datasworn::to_json_data(requires_allies) unless requires_allies.nil?
      data["supernatural"] = Datasworn::to_json_data(supernatural) unless supernatural.nil?
      data["technological"] = Datasworn::to_json_data(technological) unless technological.nil?
      data
    end
  end

  class CounterFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COUNTER = new("counter")

    def self.from_json_data(data)
      {
        "counter" => COUNTER,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A basic counter representing a non-rollable integer value. They usually
  # start at 0, and may or may not have a maximum.
  class CounterField
    attr_accessor :field_type
    attr_accessor :label
    attr_accessor :max

    # The (inclusive) minimum value.
    attr_accessor :min
    attr_accessor :rollable

    # The current value of this input.
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = CounterField.new
      out.field_type = Datasworn::from_json_data(CounterFieldFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A CSS color value.
  class CSSColor
    attr_accessor :value

    def self.from_json_data(data)
      out = CSSColor.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # An arbitrary static integer value with a label.
  class CustomValueUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CUSTOM = new("custom")

    def self.from_json_data(data)
      {
        "custom" => CUSTOM,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An arbitrary static integer value with a label.
  class CustomValue
    attr_accessor :label

    # An arbitrary static integer value with a label.
    attr_accessor :using
    attr_accessor :value

    def self.from_json_data(data)
      out = CustomValue.new
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.using = Datasworn::from_json_data(CustomValueUsing, data["using"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Datasworn::to_json_data(label)
      data["using"] = Datasworn::to_json_data(using)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  class DelveSiteType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE = new("delve_site")

    def self.from_json_data(data)
      {
        "delve_site" => DELVE_SITE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A delve site with a theme, domain, and denizens.
  class DelveSite
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # Represents the delve site's denizen matrix as an array of objects.
    attr_accessor :denizens
    attr_accessor :description

    # The ID of the site's DelveSiteDomain card.
    attr_accessor :domain

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :rank

    # The ID of the site's DelveSiteTheme card.
    attr_accessor :theme
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An additional theme or domain card ID, for use with optional rules in
    # Ironsworn: Delve.
    attr_accessor :extra_card

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # The ID of an atlas entry representing the region in which this delve site
    # is located.
    attr_accessor :region

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = DelveSite.new
      out.id = Datasworn::from_json_data(DelveSiteID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.denizens = Datasworn::from_json_data(Array[DelveSiteDenizen], data["denizens"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.domain = Datasworn::from_json_data(DelveSiteDomainID, data["domain"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.theme = Datasworn::from_json_data(DelveSiteThemeID, data["theme"])
      out.type = Datasworn::from_json_data(DelveSiteType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.extra_card = Datasworn::from_json_data(String, data["extra_card"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.region = Datasworn::from_json_data(AtlasEntryID, data["region"])
      out.replaces = Datasworn::from_json_data(Array[DelveSiteIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["denizens"] = Datasworn::to_json_data(denizens)
      data["description"] = Datasworn::to_json_data(description)
      data["domain"] = Datasworn::to_json_data(domain)
      data["name"] = Datasworn::to_json_data(name)
      data["rank"] = Datasworn::to_json_data(rank)
      data["theme"] = Datasworn::to_json_data(theme)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["extra_card"] = Datasworn::to_json_data(extra_card) unless extra_card.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["region"] = Datasworn::to_json_data(region) unless region.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Represents an entry in a delve site denizen matrix. Denizen matrices are
  # described in Ironsworn: Delve.
  class DelveSiteDenizen
    attr_accessor :id
    attr_accessor :frequency
    attr_accessor :roll

    # A name for the denizen, if it's different than the `name` property of
    # the NPC.
    attr_accessor :name

    # The ID of the relevant NPC entry, if one is specified.
    attr_accessor :npc

    def self.from_json_data(data)
      out = DelveSiteDenizen.new
      out.id = Datasworn::from_json_data(DelveSiteDenizenID, data["_id"])
      out.frequency = Datasworn::from_json_data(DelveSiteDenizenFrequency, data["frequency"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.npc = Datasworn::from_json_data(NpcID, data["npc"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["frequency"] = Datasworn::to_json_data(frequency)
      data["roll"] = Datasworn::to_json_data(roll)
      data["name"] = Datasworn::to_json_data(name) unless name.nil?
      data["npc"] = Datasworn::to_json_data(npc) unless npc.nil?
      data
    end
  end

  class DelveSiteDenizenFrequency
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COMMON = new("common")
    RARE = new("rare")
    UNCOMMON = new("uncommon")
    UNFORESEEN = new("unforeseen")
    VERY_COMMON = new("very_common")

    def self.from_json_data(data)
      {
        "common" => COMMON,
        "rare" => RARE,
        "uncommon" => UNCOMMON,
        "unforeseen" => UNFORESEEN,
        "very_common" => VERY_COMMON,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A unique ID representing a DelveSiteDenizen object.
  class DelveSiteDenizenID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDenizenID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteDenizenId that can be used to match multiple
  # DelveSiteDenizen objects.
  class DelveSiteDenizenIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDenizenIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class DelveSiteDomainType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE_DOMAIN = new("delve_site_domain")

    def self.from_json_data(data)
      {
        "delve_site_domain" => DELVE_SITE_DOMAIN,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A delve site Domain card.
  class DelveSiteDomain
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :dangers
    attr_accessor :features

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # An oracle table ID containing place name elements. For examples, see
    # oracle ID `oracle_rollable:delve/site_name/place/barrow`, and its siblings
    # in oracle collection ID `oracle_collection:delve/site_name/place`.
    # These oracles are used by the site name oracle from Ironsworn: Delve
    # (`oracle_rollable:delve/site_name/format`) to create random names for
    # delve sites.
    attr_accessor :name_oracle

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = DelveSiteDomain.new
      out.id = Datasworn::from_json_data(DelveSiteDomainID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.dangers = Datasworn::from_json_data(Array[DelveSiteDomainDanger], data["dangers"])
      out.features = Datasworn::from_json_data(Array[DelveSiteDomainFeature], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(DelveSiteDomainType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.name_oracle = Datasworn::from_json_data(OracleRollableID, data["name_oracle"])
      out.replaces = Datasworn::from_json_data(Array[DelveSiteDomainIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["dangers"] = Datasworn::to_json_data(dangers)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["name_oracle"] = Datasworn::to_json_data(name_oracle) unless name_oracle.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Represents a row in an oracle table, with a single text cell.
  class DelveSiteDomainDanger
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteDomainDanger.new
      out.id = Datasworn::from_json_data(DelveSiteDomainDangerID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A unique ID representing a DelveSiteDomainDanger object.
  class DelveSiteDomainDangerID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainDangerID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteDomainDangerId that can be used to match multiple
  # DelveSiteDomainDanger objects.
  class DelveSiteDomainDangerIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainDangerIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Represents a row in an oracle table, with a single text cell.
  class DelveSiteDomainFeature
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteDomainFeature.new
      out.id = Datasworn::from_json_data(DelveSiteDomainFeatureID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A unique ID representing a DelveSiteDomainFeature object.
  class DelveSiteDomainFeatureID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainFeatureID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteDomainFeatureId that can be used to match multiple
  # DelveSiteDomainFeature objects.
  class DelveSiteDomainFeatureIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainFeatureIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a DelveSiteDomain object.
  class DelveSiteDomainID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteDomainId that can be used to match multiple
  # DelveSiteDomain objects.
  class DelveSiteDomainIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a DelveSite object.
  class DelveSiteID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteId that can be used to match multiple DelveSite
  # objects.
  class DelveSiteIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class DelveSiteThemeType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE_THEME = new("delve_site_theme")

    def self.from_json_data(data)
      {
        "delve_site_theme" => DELVE_SITE_THEME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A delve site theme card.
  class DelveSiteTheme
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :dangers
    attr_accessor :features

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = DelveSiteTheme.new
      out.id = Datasworn::from_json_data(DelveSiteThemeID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.dangers = Datasworn::from_json_data(Array[DelveSiteThemeDanger], data["dangers"])
      out.features = Datasworn::from_json_data(Array[DelveSiteThemeFeature], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(DelveSiteThemeType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[DelveSiteThemeIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["dangers"] = Datasworn::to_json_data(dangers)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Represents a row in an oracle table, with a single text cell.
  class DelveSiteThemeDanger
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteThemeDanger.new
      out.id = Datasworn::from_json_data(DelveSiteThemeDangerID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A unique ID representing a DelveSiteThemeDanger object.
  class DelveSiteThemeDangerID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeDangerID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteThemeDangerId that can be used to match multiple
  # DelveSiteThemeDanger objects.
  class DelveSiteThemeDangerIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeDangerIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Represents a row in an oracle table, with a single text cell.
  class DelveSiteThemeFeature
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteThemeFeature.new
      out.id = Datasworn::from_json_data(DelveSiteThemeFeatureID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A unique ID representing a DelveSiteThemeFeature object.
  class DelveSiteThemeFeatureID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeFeatureID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteThemeFeatureId that can be used to match multiple
  # DelveSiteThemeFeature objects.
  class DelveSiteThemeFeatureIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeFeatureIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a DelveSiteTheme object.
  class DelveSiteThemeID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded DelveSiteThemeId that can be used to match multiple
  # DelveSiteTheme objects.
  class DelveSiteThemeIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A simple dice roll expression with an optional (positive or negative)
  # modifer.
  class DiceExpression
    attr_accessor :value

    def self.from_json_data(data)
      out = DiceExpression.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Represents a range of dice roll results, bounded by `min` and `max`
  # (inclusive).
  class DiceRange
    # High end of the dice range.
    attr_accessor :max

    # Low end of the dice range.
    attr_accessor :min

    def self.from_json_data(data)
      out = DiceRange.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A `snake_case` key used in a Datasworn dictionary object.
  class DictKey
    attr_accessor :value

    def self.from_json_data(data)
      out = DictKey.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Implementation hints or other developer-facing comments on this node. These
  # should be omitted when representing an object for gameplay.
  class Documentation
    attr_accessor :value

    def self.from_json_data(data)
      out = Documentation.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # An email address.
  class Email
    attr_accessor :value

    def self.from_json_data(data)
      out = Email.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class EmbedOnlyType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ABILITY = new("ability")
    DANGER = new("danger")
    DENIZEN = new("denizen")
    FEATURE = new("feature")
    OPTION = new("option")
    ROW = new("row")
    VARIANT = new("variant")

    def self.from_json_data(data)
      {
        "ability" => ABILITY,
        "danger" => DANGER,
        "denizen" => DENIZEN,
        "feature" => FEATURE,
        "option" => OPTION,
        "row" => ROW,
        "variant" => VARIANT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedActionRollMoveRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ACTION_ROLL = new("action_roll")

    def self.from_json_data(data)
      {
        "action_roll" => ACTION_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedActionRollMoveType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedActionRollMove
    attr_accessor :id

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedActionRollMove.new
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.roll_type = Datasworn::from_json_data(EmbeddedActionRollMoveRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerActionRoll, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedActionRollMoveType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedMove
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => EmbeddedMoveActionRoll,
        "no_roll" => EmbeddedMoveNoRoll,
        "progress_roll" => EmbeddedMoveProgressRoll,
        "special_track" => EmbeddedMoveSpecialTrack,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  class EmbeddedMoveActionRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedMoveActionRoll < EmbeddedMove
    attr_accessor :id
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedMoveActionRoll.new
      out.roll_type = "action_roll"
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerActionRoll, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedMoveActionRollType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedMoveNoRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedMoveNoRoll < EmbeddedMove
    attr_accessor :id
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedMoveNoRoll.new
      out.roll_type = "no_roll"
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerNoRoll, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedMoveNoRollType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedMoveProgressRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedMoveProgressRoll < EmbeddedMove
    attr_accessor :id
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :tracks
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedMoveProgressRoll.new
      out.roll_type = "progress_roll"
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.tracks = Datasworn::from_json_data(ProgressTrackTypeInfo, data["tracks"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRoll, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedMoveProgressRollType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["tracks"] = Datasworn::to_json_data(tracks)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedMoveSpecialTrackType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedMoveSpecialTrack < EmbeddedMove
    attr_accessor :id
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedMoveSpecialTrack.new
      out.roll_type = "special_track"
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrack, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedMoveSpecialTrackType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedMoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = EmbeddedMoveID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class EmbeddedMoveIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = EmbeddedMoveIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class EmbeddedNoRollMoveRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NO_ROLL = new("no_roll")

    def self.from_json_data(data)
      {
        "no_roll" => NO_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedNoRollMoveType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedNoRollMove
    attr_accessor :id

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedNoRollMove.new
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.roll_type = Datasworn::from_json_data(EmbeddedNoRollMoveRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerNoRoll, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedNoRollMoveType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleColumnTextOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT = new("column_text")

    def self.from_json_data(data)
      {
        "column_text" => COLUMN_TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleColumnTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleColumnTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleColumnTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleColumnText
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleColumnText.new
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(EmbeddedOracleColumnTextOracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleColumnTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleColumnTextRecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleColumnText2OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT2 = new("column_text2")

    def self.from_json_data(data)
      {
        "column_text2" => COLUMN_TEXT2,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleColumnText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleColumnText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleColumnText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleColumnText2
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleColumnText2.new
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(EmbeddedOracleColumnText2OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleColumnText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleColumnText2RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleColumnText3OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT3 = new("column_text3")

    def self.from_json_data(data)
      {
        "column_text3" => COLUMN_TEXT3,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleColumnText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleColumnText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleColumnText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleColumnText3
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleColumnText3.new
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(EmbeddedOracleColumnText3OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleColumnText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleColumnText3RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollable
    attr_accessor :oracle_type

    def self.from_json_data(data)
      {
        "column_text" => EmbeddedOracleRollableColumnText,
        "column_text2" => EmbeddedOracleRollableColumnText2,
        "column_text3" => EmbeddedOracleRollableColumnText3,
        "table_text" => EmbeddedOracleRollableTableText,
        "table_text2" => EmbeddedOracleRollableTableText2,
        "table_text3" => EmbeddedOracleRollableTableText3,
      }[data["oracle_type"]].from_json_data(data)
    end
  end

  class EmbeddedOracleRollableColumnTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleRollableColumnTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleRollableColumnTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleRollableColumnText < EmbeddedOracleRollable
    attr_accessor :id
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleRollableColumnText.new
      out.oracle_type = "column_text"
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleRollableColumnTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleRollableColumnTextRecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "column_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollableColumnText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleRollableColumnText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleRollableColumnText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleRollableColumnText2 < EmbeddedOracleRollable
    attr_accessor :id
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleRollableColumnText2.new
      out.oracle_type = "column_text2"
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleRollableColumnText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleRollableColumnText2RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "column_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollableColumnText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleRollableColumnText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleRollableColumnText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleRollableColumnText3 < EmbeddedOracleRollable
    attr_accessor :id
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleRollableColumnText3.new
      out.oracle_type = "column_text3"
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleRollableColumnText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleRollableColumnText3RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "column_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollableTableTextColumnLabels
    attr_accessor :roll
    attr_accessor :text

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableTextColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class EmbeddedOracleRollableTableTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleRollableTableTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleRollableTableText < EmbeddedOracleRollable
    attr_accessor :id
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText.new
      out.oracle_type = "table_text"
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.column_labels = Datasworn::from_json_data(EmbeddedOracleRollableTableTextColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleRollableTableTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleRollableTableTextRecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollableTableText2ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText2ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class EmbeddedOracleRollableTableText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleRollableTableText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleRollableTableText2 < EmbeddedOracleRollable
    attr_accessor :id
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText2.new
      out.oracle_type = "table_text2"
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.column_labels = Datasworn::from_json_data(EmbeddedOracleRollableTableText2ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleRollableTableText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleRollableTableText2RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollableTableText3ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText3ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class EmbeddedOracleRollableTableText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleRollableTableText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleRollableTableText3 < EmbeddedOracleRollable
    attr_accessor :id
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleRollableTableText3.new
      out.oracle_type = "table_text3"
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.column_labels = Datasworn::from_json_data(EmbeddedOracleRollableTableText3ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleRollableTableText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleRollableTableText3RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = EmbeddedOracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class EmbeddedOracleRollableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = EmbeddedOracleRollableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class EmbeddedOracleTableTextColumnLabels
    attr_accessor :roll
    attr_accessor :text

    def self.from_json_data(data)
      out = EmbeddedOracleTableTextColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class EmbeddedOracleTableTextOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_TEXT = new("table_text")

    def self.from_json_data(data)
      {
        "table_text" => TABLE_TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleTableTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleTableTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleTableTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleTableText
    attr_accessor :id
    attr_accessor :column_labels

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleTableText.new
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.column_labels = Datasworn::from_json_data(EmbeddedOracleTableTextColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(EmbeddedOracleTableTextOracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleTableTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleTableTextRecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleTableText2ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = EmbeddedOracleTableText2ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class EmbeddedOracleTableText2OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_TEXT2 = new("table_text2")

    def self.from_json_data(data)
      {
        "table_text2" => TABLE_TEXT2,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleTableText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleTableText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleTableText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleTableText2
    attr_accessor :id
    attr_accessor :column_labels

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleTableText2.new
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.column_labels = Datasworn::from_json_data(EmbeddedOracleTableText2ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(EmbeddedOracleTableText2OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleTableText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleTableText2RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedOracleTableText3ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = EmbeddedOracleTableText3ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class EmbeddedOracleTableText3OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_TEXT3 = new("table_text3")

    def self.from_json_data(data)
      {
        "table_text3" => TABLE_TEXT3,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleTableText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedOracleTableText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = EmbeddedOracleTableText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class EmbeddedOracleTableText3
    attr_accessor :id
    attr_accessor :column_labels

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedOracleTableText3.new
      out.id = Datasworn::from_json_data(EmbeddedOracleRollableID, data["_id"])
      out.column_labels = Datasworn::from_json_data(EmbeddedOracleTableText3ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(EmbeddedOracleTableText3OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(EmbeddedOracleTableText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(EmbeddedOracleTableText3RecommendedRolls, data["recommended_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedProgressRollMoveRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    PROGRESS_ROLL = new("progress_roll")

    def self.from_json_data(data)
      {
        "progress_roll" => PROGRESS_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedProgressRollMoveType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedProgressRollMove
    attr_accessor :id

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Describes the common features of progress tracks associated with this
    # move.
    attr_accessor :tracks

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedProgressRollMove.new
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.roll_type = Datasworn::from_json_data(EmbeddedProgressRollMoveRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.tracks = Datasworn::from_json_data(ProgressTrackTypeInfo, data["tracks"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRoll, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedProgressRollMoveType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["tracks"] = Datasworn::to_json_data(tracks)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class EmbeddedSpecialTrackMoveRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    SPECIAL_TRACK = new("special_track")

    def self.from_json_data(data)
      {
        "special_track" => SPECIAL_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedSpecialTrackMoveType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class EmbeddedSpecialTrackMove
    attr_accessor :id

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = EmbeddedSpecialTrackMove.new
      out.id = Datasworn::from_json_data(EmbeddedMoveID, data["_id"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.roll_type = Datasworn::from_json_data(EmbeddedSpecialTrackMoveRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrack, data["trigger"])
      out.type = Datasworn::from_json_data(EmbeddedSpecialTrackMoveType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # This type is a placeholder and may see signficant changes in v0.2.0.
  class EntityPrompt
    attr_accessor :text

    def self.from_json_data(data)
      out = EntityPrompt.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  # The version of the Datasworn format used by this data.
  class ExpansionDataswornVersion
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DEFAULT_NAME = new("0.1.0")

    def self.from_json_data(data)
      {
        "0.1.0" => DEFAULT_NAME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ExpansionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    EXPANSION = new("expansion")

    def self.from_json_data(data)
      {
        "expansion" => EXPANSION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A Datasworn package that relies on an external package to provide its
  # ruleset.
  class Expansion
    attr_accessor :id

    # A dictionary object containing asset collections, which contain assets.
    attr_accessor :assets

    # Lists authors credited by the source material.
    attr_accessor :authors

    # The version of the Datasworn format used by this data.
    attr_accessor :datasworn_version

    # The date of the source documents's last update, formatted YYYY-MM-DD.
    # Required because it's used to determine whether the data needs updating.
    attr_accessor :date
    attr_accessor :license

    # A dictionary object containing move categories, which contain moves.
    attr_accessor :moves

    # A dictionary object containing oracle collections, which may contain
    # oracle tables and/or oracle collections.
    attr_accessor :oracles
    attr_accessor :ruleset

    # The title of the source document.
    attr_accessor :title
    attr_accessor :type

    # A URL where the source document is available.
    attr_accessor :url

    # A dictionary object containing atlas collections, which contain atlas
    # entries.
    attr_accessor :atlas

    # A dictionary object of delve sites, like the premade delve sites presented
    # in Ironsworn: Delve
    attr_accessor :delve_sites
    attr_accessor :description

    # A dictionary object containing NPC collections, which contain NPCs.
    attr_accessor :npcs

    # A dictionary object containing rarities, like those presented in
    # Ironsworn: Delve.
    attr_accessor :rarities
    attr_accessor :rules

    # A dictionary object containing delve site domains.
    attr_accessor :site_domains

    # A dictionary object containing delve site themes.
    attr_accessor :site_themes

    # A dictionary object of truth categories.
    attr_accessor :truths

    def self.from_json_data(data)
      out = Expansion.new
      out.id = Datasworn::from_json_data(ExpansionID, data["_id"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetCollection], data["assets"])
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.datasworn_version = Datasworn::from_json_data(ExpansionDataswornVersion, data["datasworn_version"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(WebURL, data["license"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleTablesCollection], data["oracles"])
      out.ruleset = Datasworn::from_json_data(RulesetID, data["ruleset"])
      out.title = Datasworn::from_json_data(Label, data["title"])
      out.type = Datasworn::from_json_data(ExpansionType, data["type"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.atlas = Datasworn::from_json_data(Hash[String, AtlasCollection], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.rules = Datasworn::from_json_data(RulesExpansion, data["rules"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["assets"] = Datasworn::to_json_data(assets)
      data["authors"] = Datasworn::to_json_data(authors)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["moves"] = Datasworn::to_json_data(moves)
      data["oracles"] = Datasworn::to_json_data(oracles)
      data["ruleset"] = Datasworn::to_json_data(ruleset)
      data["title"] = Datasworn::to_json_data(title)
      data["type"] = Datasworn::to_json_data(type)
      data["url"] = Datasworn::to_json_data(url)
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["rules"] = Datasworn::to_json_data(rules) unless rules.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  # The ID of a Datasworn package that relies on an external package to provide
  # its ruleset.
  class ExpansionID
    attr_accessor :value

    def self.from_json_data(data)
      out = ExpansionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class I18nHint
    # The part of speech for this string.
    attr_accessor :part_of_speech

    def self.from_json_data(data)
      out = I18nHint.new
      out.part_of_speech = Datasworn::from_json_data(PartOfSpeech, data["part_of_speech"])
      out
    end

    def to_json_data
      data = {}
      data["part_of_speech"] = Datasworn::to_json_data(part_of_speech) unless part_of_speech.nil?
      data
    end
  end

  class I18nHintsTemplate
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = I18nHintsTemplate.new
      out.text = Datasworn::from_json_data(I18nHint, data["text"])
      out.text2 = Datasworn::from_json_data(I18nHint, data["text2"])
      out.text3 = Datasworn::from_json_data(I18nHint, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data["text2"] = Datasworn::to_json_data(text2) unless text2.nil?
      data["text3"] = Datasworn::to_json_data(text3) unless text3.nil?
      data
    end
  end

  # Internationalization/localization hints for the text content of this object.
  class I18nHints
    attr_accessor :template
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = I18nHints.new
      out.template = Datasworn::from_json_data(I18nHintsTemplate, data["template"])
      out.text = Datasworn::from_json_data(I18nHint, data["text"])
      out.text2 = Datasworn::from_json_data(I18nHint, data["text2"])
      out.text3 = Datasworn::from_json_data(I18nHint, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data["text2"] = Datasworn::to_json_data(text2) unless text2.nil?
      data["text3"] = Datasworn::to_json_data(text3) unless text3.nil?
      data
    end
  end

  # Describes a category of standard impacts/debilities.
  class ImpactCategory
    # A dictionary object of the Impacts in this category.
    attr_accessor :contents

    # A description of this impact category.
    attr_accessor :description

    # A label for this impact category.
    attr_accessor :label

    def self.from_json_data(data)
      out = ImpactCategory.new
      out.contents = Datasworn::from_json_data(Hash[String, ImpactRule], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["contents"] = Datasworn::to_json_data(contents)
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  # Describes a standard impact/debility.
  class ImpactRule
    # A description of this impact.
    attr_accessor :description

    # The label for this impact.
    attr_accessor :label

    # Is this impact permanent?
    attr_accessor :permanent

    # Any ruleset condition meters that can't recover when this impact is
    # active.
    attr_accessor :prevents_recovery

    # Is this impact applied to all players at once?
    attr_accessor :shared

    def self.from_json_data(data)
      out = ImpactRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.permanent = Datasworn::from_json_data(TrueClass, data["permanent"])
      out.prevents_recovery = Datasworn::from_json_data(Array[ConditionMeterKey], data["prevents_recovery"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["permanent"] = Datasworn::to_json_data(permanent)
      data["prevents_recovery"] = Datasworn::to_json_data(prevents_recovery)
      data["shared"] = Datasworn::to_json_data(shared)
      data
    end
  end

  # A localized, player-facing name or label, formatted as plain text. In some
  # contexts it may be undesirable to render this text, but it should always be
  # exposed to assistive technology (e.g. with `aria-label` in HTML).
  class Label
    attr_accessor :value

    def self.from_json_data(data)
      out = Label.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Localized, player-facing text, formatted in Markdown. It is *not* formatted
  # for use "out of the box"; it uses some custom syntax, intended to be
  # replaced in whatever way is most appropriate for your implementation.
  # 
  # * `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to
  # the identified object. The ID must conform to the `AnyId` type; no wildcards
  # allowed.
  # * `{{table>oracle_rollable:starforged/core/action}}`: the referenced
  # oracle is rendered here in the source material. The ID must conform to the
  # `AnyOracleRollableId` type; no wildcards allowed.
  # * `{{table_columns>move:delve/delve/delve_the_depths}}`: Render
  # *all* direct OracleRollable children of the identified node. This
  # can be an OracleCollectionId, or the ID of anything that can have
  # EmbeddedOracleRollables (such as a Move or TruthOption).
  class MarkdownString
    attr_accessor :value

    def self.from_json_data(data)
      out = MarkdownString.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A rich text string in Markdown with replaced values from oracle roll
  # results.
  # 
  # The custom syntax `{{some_row_key>some_oracle_table_id}}` should be replaced
  # by the `some_row_key` string of a rolled oracle table. This is usually the
  # `text` key, for example `{{text>oracle_rollable:starforged/core/action}}`
  class MarkdownTemplateString
    attr_accessor :value

    def self.from_json_data(data)
      out = MarkdownTemplateString.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Move
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => MoveActionRoll0,
        "no_roll" => MoveNoRoll0,
        "progress_roll" => MoveProgressRoll0,
        "special_track" => MoveSpecialTrack0,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  class MoveActionRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A move that makes an action roll.
  class MoveActionRoll0 < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveActionRoll0.new
      out.roll_type = "action_roll"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerActionRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveActionRollType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveNoRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A move that makes no progress rolls or action rolls.
  class MoveNoRoll0 < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveNoRoll0.new
      out.roll_type = "no_roll"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerNoRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveNoRollType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveProgressRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A progress move that rolls on a standard progress track type (whose features
  # are defined by this move object). For progress rolls that use special
  # tracks, see MoveSpecialTrack.
  class MoveProgressRoll0 < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :tracks
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveProgressRoll0.new
      out.roll_type = "progress_roll"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.tracks = Datasworn::from_json_data(ProgressTrackTypeInfo, data["tracks"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveProgressRollType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["tracks"] = Datasworn::to_json_data(tracks)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveSpecialTrackType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A progress move that rolls on a special track, such as Legacies (Starforged)
  # or Bonds (classic Ironsworn). For progress moves that use standard progress
  # tracks, see MoveProgressRoll instead.
  class MoveSpecialTrack0 < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :allow_momentum_burn
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveSpecialTrack0.new
      out.roll_type = "special_track"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrack, data["trigger"])
      out.type = Datasworn::from_json_data(MoveSpecialTrackType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveActionRollRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ACTION_ROLL = new("action_roll")

    def self.from_json_data(data)
      {
        "action_roll" => ACTION_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveActionRollType0
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A move that makes an action roll.
  class MoveActionRoll
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles

    # Indicates that this move replaces the identified moves. References to the
    # replaced moves can be considered equivalent to this move.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveActionRoll.new
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.roll_type = Datasworn::from_json_data(MoveActionRollRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerActionRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveActionRollType0, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A move must have this `roll_type` to receive this enhancement. This is in
  # addition to any other restrictions made by other properties.
  class MoveActionRollEnhancementRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ACTION_ROLL = new("action_roll")

    def self.from_json_data(data)
      {
        "action_roll" => ACTION_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveActionRollEnhancement
    attr_accessor :enhances

    # A move must have this `roll_type` to receive this enhancement. This is in
    # addition to any other restrictions made by other properties.
    attr_accessor :roll_type
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveActionRollEnhancement.new
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.roll_type = Datasworn::from_json_data(MoveActionRollEnhancementRollType, data["roll_type"])
      out.trigger = Datasworn::from_json_data(TriggerActionRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = {}
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  class MoveCategoryType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE_CATEGORY = new("move_category")

    def self.from_json_data(data)
      {
        "move_category" => MOVE_CATEGORY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveCategory
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :collections
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveCategory.new
      out.id = Datasworn::from_json_data(MoveCategoryID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.collections = Datasworn::from_json_data(Hash[String, MoveCategory], data["collections"])
      out.contents = Datasworn::from_json_data(Hash[String, Move], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(MoveCategoryType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[MoveCategoryIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[MoveCategoryIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["collections"] = Datasworn::to_json_data(collections)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing a MoveCategory object.
  class MoveCategoryID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveCategoryID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded MoveCategoryId that can be used to match multiple MoveCategory
  # objects.
  class MoveCategoryIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveCategoryIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveEnhancement
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => MoveEnhancementActionRoll,
        "no_roll" => MoveEnhancementNoRoll,
        "progress_roll" => MoveEnhancementProgressRoll,
        "special_track" => MoveEnhancementSpecialTrack,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementActionRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementActionRoll.new
      out.roll_type = "action_roll"
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerActionRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementNoRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementNoRoll.new
      out.roll_type = "no_roll"
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerNoRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementProgressRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementProgressRoll.new
      out.roll_type = "progress_roll"
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementSpecialTrack < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementSpecialTrack.new
      out.roll_type = "special_track"
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrackEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # A unique ID representing a Move object.
  class MoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded MoveId that can be used to match multiple Move objects.
  class MoveIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveNoRollRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NO_ROLL = new("no_roll")

    def self.from_json_data(data)
      {
        "no_roll" => NO_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveNoRollType0
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A move that makes no progress rolls or action rolls.
  class MoveNoRoll
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles

    # Indicates that this move replaces the identified moves. References to the
    # replaced moves can be considered equivalent to this move.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveNoRoll.new
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.roll_type = Datasworn::from_json_data(MoveNoRollRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerNoRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveNoRollType0, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A move must have this `roll_type` to receive this enhancement. This is in
  # addition to any other restrictions made by other properties.
  class MoveNoRollEnhancementRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NO_ROLL = new("no_roll")

    def self.from_json_data(data)
      {
        "no_roll" => NO_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveNoRollEnhancement
    attr_accessor :enhances

    # A move must have this `roll_type` to receive this enhancement. This is in
    # addition to any other restrictions made by other properties.
    attr_accessor :roll_type
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveNoRollEnhancement.new
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.roll_type = Datasworn::from_json_data(MoveNoRollEnhancementRollType, data["roll_type"])
      out.trigger = Datasworn::from_json_data(TriggerNoRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = {}
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # A unique ID representing a MoveOracleRollable object.
  class MoveOracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveOracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded MoveOracleRollableId that can be used to match multiple
  # MoveOracleRollable objects.
  class MoveOracleRollableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveOracleRollableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a MoveOracleRollableRow object.
  class MoveOracleRollableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveOracleRollableRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded MoveOracleRollableRowId that can be used to match multiple
  # MoveOracleRollableRow objects.
  class MoveOracleRollableRowIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveOracleRollableRowIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveOutcome
    attr_accessor :text
    attr_accessor :oracle_rolls

    def self.from_json_data(data)
      out = MoveOutcome.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data
    end
  end

  # A standalone localized description for each move outcome (miss, weak hit,
  # or strong hit). This is for for e.g. VTT implementations, where it's often
  # useful to display only the rules text relevant to a roll result.
  # 
  #   This often requires light editorialization to create text that can stand
  # alone without reference to the rest of the move. For example, 'as above'
  # (in reference to another move outcome) shouldn't be used here; instead, the
  # relevant text should be repeated.
  class MoveOutcomes
    attr_accessor :miss
    attr_accessor :strong_hit
    attr_accessor :weak_hit

    def self.from_json_data(data)
      out = MoveOutcomes.new
      out.miss = Datasworn::from_json_data(MoveOutcome, data["miss"])
      out.strong_hit = Datasworn::from_json_data(MoveOutcome, data["strong_hit"])
      out.weak_hit = Datasworn::from_json_data(MoveOutcome, data["weak_hit"])
      out
    end

    def to_json_data
      data = {}
      data["miss"] = Datasworn::to_json_data(miss)
      data["strong_hit"] = Datasworn::to_json_data(strong_hit)
      data["weak_hit"] = Datasworn::to_json_data(weak_hit)
      data
    end
  end

  class MoveProgressRollRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    PROGRESS_ROLL = new("progress_roll")

    def self.from_json_data(data)
      {
        "progress_roll" => PROGRESS_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveProgressRollType0
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A progress move that rolls on a standard progress track type (whose features
  # are defined by this move object). For progress rolls that use special
  # tracks, see MoveSpecialTrack.
  class MoveProgressRoll
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Describes the common features of progress tracks associated with this
    # move.
    attr_accessor :tracks

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles

    # Indicates that this move replaces the identified moves. References to the
    # replaced moves can be considered equivalent to this move.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveProgressRoll.new
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.roll_type = Datasworn::from_json_data(MoveProgressRollRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.tracks = Datasworn::from_json_data(ProgressTrackTypeInfo, data["tracks"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveProgressRollType0, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["tracks"] = Datasworn::to_json_data(tracks)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A move must have this `roll_type` to receive this enhancement. This is in
  # addition to any other restrictions made by other properties.
  class MoveProgressRollEnhancementRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    PROGRESS_ROLL = new("progress_roll")

    def self.from_json_data(data)
      {
        "progress_roll" => PROGRESS_ROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveProgressRollEnhancement
    attr_accessor :enhances

    # A move must have this `roll_type` to receive this enhancement. This is in
    # addition to any other restrictions made by other properties.
    attr_accessor :roll_type
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveProgressRollEnhancement.new
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.roll_type = Datasworn::from_json_data(MoveProgressRollEnhancementRollType, data["roll_type"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = {}
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  class MoveRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # A move that makes an action roll.
    ACTION_ROLL = new("action_roll")

    # A move that makes no action rolls or progress rolls.
    NO_ROLL = new("no_roll")

    # A progress move that rolls on a standard progress track type (defined by
    # this move).
    PROGRESS_ROLL = new("progress_roll")

    # A progress move that rolls on one or more special tracks, like Bonds
    # (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    SPECIAL_TRACK = new("special_track")

    def self.from_json_data(data)
      {
        "action_roll" => ACTION_ROLL,
        "no_roll" => NO_ROLL,
        "progress_roll" => PROGRESS_ROLL,
        "special_track" => SPECIAL_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveSpecialTrackRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    SPECIAL_TRACK = new("special_track")

    def self.from_json_data(data)
      {
        "special_track" => SPECIAL_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveSpecialTrackType0
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A progress move that rolls on a special track, such as Legacies (Starforged)
  # or Bonds (classic Ironsworn). For progress moves that use standard progress
  # tracks, see MoveProgressRoll instead.
  class MoveSpecialTrack
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # Is burning momentum allowed for this move?
    attr_accessor :allow_momentum_burn

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :roll_type

    # The complete rules text of the move.
    attr_accessor :text

    # Trigger conditions for this move.
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :oracles

    # Indicates that this move replaces the identified moves. References to the
    # replaced moves can be considered equivalent to this move.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveSpecialTrack.new
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.allow_momentum_burn = Datasworn::from_json_data(TrueClass, data["allow_momentum_burn"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.roll_type = Datasworn::from_json_data(MoveSpecialTrackRollType, data["roll_type"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrack, data["trigger"])
      out.type = Datasworn::from_json_data(MoveSpecialTrackType0, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.replaces = Datasworn::from_json_data(Array[MoveIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["allow_momentum_burn"] = Datasworn::to_json_data(allow_momentum_burn)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A move must have this `roll_type` to receive this enhancement. This is in
  # addition to any other restrictions made by other properties.
  class MoveSpecialTrackEnhancementRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    SPECIAL_TRACK = new("special_track")

    def self.from_json_data(data)
      {
        "special_track" => SPECIAL_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveSpecialTrackEnhancement
    attr_accessor :enhances

    # A move must have this `roll_type` to receive this enhancement. This is in
    # addition to any other restrictions made by other properties.
    attr_accessor :roll_type
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveSpecialTrackEnhancement.new
      out.enhances = Datasworn::from_json_data(Array[AnyMoveIDWildcard], data["enhances"])
      out.roll_type = Datasworn::from_json_data(MoveSpecialTrackEnhancementRollType, data["roll_type"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrackEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = {}
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["roll_type"] = Datasworn::to_json_data(roll_type)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  class NonCollectableType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE = new("delve_site")
    DELVE_SITE_DOMAIN = new("delve_site_domain")
    DELVE_SITE_THEME = new("delve_site_theme")
    RARITY = new("rarity")
    TRUTH = new("truth")

    def self.from_json_data(data)
      {
        "delve_site" => DELVE_SITE,
        "delve_site_domain" => DELVE_SITE_DOMAIN,
        "delve_site_theme" => DELVE_SITE_THEME,
        "rarity" => RARITY,
        "truth" => TRUTH,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class NpcType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NPC = new("npc")

    def self.from_json_data(data)
      {
        "npc" => NPC,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A non-player character entry, similar to those in Chapter 5 of the Ironsworn
  # Rulebook, or Chapter 4 of Starforged.
  class Npc
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :description
    attr_accessor :drives
    attr_accessor :features
    attr_accessor :name
    attr_accessor :nature

    # The suggested challenge rank for this NPC.
    attr_accessor :rank
    attr_accessor :tactics
    attr_accessor :type
    attr_accessor :variants
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :quest_starter

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags
    attr_accessor :your_truth

    def self.from_json_data(data)
      out = Npc.new
      out.id = Datasworn::from_json_data(NpcID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.drives = Datasworn::from_json_data(Array[MarkdownString], data["drives"])
      out.features = Datasworn::from_json_data(Array[MarkdownString], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.nature = Datasworn::from_json_data(NpcNature, data["nature"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.tactics = Datasworn::from_json_data(Array[MarkdownString], data["tactics"])
      out.type = Datasworn::from_json_data(NpcType, data["type"])
      out.variants = Datasworn::from_json_data(Hash[String, NpcVariant], data["variants"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.replaces = Datasworn::from_json_data(Array[NpcIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.your_truth = Datasworn::from_json_data(MarkdownString, data["your_truth"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["description"] = Datasworn::to_json_data(description)
      data["drives"] = Datasworn::to_json_data(drives)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["nature"] = Datasworn::to_json_data(nature)
      data["rank"] = Datasworn::to_json_data(rank)
      data["tactics"] = Datasworn::to_json_data(tactics)
      data["type"] = Datasworn::to_json_data(type)
      data["variants"] = Datasworn::to_json_data(variants)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["quest_starter"] = Datasworn::to_json_data(quest_starter) unless quest_starter.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["your_truth"] = Datasworn::to_json_data(your_truth) unless your_truth.nil?
      data
    end
  end

  class NpcCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NPC_COLLECTION = new("npc_collection")

    def self.from_json_data(data)
      {
        "npc_collection" => NPC_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class NpcCollection
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :collections
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = NpcCollection.new
      out.id = Datasworn::from_json_data(NpcCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.collections = Datasworn::from_json_data(Hash[String, NpcCollection], data["collections"])
      out.contents = Datasworn::from_json_data(Hash[String, Npc], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(NpcCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[NpcCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[NpcCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["collections"] = Datasworn::to_json_data(collections)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing a NpcCollection object.
  class NpcCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded NpcCollectionId that can be used to match multiple
  # NpcCollection objects.
  class NpcCollectionIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcCollectionIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a Npc object.
  class NpcID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded NpcId that can be used to match multiple Npc objects.
  class NpcIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A localized category label describing the nature of this NPC.
  # 
  # In Ironsworn classic, this is probably the singular form of the parent
  # collection's name.
  # 
  # For Starforged, see the table on p. 258 for examples.
  class NpcNature
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcNature.new
      out.value = Datasworn.from_json_data(Label, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class NpcVariant
    # The unique Datasworn ID for this node.
    attr_accessor :id
    attr_accessor :description
    attr_accessor :name
    attr_accessor :nature

    # The suggested challenge rank for this NPC.
    attr_accessor :rank
    attr_accessor :comment
    attr_accessor :summary

    def self.from_json_data(data)
      out = NpcVariant.new
      out.id = Datasworn::from_json_data(NpcVariantID, data["_id"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.nature = Datasworn::from_json_data(NpcNature, data["nature"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["description"] = Datasworn::to_json_data(description)
      data["name"] = Datasworn::to_json_data(name)
      data["nature"] = Datasworn::to_json_data(nature)
      data["rank"] = Datasworn::to_json_data(rank)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID representing a NpcVariant object.
  class NpcVariantID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcVariantID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded NpcVariantId that can be used to match multiple NpcVariant
  # objects.
  class NpcVariantIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcVariantIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleCollection
    attr_accessor :oracle_type

    def self.from_json_data(data)
      {
        "table_shared_rolls" => OracleCollectionTableSharedRolls,
        "table_shared_text" => OracleCollectionTableSharedText,
        "table_shared_text2" => OracleCollectionTableSharedText2,
        "table_shared_text3" => OracleCollectionTableSharedText3,
        "tables" => OracleCollectionTables,
      }[data["oracle_type"]].from_json_data(data)
    end
  end

  # Provides column labels for this table. The `roll` key refers to the roll
  # column showing the dice range (`min` and `max` on each table row). For all
  # other column labels, see the `name` property of each child `OracleColumn`.
  class OracleCollectionTableSharedRollsColumnLabels
    attr_accessor :roll

    def self.from_json_data(data)
      out = OracleCollectionTableSharedRollsColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data
    end
  end

  class OracleCollectionTableSharedRollsType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with one roll column and
  # multiple text columns.
  class OracleCollectionTableSharedRolls < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedRolls.new
      out.oracle_type = "table_shared_rolls"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedRollsColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedRollsType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_rolls" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleCollectionTableSharedTextColumnLabels
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleCollectionTableSharedTextColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleCollectionTableSharedTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns
  # and one text column.
  class OracleCollectionTableSharedText < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText.new
      out.oracle_type = "table_shared_text"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedTextColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleCollectionTableSharedText2ColumnLabels
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText2ColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleCollectionTableSharedText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns,
  # and 2 shared text columns.
  class OracleCollectionTableSharedText2 < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText2.new
      out.oracle_type = "table_shared_text2"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedText2ColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText2], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleCollectionTableSharedText3ColumnLabels
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText3ColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class OracleCollectionTableSharedText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns,
  # and 3 shared text columns.
  class OracleCollectionTableSharedText3 < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText3.new
      out.oracle_type = "table_shared_text3"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedText3ColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText3], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleCollectionTablesType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection that represents a category or grouping of tables, which
  # may themselves be `OracleTablesCollection`s.
  class OracleCollectionTables < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :collections
    attr_accessor :contents
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTables.new
      out.oracle_type = "tables"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.collections = Datasworn::from_json_data(Hash[String, OracleCollection], data["collections"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleRollableTable], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTablesType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "tables" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["collections"] = Datasworn::to_json_data(collections)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing an OracleCollection object.
  class OracleCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded OracleCollectionId that can be used to match multiple
  # OracleCollection objects.
  class OracleCollectionIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleCollectionIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleColumnTextOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT = new("column_text")

    def self.from_json_data(data)
      {
        "column_text" => COLUMN_TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleColumnTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # Represents a single column in an OracleCollection.
  class OracleColumnText
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleColumnText.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleColumnTextOracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleColumnTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleColumnTextRecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleColumnText2OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT2 = new("column_text2")

    def self.from_json_data(data)
      {
        "column_text2" => COLUMN_TEXT2,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleColumnText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class OracleColumnText2
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleColumnText2.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleColumnText2OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleColumnText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleColumnText2RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleColumnText3OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT3 = new("column_text3")

    def self.from_json_data(data)
      {
        "column_text3" => COLUMN_TEXT3,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleColumnText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class OracleColumnText3
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleColumnText3.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleColumnText3OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleColumnText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleColumnText3RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Special roll instructions to use when rolling multiple times on a single
  # oracle.
  class OracleDuplicateBehavior
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Duplicates results should be kept.
    KEEP = new("keep")

    # Duplicate results should be kept, and they compound to make things worse.
    MAKE_IT_WORSE = new("make_it_worse")

    # Duplicate results should be re-rolled.
    REROLL = new("reroll")

    def self.from_json_data(data)
      {
        "keep" => KEEP,
        "make_it_worse" => MAKE_IT_WORSE,
        "reroll" => REROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleMatchBehavior
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleMatchBehavior.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleRoll
    # Both Ironsworn and Starforged explicitly recommend *against* rolling
    # all details at once. That said, some oracle results only provide useful
    # information once a secondary roll occurs, such as "Action + Theme" or
    # "Roll twice".
    attr_accessor :auto
    attr_accessor :dice

    # Special rules on how to handle duplicate results, when rolling multiple
    # times.
    attr_accessor :duplicates

    # The number of times to roll.
    attr_accessor :number_of_rolls
    attr_accessor :oracle

    def self.from_json_data(data)
      out = OracleRoll.new
      out.auto = Datasworn::from_json_data(TrueClass, data["auto"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.duplicates = Datasworn::from_json_data(OracleDuplicateBehavior, data["duplicates"])
      out.number_of_rolls = Datasworn::from_json_data(Integer, data["number_of_rolls"])
      out.oracle = Datasworn::from_json_data(OracleRollableID, data["oracle"])
      out
    end

    def to_json_data
      data = {}
      data["auto"] = Datasworn::to_json_data(auto)
      data["dice"] = Datasworn::to_json_data(dice)
      data["duplicates"] = Datasworn::to_json_data(duplicates)
      data["number_of_rolls"] = Datasworn::to_json_data(number_of_rolls)
      data["oracle"] = Datasworn::to_json_data(oracle)
      data
    end
  end

  # Provides string templates that may be used in place of the static row
  # text from `OracleRollableRow#text`, `OracleRollableRow#text2`, and
  # `OracleRollableRow#text3`.
  # 
  #   These strings are formatted in Markdown, but use a special syntax
  # for their placeholders: `{{text>some_oracle_rollable_id}}`. The
  # placeholder should be replaced with the value of a rolled (or selected)
  # `OracleRollableRow#text` from the target oracle rollable ID.
  class OracleRollTemplate
    # A string template that may be used in place of OracleRollableRow#text.
    attr_accessor :text

    # A string template that may be used in place of OracleRollableRow#text2.
    attr_accessor :text2

    # A string template that may be used in place of OracleRollableRow#text3.
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleRollTemplate.new
      out.text = Datasworn::from_json_data(MarkdownTemplateString, data["text"])
      out.text2 = Datasworn::from_json_data(MarkdownTemplateString, data["text2"])
      out.text3 = Datasworn::from_json_data(MarkdownTemplateString, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data["text2"] = Datasworn::to_json_data(text2) unless text2.nil?
      data["text3"] = Datasworn::to_json_data(text3) unless text3.nil?
      data
    end
  end

  # A collection of table rows from which random results may be rolled. This may
  # represent a standalone table, or a column in a larger table.
  class OracleRollable
    attr_accessor :oracle_type

    def self.from_json_data(data)
      {
        "column_text" => OracleRollableColumnText,
        "column_text2" => OracleRollableColumnText2,
        "column_text3" => OracleRollableColumnText3,
        "table_text" => OracleRollableTableText,
        "table_text2" => OracleRollableTableText2,
        "table_text3" => OracleRollableTableText3,
      }[data["oracle_type"]].from_json_data(data)
    end
  end

  class OracleRollableColumnTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableColumnTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableColumnTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # Represents a single column in an OracleCollection.
  class OracleRollableColumnText < OracleRollable
    attr_accessor :id
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableColumnText.new
      out.oracle_type = "column_text"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableColumnTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableColumnTextRecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "column_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableColumnText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableColumnText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableColumnText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class OracleRollableColumnText2 < OracleRollable
    attr_accessor :id
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableColumnText2.new
      out.oracle_type = "column_text2"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableColumnText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableColumnText2RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "column_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableColumnText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableColumnText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableColumnText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  class OracleRollableColumnText3 < OracleRollable
    attr_accessor :id
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableColumnText3.new
      out.oracle_type = "column_text3"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableColumnText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableColumnText3RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "column_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableTableTextColumnLabels
    attr_accessor :roll
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleRollableTableTextColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleRollableTableTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableTableTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableTableTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # Represents a basic rollable oracle table with one roll column and one text
  # result column.
  class OracleRollableTableText < OracleRollable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableTableText.new
      out.oracle_type = "table_text"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleRollableTableTextColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableTableTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableTableTextRecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableTableText2ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleRollableTableText2ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleRollableTableText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableTableText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableTableText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and two text columns.
  class OracleRollableTableText2 < OracleRollable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableTableText2.new
      out.oracle_type = "table_text2"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleRollableTableText2ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableTableText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableTableText2RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableTableText3ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleRollableTableText3ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class OracleRollableTableText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableTableText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableTableText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and 3 text columns.
  class OracleRollableTableText3 < OracleRollable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableTableText3.new
      out.oracle_type = "table_text3"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleRollableTableText3ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableTableText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableTableText3RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing an OracleRollable object.
  class OracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded OracleRollableId that can be used to match multiple
  # OracleRollable objects.
  class OracleRollableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleRollableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing an OracleRollableRow object.
  class OracleRollableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleRollableRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded OracleRollableRowId that can be used to match multiple
  # OracleRollableRow objects.
  class OracleRollableRowIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleRollableRowIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Represents a row in an oracle table, with a single text cell.
  class OracleRollableRowText
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleRollableRowText.new
      out.id = Datasworn::from_json_data(AnyOracleRollableRowID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Represents a row in an oracle table that provides a secondary text field.
  class OracleRollableRowText2
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleRollableRowText2.new
      out.id = Datasworn::from_json_data(AnyOracleRollableRowID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.text2 = Datasworn::from_json_data(MarkdownString, data["text2"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Represents a row in an oracle table with 3 text cells.
  class OracleRollableRowText3
    attr_accessor :id
    attr_accessor :roll

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleRollableRowText3.new
      out.id = Datasworn::from_json_data(AnyOracleRollableRowID, data["_id"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.text2 = Datasworn::from_json_data(MarkdownString, data["text2"])
      out.text3 = Datasworn::from_json_data(MarkdownString, data["text3"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  class OracleRollableTable
    attr_accessor :oracle_type

    def self.from_json_data(data)
      {
        "table_text" => OracleRollableTableTableText,
        "table_text2" => OracleRollableTableTableText2,
        "table_text3" => OracleRollableTableTableText3,
      }[data["oracle_type"]].from_json_data(data)
    end
  end

  class OracleRollableTableTableTextColumnLabels
    attr_accessor :roll
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleRollableTableTableTextColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleRollableTableTableTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableTableTableTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableTableTableTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # Represents a basic rollable oracle table with one roll column and one text
  # result column.
  class OracleRollableTableTableText < OracleRollableTable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableTableTableText.new
      out.oracle_type = "table_text"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleRollableTableTableTextColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableTableTableTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableTableTableTextRecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableTableTableText2ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleRollableTableTableText2ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleRollableTableTableText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableTableTableText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableTableTableText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and two text columns.
  class OracleRollableTableTableText2 < OracleRollableTable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableTableTableText2.new
      out.oracle_type = "table_text2"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleRollableTableTableText2ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableTableTableText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableTableTableText2RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleRollableTableTableText3ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleRollableTableTableText3ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class OracleRollableTableTableText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollableTableTableText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleRollableTableTableText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and 3 text columns.
  class OracleRollableTableTableText3 < OracleRollableTable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleRollableTableTableText3.new
      out.oracle_type = "table_text3"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleRollableTableTableText3ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleRollableTableTableText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleRollableTableTableText3RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Provides column labels for this table. The `roll` key refers to the roll
  # column showing the dice range (`min` and `max` on each table row). For all
  # other column labels, see the `name` property of each child `OracleColumn`.
  class OracleTableSharedRollsColumnLabels
    attr_accessor :roll

    def self.from_json_data(data)
      out = OracleTableSharedRollsColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data
    end
  end

  class OracleTableSharedRollsOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_SHARED_ROLLS = new("table_shared_rolls")

    def self.from_json_data(data)
      {
        "table_shared_rolls" => TABLE_SHARED_ROLLS,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableSharedRollsType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with one roll column and
  # multiple text columns.
  class OracleTableSharedRolls
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # Provides column labels for this table. The `roll` key refers to the roll
    # column showing the dice range (`min` and `max` on each table row). For all
    # other column labels, see the `name` property of each child `OracleColumn`.
    attr_accessor :column_labels
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableSharedRolls.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableSharedRollsColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableSharedRollsOracleType, data["oracle_type"])
      out.type = Datasworn::from_json_data(OracleTableSharedRollsType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTableSharedTextColumnLabels
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleTableSharedTextColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleTableSharedTextOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_SHARED_TEXT = new("table_shared_text")

    def self.from_json_data(data)
      {
        "table_shared_text" => TABLE_SHARED_TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableSharedTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns
  # and one text column.
  class OracleTableSharedText
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableSharedText.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableSharedTextColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableSharedTextOracleType, data["oracle_type"])
      out.type = Datasworn::from_json_data(OracleTableSharedTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTableSharedText2ColumnLabels
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleTableSharedText2ColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleTableSharedText2OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_SHARED_TEXT2 = new("table_shared_text2")

    def self.from_json_data(data)
      {
        "table_shared_text2" => TABLE_SHARED_TEXT2,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableSharedText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns,
  # and 2 shared text columns.
  class OracleTableSharedText2
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableSharedText2.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableSharedText2ColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText2], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableSharedText2OracleType, data["oracle_type"])
      out.type = Datasworn::from_json_data(OracleTableSharedText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTableSharedText3ColumnLabels
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleTableSharedText3ColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class OracleTableSharedText3OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_SHARED_TEXT3 = new("table_shared_text3")

    def self.from_json_data(data)
      {
        "table_shared_text3" => TABLE_SHARED_TEXT3,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableSharedText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns,
  # and 3 shared text columns.
  class OracleTableSharedText3
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableSharedText3.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableSharedText3ColumnLabels, data["column_labels"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText3], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableSharedText3OracleType, data["oracle_type"])
      out.type = Datasworn::from_json_data(OracleTableSharedText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTableTextColumnLabels
    attr_accessor :roll
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleTableTextColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleTableTextOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_TEXT = new("table_text")

    def self.from_json_data(data)
      {
        "table_text" => TABLE_TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleTableTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # Represents a basic rollable oracle table with one roll column and one text
  # result column.
  class OracleTableText
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :column_labels

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableText.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableTextColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableTextOracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleTableTextType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleTableTextRecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTableText2ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleTableText2ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleTableText2OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_TEXT2 = new("table_text2")

    def self.from_json_data(data)
      {
        "table_text2" => TABLE_TEXT2,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleTableText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and two text columns.
  class OracleTableText2
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :column_labels

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableText2.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableText2ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableText2OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleTableText2Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleTableText2RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTableText3ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleTableText3ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class OracleTableText3OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLE_TEXT3 = new("table_text3")

    def self.from_json_data(data)
      {
        "table_text3" => TABLE_TEXT3,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleTableText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and 3 text columns.
  class OracleTableText3
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :column_labels

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match
    attr_accessor :recommended_rolls

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableText3.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableText3ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTableText3OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleRollableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleTableText3Type, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleTableText3RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(Array[OracleRollableIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleTablesCollectionOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLES = new("tables")

    def self.from_json_data(data)
      {
        "tables" => TABLES,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTablesCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection that represents a category or grouping of tables, which
  # may themselves be `OracleTablesCollection`s.
  class OracleTablesCollection
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :collections
    attr_accessor :contents

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :oracle_type
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This node's content enhances all nodes that match these wildcards, rather
    # than being a standalone item of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTablesCollection.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.collections = Datasworn::from_json_data(Hash[String, OracleCollection], data["collections"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleRollableTable], data["contents"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTablesCollectionOracleType, data["oracle_type"])
      out.type = Datasworn::from_json_data(OracleTablesCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[OracleCollectionIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["collections"] = Datasworn::to_json_data(collections)
      data["contents"] = Datasworn::to_json_data(contents)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Represents a page number in a book.
  class PageNumber
    attr_accessor :value

    def self.from_json_data(data)
      out = PageNumber.new
      out.value = Datasworn.from_json_data(Integer, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class PartOfSpeech
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # An adjective.
    ADJECTIVE = new("adjective")

    # An adjective used as a proper noun.
    ADJECTIVE_AS_PROPER_NOUN = new("adjective_as_proper_noun")

    # A common noun used as an adjective, to modify another noun.
    ADJUNCT_COMMON_NOUN = new("adjunct_common_noun")

    # A proper noun used as an adjective, to modify another noun.
    ADJUNCT_PROPER_NOUN = new("adjunct_proper_noun")

    # A verb used as an adjective, to modify a noun.
    ATTRIBUTIVE_VERB = new("attributive_verb")

    # A common noun.
    COMMON_NOUN = new("common_noun")

    # An common noun used as a proper noun.
    COMMON_NOUN_AS_PROPER_NOUN = new("common_noun_as_proper_noun")

    # Gerund or present participle of a verb, e.g. "going", "seeing", "waving".
    # Can function as a noun, an adjective, or a progressive verb.
    GERUND = new("gerund")

    # A proper noun.
    PROPER_NOUN = new("proper_noun")

    # A verb in present tense
    VERB = new("verb")

    def self.from_json_data(data)
      {
        "adjective" => ADJECTIVE,
        "adjective_as_proper_noun" => ADJECTIVE_AS_PROPER_NOUN,
        "adjunct_common_noun" => ADJUNCT_COMMON_NOUN,
        "adjunct_proper_noun" => ADJUNCT_PROPER_NOUN,
        "attributive_verb" => ATTRIBUTIVE_VERB,
        "common_noun" => COMMON_NOUN,
        "common_noun_as_proper_noun" => COMMON_NOUN_AS_PROPER_NOUN,
        "gerund" => GERUND,
        "proper_noun" => PROPER_NOUN,
        "verb" => VERB,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # An automatic miss.
    MISS = new("miss")

    # Make a progress roll on a progress track associated with this move.
    PROGRESS_ROLL = new("progress_roll")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "miss" => MISS,
        "progress_roll" => PROGRESS_ROLL,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollOptionUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    PROGRESS_TRACK = new("progress_track")

    def self.from_json_data(data)
      {
        "progress_track" => PROGRESS_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollOption
    attr_accessor :using

    def self.from_json_data(data)
      out = ProgressRollOption.new
      out.using = Datasworn::from_json_data(ProgressRollOptionUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes the features of a type of progress track.
  class ProgressTrackTypeInfo
    # A category label for progress tracks of this type.
    attr_accessor :category
    attr_accessor :controls

    def self.from_json_data(data)
      out = ProgressTrackTypeInfo.new
      out.category = Datasworn::from_json_data(Label, data["category"])
      out.controls = Datasworn::from_json_data(Hash[String, Object], data["controls"])
      out
    end

    def to_json_data
      data = {}
      data["category"] = Datasworn::to_json_data(category)
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data
    end
  end

  class RarityType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    RARITY = new("rarity")

    def self.from_json_data(data)
      {
        "rarity" => RARITY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A rarity, as described in Ironsworn: Delve.
  class Rarity
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source

    # The asset augmented by this rarity.
    attr_accessor :asset

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :type

    # From Ironsworn: Delve, p. 174:
    # 
    #       Some assets will bring a rarity into play more often than others,
    # so the experience point cost for a rarity will vary by the linked asset.
    # These costs are shown in the tables on page 175.
    # 
    #       If you are playing solo, and aren’t concerned with the relative
    # balance of rarity abilities, you can ignore these variable costs. If so,
    # spend 3 experience points to purchase a rarity.
    attr_accessor :xp_cost
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = Rarity.new
      out.id = Datasworn::from_json_data(RarityID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.asset = Datasworn::from_json_data(AssetID, data["asset"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(RarityType, data["type"])
      out.xp_cost = Datasworn::from_json_data(Integer, data["xp_cost"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[RarityIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["asset"] = Datasworn::to_json_data(asset)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["xp_cost"] = Datasworn::to_json_data(xp_cost)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID representing a Rarity object.
  class RarityID
    attr_accessor :value

    def self.from_json_data(data)
      out = RarityID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded RarityId that can be used to match multiple Rarity objects.
  class RarityIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = RarityIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Provides a value like a stat, condition meter, or other number (usually for
  # use in an action roll). The expected value is an integer, or null.
  class RollableValue
    attr_accessor :using

    def self.from_json_data(data)
      {
        "asset_control" => RollableValueAssetControl,
        "asset_option" => RollableValueAssetOption,
        "attached_asset_control" => RollableValueAttachedAssetControl,
        "attached_asset_option" => RollableValueAttachedAssetOption,
        "condition_meter" => RollableValueConditionMeter,
        "custom" => RollableValueCustom,
        "stat" => RollableValueStat,
      }[data["using"]].from_json_data(data)
    end
  end

  # A reference to the value of an asset control.
  class RollableValueAssetControl < RollableValue
    attr_accessor :assets
    attr_accessor :control

    def self.from_json_data(data)
      out = RollableValueAssetControl.new
      out.using = "asset_control"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out
    end

    def to_json_data
      data = { "using" => "asset_control" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["control"] = Datasworn::to_json_data(control)
      data
    end
  end

  # A reference to the value of an asset option.
  class RollableValueAssetOption < RollableValue
    attr_accessor :assets
    attr_accessor :option

    def self.from_json_data(data)
      out = RollableValueAssetOption.new
      out.using = "asset_option"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "asset_option" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  # A reference to the value of an attached asset control. For example, a Module
  # asset could use this to roll using the `integrity` control of an attached
  # Vehicle.
  class RollableValueAttachedAssetControl < RollableValue
    attr_accessor :control

    def self.from_json_data(data)
      out = RollableValueAttachedAssetControl.new
      out.using = "attached_asset_control"
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_control" }
      data["control"] = Datasworn::to_json_data(control)
      data
    end
  end

  # A reference to the value of an attached asset option.
  class RollableValueAttachedAssetOption < RollableValue
    attr_accessor :option

    def self.from_json_data(data)
      out = RollableValueAttachedAssetOption.new
      out.using = "attached_asset_option"
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_option" }
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  # A reference to the value of a standard player condition meter.
  class RollableValueConditionMeter < RollableValue
    attr_accessor :condition_meter

    def self.from_json_data(data)
      out = RollableValueConditionMeter.new
      out.using = "condition_meter"
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out
    end

    def to_json_data
      data = { "using" => "condition_meter" }
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data
    end
  end

  # An arbitrary static integer value with a label.
  class RollableValueCustom < RollableValue
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = RollableValueCustom.new
      out.using = "custom"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  # A reference to the value of a standard player character stat.
  class RollableValueStat < RollableValue
    attr_accessor :stat

    def self.from_json_data(data)
      out = RollableValueStat.new
      out.using = "stat"
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out
    end

    def to_json_data
      data = { "using" => "stat" }
      data["stat"] = Datasworn::to_json_data(stat)
      data
    end
  end

  # Describes rules for player characters in this ruleset, such as stats and
  # condition meters.
  class Rules
    # Describes the standard condition meters used by player characters in this
    # ruleset.
    attr_accessor :condition_meters

    # Describes the standard impacts/debilities used by player characters in
    # this ruleset.
    attr_accessor :impacts

    # Describes the special tracks used by player characters in this ruleset,
    # like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    attr_accessor :special_tracks

    # Describes the standard stats used by player characters in this ruleset.
    attr_accessor :stats
    attr_accessor :tags

    def self.from_json_data(data)
      out = Rules.new
      out.condition_meters = Datasworn::from_json_data(Hash[String, ConditionMeterRule], data["condition_meters"])
      out.impacts = Datasworn::from_json_data(Hash[String, ImpactCategory], data["impacts"])
      out.special_tracks = Datasworn::from_json_data(Hash[String, SpecialTrackRule], data["special_tracks"])
      out.stats = Datasworn::from_json_data(Hash[String, StatRule], data["stats"])
      out.tags = Datasworn::from_json_data(Hash[String, TagRule], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meters"] = Datasworn::to_json_data(condition_meters)
      data["impacts"] = Datasworn::to_json_data(impacts)
      data["special_tracks"] = Datasworn::to_json_data(special_tracks)
      data["stats"] = Datasworn::to_json_data(stats)
      data["tags"] = Datasworn::to_json_data(tags)
      data
    end
  end

  # Describes rules for player characters in this ruleset, such as stats and
  # condition meters.
  class RulesExpansion
    # Describes the standard condition meters used by player characters in this
    # ruleset.
    attr_accessor :condition_meters

    # Describes the standard impacts/debilities used by player characters in
    # this ruleset.
    attr_accessor :impacts

    # Describes the special tracks used by player characters in this ruleset,
    # like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    attr_accessor :special_tracks

    # Describes the standard stats used by player characters in this ruleset.
    attr_accessor :stats
    attr_accessor :tags

    def self.from_json_data(data)
      out = RulesExpansion.new
      out.condition_meters = Datasworn::from_json_data(Hash[String, ConditionMeterRule], data["condition_meters"])
      out.impacts = Datasworn::from_json_data(Hash[String, ImpactCategory], data["impacts"])
      out.special_tracks = Datasworn::from_json_data(Hash[String, SpecialTrackRule], data["special_tracks"])
      out.stats = Datasworn::from_json_data(Hash[String, StatRule], data["stats"])
      out.tags = Datasworn::from_json_data(Hash[String, TagRule], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meters"] = Datasworn::to_json_data(condition_meters) unless condition_meters.nil?
      data["impacts"] = Datasworn::to_json_data(impacts) unless impacts.nil?
      data["special_tracks"] = Datasworn::to_json_data(special_tracks) unless special_tracks.nil?
      data["stats"] = Datasworn::to_json_data(stats) unless stats.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class RulesPackageID
    attr_accessor :value

    def self.from_json_data(data)
      out = RulesPackageID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # The version of the Datasworn format used by this data.
  class RulesetDataswornVersion
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DEFAULT_NAME = new("0.1.0")

    def self.from_json_data(data)
      {
        "0.1.0" => DEFAULT_NAME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class RulesetType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    RULESET = new("ruleset")

    def self.from_json_data(data)
      {
        "ruleset" => RULESET,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standalone Datasworn package that describes its own ruleset.
  class Ruleset
    attr_accessor :id

    # A dictionary object containing asset collections, which contain assets.
    attr_accessor :assets

    # Lists authors credited by the source material.
    attr_accessor :authors

    # The version of the Datasworn format used by this data.
    attr_accessor :datasworn_version

    # The date of the source documents's last update, formatted YYYY-MM-DD.
    # Required because it's used to determine whether the data needs updating.
    attr_accessor :date
    attr_accessor :license

    # A dictionary object containing move categories, which contain moves.
    attr_accessor :moves

    # A dictionary object containing oracle collections, which may contain
    # oracle tables and/or oracle collections.
    attr_accessor :oracles
    attr_accessor :rules

    # The title of the source document.
    attr_accessor :title
    attr_accessor :type

    # A URL where the source document is available.
    attr_accessor :url

    # A dictionary object containing atlas collections, which contain atlas
    # entries.
    attr_accessor :atlas

    # A dictionary object of delve sites, like the premade delve sites presented
    # in Ironsworn: Delve
    attr_accessor :delve_sites
    attr_accessor :description

    # A dictionary object containing NPC collections, which contain NPCs.
    attr_accessor :npcs

    # A dictionary object containing rarities, like those presented in
    # Ironsworn: Delve.
    attr_accessor :rarities

    # A dictionary object containing delve site domains.
    attr_accessor :site_domains

    # A dictionary object containing delve site themes.
    attr_accessor :site_themes

    # A dictionary object of truth categories.
    attr_accessor :truths

    def self.from_json_data(data)
      out = Ruleset.new
      out.id = Datasworn::from_json_data(RulesetID, data["_id"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetCollection], data["assets"])
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.datasworn_version = Datasworn::from_json_data(RulesetDataswornVersion, data["datasworn_version"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(WebURL, data["license"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleTablesCollection], data["oracles"])
      out.rules = Datasworn::from_json_data(Rules, data["rules"])
      out.title = Datasworn::from_json_data(Label, data["title"])
      out.type = Datasworn::from_json_data(RulesetType, data["type"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.atlas = Datasworn::from_json_data(Hash[String, AtlasCollection], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["assets"] = Datasworn::to_json_data(assets)
      data["authors"] = Datasworn::to_json_data(authors)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["moves"] = Datasworn::to_json_data(moves)
      data["oracles"] = Datasworn::to_json_data(oracles)
      data["rules"] = Datasworn::to_json_data(rules)
      data["title"] = Datasworn::to_json_data(title)
      data["type"] = Datasworn::to_json_data(type)
      data["url"] = Datasworn::to_json_data(url)
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  # The ID of standalone Datasworn package that describes its own ruleset.
  class RulesetID
    attr_accessor :value

    def self.from_json_data(data)
      out = RulesetID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A JSON schema representing a single value (or reference) that's possible
  # to represent
  class SafeValueSchema
    attr_accessor :value

    def self.from_json_data(data)
      out = SafeValueSchema.new
      out.value = Datasworn.from_json_data(Object, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class SelectEnhancementFieldChoice0
    attr_accessor :choice_type

    def self.from_json_data(data)
      {
        "choice" => SelectEnhancementFieldChoiceChoice,
        "choice_group" => SelectEnhancementFieldChoiceChoiceGroup,
      }[data["choice_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class SelectEnhancementFieldChoiceChoice < SelectEnhancementFieldChoice0
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = SelectEnhancementFieldChoiceChoice.new
      out.choice_type = "choice"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class SelectEnhancementFieldChoiceChoiceGroup < SelectEnhancementFieldChoice0
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = SelectEnhancementFieldChoiceChoiceGroup.new
      out.choice_type = "choice_group"
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice], data["choices"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  class SelectEnhancementFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    SELECT_ENHANCEMENT = new("select_enhancement")

    def self.from_json_data(data)
      {
        "select_enhancement" => SELECT_ENHANCEMENT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class SelectEnhancementField
    attr_accessor :choices
    attr_accessor :field_type
    attr_accessor :label
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = SelectEnhancementField.new
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice0], data["choices"])
      out.field_type = Datasworn::from_json_data(SelectEnhancementFieldFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["choices"] = Datasworn::to_json_data(choices)
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class SelectEnhancementFieldChoiceChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectEnhancementFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = SelectEnhancementFieldChoice.new
      out.choice_type = Datasworn::from_json_data(SelectEnhancementFieldChoiceChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = {}
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  class SelectEnhancementFieldChoiceGroupChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE_GROUP = new("choice_group")

    def self.from_json_data(data)
      {
        "choice_group" => CHOICE_GROUP,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents a grouping of options in a list of choices.
  class SelectEnhancementFieldChoiceGroup
    attr_accessor :choice_type
    attr_accessor :choices

    # A label for this option group.
    attr_accessor :name

    def self.from_json_data(data)
      out = SelectEnhancementFieldChoiceGroup.new
      out.choice_type = Datasworn::from_json_data(SelectEnhancementFieldChoiceGroupChoiceType, data["choice_type"])
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice], data["choices"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = {}
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  class SelectValueFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    SELECT_VALUE = new("select_value")

    def self.from_json_data(data)
      {
        "select_value" => SELECT_VALUE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents a list of mutually exclusive choices.
  class SelectValueField
    attr_accessor :choices
    attr_accessor :field_type
    attr_accessor :label
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = SelectValueField.new
      out.choices = Datasworn::from_json_data(Hash[String, SelectValueFieldChoice], data["choices"])
      out.field_type = Datasworn::from_json_data(SelectValueFieldFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["choices"] = Datasworn::to_json_data(choices)
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class SelectValueFieldChoice
    attr_accessor :using

    def self.from_json_data(data)
      {
        "asset_control" => SelectValueFieldChoiceAssetControl,
        "asset_option" => SelectValueFieldChoiceAssetOption,
        "attached_asset_control" => SelectValueFieldChoiceAttachedAssetControl,
        "attached_asset_option" => SelectValueFieldChoiceAttachedAssetOption,
        "condition_meter" => SelectValueFieldChoiceConditionMeter,
        "custom" => SelectValueFieldChoiceCustom,
        "stat" => SelectValueFieldChoiceStat,
      }[data["using"]].from_json_data(data)
    end
  end

  class SelectValueFieldChoiceAssetControlChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAssetControl < SelectValueFieldChoice
    attr_accessor :assets
    attr_accessor :choice_type
    attr_accessor :control
    attr_accessor :label

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAssetControl.new
      out.using = "asset_control"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAssetControlChoiceType, data["choice_type"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = { "using" => "asset_control" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["control"] = Datasworn::to_json_data(control)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class SelectValueFieldChoiceAssetOptionChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAssetOption < SelectValueFieldChoice
    attr_accessor :assets
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :option

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAssetOption.new
      out.using = "asset_option"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAssetOptionChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "asset_option" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  class SelectValueFieldChoiceAttachedAssetControlChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAttachedAssetControl < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :control
    attr_accessor :label

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAttachedAssetControl.new
      out.using = "attached_asset_control"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAttachedAssetControlChoiceType, data["choice_type"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_control" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["control"] = Datasworn::to_json_data(control)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class SelectValueFieldChoiceAttachedAssetOptionChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAttachedAssetOption < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :option

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAttachedAssetOption.new
      out.using = "attached_asset_option"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAttachedAssetOptionChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_option" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  class SelectValueFieldChoiceConditionMeterChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceConditionMeter < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :condition_meter
    attr_accessor :label

    def self.from_json_data(data)
      out = SelectValueFieldChoiceConditionMeter.new
      out.using = "condition_meter"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceConditionMeterChoiceType, data["choice_type"])
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = { "using" => "condition_meter" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class SelectValueFieldChoiceCustomChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceCustom < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = SelectValueFieldChoiceCustom.new
      out.using = "custom"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceCustomChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  class SelectValueFieldChoiceStatChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceStat < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :stat

    def self.from_json_data(data)
      out = SelectValueFieldChoiceStat.new
      out.using = "stat"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceStatChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out
    end

    def to_json_data
      data = { "using" => "stat" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["stat"] = Datasworn::to_json_data(stat)
      data
    end
  end

  class SemanticVersion
    attr_accessor :value

    def self.from_json_data(data)
      out = SemanticVersion.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Metadata describing the original source of this node
  class SourceInfo
    # Lists authors credited by the source material.
    attr_accessor :authors

    # The date of the source documents's last update, formatted YYYY-MM-DD.
    # Required because it's used to determine whether the data needs updating.
    attr_accessor :date
    attr_accessor :license

    # The title of the source document.
    attr_accessor :title

    # A URL where the source document is available.
    attr_accessor :url

    # The page number where this content is described in full.
    attr_accessor :page

    def self.from_json_data(data)
      out = SourceInfo.new
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(WebURL, data["license"])
      out.title = Datasworn::from_json_data(Label, data["title"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.page = Datasworn::from_json_data(PageNumber, data["page"])
      out
    end

    def to_json_data
      data = {}
      data["authors"] = Datasworn::to_json_data(authors)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["title"] = Datasworn::to_json_data(title)
      data["url"] = Datasworn::to_json_data(url)
      data["page"] = Datasworn::to_json_data(page) unless page.nil?
      data
    end
  end

  class SpecialTrackRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Use _every_ roll option at once.
    ALL = new("all")

    # Use the roll option with the best/highest value.
    HIGHEST = new("highest")

    # Use the roll option with the worst/lowest value.
    LOWEST = new("lowest")

    # An automatic miss.
    MISS = new("miss")

    # The player chooses which roll option to use.
    PLAYER_CHOICE = new("player_choice")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "player_choice" => PLAYER_CHOICE,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
  # or Legacies (Starforged).
  class SpecialTrackRule
    # A description of this special track.
    attr_accessor :description

    # A label for this special track.
    attr_accessor :label

    # Is this track an optional rule?
    attr_accessor :optional

    # Is this track shared by all players?
    attr_accessor :shared

    def self.from_json_data(data)
      out = SpecialTrackRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.optional = Datasworn::from_json_data(TrueClass, data["optional"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["optional"] = Datasworn::to_json_data(optional)
      data["shared"] = Datasworn::to_json_data(shared)
      data
    end
  end

  # Special, ruleset-specific progress tracks. Usually, one exists per player
  # character, and they persist through the life of the player character.
  # 'Canonical' examples:
  #   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
  # legacy track, use `bonds_legacy` instead.
  #   * `failure_track`, described in Ironsworn: Delve
  #   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
  # Ironsworn: Starforged
  # 
  class SpecialTrackType
    attr_accessor :value

    def self.from_json_data(data)
      out = SpecialTrackType.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A basic player character stat.
  class StatKey
    attr_accessor :value

    def self.from_json_data(data)
      out = StatKey.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes a standard player character stat.
  class StatRule
    # A description of this stat.
    attr_accessor :description

    # A label for this stat.
    attr_accessor :label

    def self.from_json_data(data)
      out = StatRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  # A reference to the value of a standard player character stat.
  class StatValueRefUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    STAT = new("stat")

    def self.from_json_data(data)
      {
        "stat" => STAT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A reference to the value of a standard player character stat.
  class StatValueRef
    attr_accessor :stat

    # A reference to the value of a standard player character stat.
    attr_accessor :using

    def self.from_json_data(data)
      out = StatValueRef.new
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out.using = Datasworn::from_json_data(StatValueRefUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["stat"] = Datasworn::to_json_data(stat)
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  class Suggestions
    attr_accessor :value

    def self.from_json_data(data)
      out = Suggestions.new
      out.value = Datasworn.from_json_data(Array[AnyIDWildcard], data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A relative (local) URL pointing to a vector image in the SVG format.
  class SvgImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = SvgImageURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Tag
    attr_accessor :value

    def self.from_json_data(data)
      out = Tag.new
      out.value = Datasworn.from_json_data(Object, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TagRule
    attr_accessor :schema
    attr_accessor :applies_to

    def self.from_json_data(data)
      out = TagRule.new
      out.schema = Datasworn::from_json_data(TagSchema, data["$schema"])
      out.applies_to = Datasworn::from_json_data(Array[TaggableNodeType], data["applies_to"])
      out
    end

    def to_json_data
      data = {}
      data["$schema"] = Datasworn::to_json_data(schema)
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data
    end
  end

  # A JSON schema used to validate the tag data, with a mandatory description.
  class TagSchema
    attr_accessor :value

    def self.from_json_data(data)
      out = TagSchema.new
      out.value = Datasworn.from_json_data(Object, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TaggableNodeType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ABILITY = new("ability")
    ASSET = new("asset")
    ASSET_COLLECTION = new("asset_collection")
    ATLAS_COLLECTION = new("atlas_collection")
    ATLAS_ENTRY = new("atlas_entry")
    DANGER = new("danger")
    DELVE_SITE = new("delve_site")
    DELVE_SITE_DOMAIN = new("delve_site_domain")
    DELVE_SITE_THEME = new("delve_site_theme")
    DENIZEN = new("denizen")
    FEATURE = new("feature")
    MOVE = new("move")
    MOVE_CATEGORY = new("move_category")
    NPC = new("npc")
    NPC_COLLECTION = new("npc_collection")
    OPTION = new("option")
    ORACLE_COLLECTION = new("oracle_collection")
    ORACLE_ROLLABLE = new("oracle_rollable")
    RARITY = new("rarity")
    ROW = new("row")
    TRUTH = new("truth")
    VARIANT = new("variant")

    def self.from_json_data(data)
      {
        "ability" => ABILITY,
        "asset" => ASSET,
        "asset_collection" => ASSET_COLLECTION,
        "atlas_collection" => ATLAS_COLLECTION,
        "atlas_entry" => ATLAS_ENTRY,
        "danger" => DANGER,
        "delve_site" => DELVE_SITE,
        "delve_site_domain" => DELVE_SITE_DOMAIN,
        "delve_site_theme" => DELVE_SITE_THEME,
        "denizen" => DENIZEN,
        "feature" => FEATURE,
        "move" => MOVE,
        "move_category" => MOVE_CATEGORY,
        "npc" => NPC,
        "npc_collection" => NPC_COLLECTION,
        "option" => OPTION,
        "oracle_collection" => ORACLE_COLLECTION,
        "oracle_rollable" => ORACLE_ROLLABLE,
        "rarity" => RARITY,
        "row" => ROW,
        "truth" => TRUTH,
        "variant" => VARIANT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A dictionary of tags, keyed by the RulesPackageId that the tags are from.
  class Tags
    attr_accessor :value

    def self.from_json_data(data)
      out = Tags.new
      out.value = Datasworn.from_json_data(Hash[String, Hash[String, Tag]], data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TextFieldFieldType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TEXT = new("text")

    def self.from_json_data(data)
      {
        "text" => TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an input that accepts plain text.
  class TextField
    attr_accessor :field_type
    attr_accessor :label
    attr_accessor :value

    # An icon associated with this input.
    attr_accessor :icon

    def self.from_json_data(data)
      out = TextField.new
      out.field_type = Datasworn::from_json_data(TextFieldFieldType, data["field_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = {}
      data["field_type"] = Datasworn::to_json_data(field_type)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Describes trigger conditions for a move that makes an action roll.
  class TriggerActionRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerActionRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerActionRollCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRollCondition.new
      out.method = Datasworn::from_json_data(ActionRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[RollableValue], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerActionRollConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRollConditionEnhancement.new
      out.method = Datasworn::from_json_data(ActionRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[RollableValue], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerActionRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerActionRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerActionRollConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  # Information on who can activate this trigger condition. Usually this is just
  # the player, but some asset abilities can trigger from an ally's move.
  class TriggerBy
    # Can this trigger be activated by one of the player's allies?
    attr_accessor :ally

    # Can this trigger be activated by the player who owns this?
    attr_accessor :player

    def self.from_json_data(data)
      out = TriggerBy.new
      out.ally = Datasworn::from_json_data(TrueClass, data["ally"])
      out.player = Datasworn::from_json_data(TrueClass, data["player"])
      out
    end

    def to_json_data
      data = {}
      data["ally"] = Datasworn::to_json_data(ally)
      data["player"] = Datasworn::to_json_data(player)
      data
    end
  end

  # Describes trigger conditions for a move that makes no rolls.
  class TriggerNoRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerNoRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerNoRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerNoRollCondition
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerNoRollCondition.new
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerNoRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerNoRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerNoRollCondition], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TriggerProgressRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerProgressRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerProgressRollCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRollCondition.new
      out.method = Datasworn::from_json_data(ProgressRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[ProgressRollOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerProgressRollConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRollConditionEnhancement.new
      out.method = Datasworn::from_json_data(ProgressRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[ProgressRollOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerProgressRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerProgressRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerProgressRollConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TriggerSpecialTrack
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrack.new
      out.conditions = Datasworn::from_json_data(Array[TriggerSpecialTrackCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerSpecialTrackCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrackCondition.new
      out.method = Datasworn::from_json_data(SpecialTrackRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # A progress move that rolls on one or more special tracks, like Bonds
  # (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
  class TriggerSpecialTrackConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrackConditionEnhancement.new
      out.method = Datasworn::from_json_data(SpecialTrackRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerSpecialTrackConditionOption
    attr_accessor :using

    def self.from_json_data(data)
      out = TriggerSpecialTrackConditionOption.new
      out.using = Datasworn::from_json_data(SpecialTrackType, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerSpecialTrackEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerSpecialTrackEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TruthType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TRUTH = new("truth")

    def self.from_json_data(data)
      {
        "truth" => TRUTH,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A setting truth category.
  class Truth
    # The unique Datasworn ID for this node.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # node, including the author and licensing information.
    attr_accessor :source
    attr_accessor :dice

    # The primary name/label for this node.
    attr_accessor :name
    attr_accessor :options
    attr_accessor :type
    attr_accessor :comment

    # The name of this node as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this node.
    attr_accessor :color

    # Prompts for factions related to this truth, like those presented in
    # standard isles. This is presented as a single paragraph in the original
    # text; Datasworn uses an array (one faction prompt per string) to represent
    # them in order to make them more suitable for programmatic use.
    # 
    # This property is a placeholder and may see signficant changes in v0.2.0.
    attr_accessor :factions

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This node replaces all nodes that match these wildcards. References to the
    # replaced nodes can be considered equivalent to this node.
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags
    attr_accessor :your_character

    def self.from_json_data(data)
      out = Truth.new
      out.id = Datasworn::from_json_data(TruthID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Array[TruthOption], data["options"])
      out.type = Datasworn::from_json_data(TruthType, data["type"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.factions = Datasworn::from_json_data(Array[EntityPrompt], data["factions"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(Array[TruthIDWildcard], data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Tags, data["tags"])
      out.your_character = Datasworn::from_json_data(MarkdownString, data["your_character"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["options"] = Datasworn::to_json_data(options)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["factions"] = Datasworn::to_json_data(factions) unless factions.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["your_character"] = Datasworn::to_json_data(your_character) unless your_character.nil?
      data
    end
  end

  # A unique ID representing a Truth object.
  class TruthID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded TruthId that can be used to match multiple Truth objects.
  class TruthIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TruthOption
    # The unique Datasworn ID for this node.
    attr_accessor :id
    attr_accessor :description
    attr_accessor :quest_starter
    attr_accessor :roll
    attr_accessor :comment
    attr_accessor :oracles
    attr_accessor :summary

    def self.from_json_data(data)
      out = TruthOption.new
      out.id = Datasworn::from_json_data(TruthOptionID, data["_id"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.roll = Datasworn::from_json_data(DiceRange, data["roll"])
      out.comment = Datasworn::from_json_data(Documentation, data["_comment"])
      out.oracles = Datasworn::from_json_data(Hash[String, EmbeddedOracleRollable], data["oracles"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["description"] = Datasworn::to_json_data(description)
      data["quest_starter"] = Datasworn::to_json_data(quest_starter)
      data["roll"] = Datasworn::to_json_data(roll)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID representing a TruthOption object.
  class TruthOptionID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded TruthOptionId that can be used to match multiple TruthOption
  # objects.
  class TruthOptionIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a TruthOptionOracleRollable object.
  class TruthOptionOracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionOracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded TruthOptionOracleRollableId that can be used to match multiple
  # TruthOptionOracleRollable objects.
  class TruthOptionOracleRollableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionOracleRollableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID representing a TruthOptionOracleRollableRow object.
  class TruthOptionOracleRollableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionOracleRollableRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded TruthOptionOracleRollableRowId that can be used to match
  # multiple TruthOptionOracleRollableRow objects.
  class TruthOptionOracleRollableRowIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionOracleRollableRowIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # An absolute URL pointing to a website.
  class WebURL
    attr_accessor :value

    def self.from_json_data(data)
      out = WebURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A relative (local) URL pointing to a raster image in the WEBP format.
  class WebpImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = WebpImageURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  private

  def self.from_json_data(type, data)
    if data.nil? || [Object, TrueClass, Integer, Float, String].include?(type)
      data
    elsif type == DateTime
      DateTime.rfc3339(data)
    elsif type.is_a?(Array)
      data.map { |elem| from_json_data(type.first, elem) }
    elsif type.is_a?(Hash)
      data.transform_values { |elem| from_json_data(type.values.first, elem) }
    else
      type.from_json_data(data)
    end
  end

  def self.to_json_data(data)
    if data.nil? || [TrueClass, FalseClass, Integer, Float, String].include?(data.class)
      data
    elsif data.is_a?(DateTime)
      data.rfc3339
    elsif data.is_a?(Array)
      data.map { |elem| to_json_data(elem) }
    elsif data.is_a?(Hash)
      data.transform_values { |elem| to_json_data(elem) }
    else
      data.to_json_data
    end
  end
end

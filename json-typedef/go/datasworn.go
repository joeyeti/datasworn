// Code generated by jtd-codegen for Go v0.2.1. DO NOT EDIT.

package Datasworn

import (
	"encoding/json"
	"fmt"
	"time"
)

// Describes game rules compatible with the Ironsworn tabletop role-playing game
// by Shawn Tomkin.
type RulesPackage struct {
	Type string

	Expansion RulesPackageExpansion

	Ruleset RulesPackageRuleset
}

func (v RulesPackage) MarshalJSON() ([]byte, error) {
	switch v.Type {
	case "expansion":
		return json.Marshal(struct { T string `json:"type"`; RulesPackageExpansion }{ v.Type, v.Expansion })
	case "ruleset":
		return json.Marshal(struct { T string `json:"type"`; RulesPackageRuleset }{ v.Type, v.Ruleset })
	}

	return nil, fmt.Errorf("bad Type value: %s", v.Type)
}

func (v *RulesPackage) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "expansion":
		err = json.Unmarshal(b, &v.Expansion)
	case "ruleset":
		err = json.Unmarshal(b, &v.Ruleset)
	default:
		err = fmt.Errorf("bad Type value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Type = t.T
	return nil
}

// The version of the Datasworn format used by this data.
type RulesPackageExpansionDataswornVersion string

const (
	RulesPackageExpansionDataswornVersion0 RulesPackageExpansionDataswornVersion = "0.1.0"
)

// A Datasworn package that relies on an external package to provide its
// ruleset.
type RulesPackageExpansion struct {
	ID ExpansionID `json:"_id"`

	// A dictionary object containing asset collections, which contain assets.
	Assets map[string]AssetCollection `json:"assets"`

	// Lists authors credited by the source material.
	Authors []AuthorInfo `json:"authors"`

	// The version of the Datasworn format used by this data.
	DataswornVersion RulesPackageExpansionDataswornVersion `json:"datasworn_version"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date time.Time `json:"date"`

	License WebURL `json:"license"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleTablesCollection `json:"oracles"`

	Ruleset RulesetID `json:"ruleset"`

	// The title of the source document.
	Title Label `json:"title"`

	// A URL where the source document is available.
	URL WebURL `json:"url"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]AtlasCollection `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	Rules *RulesExpansion `json:"rules,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

// The version of the Datasworn format used by this data.
type RulesPackageRulesetDataswornVersion string

const (
	RulesPackageRulesetDataswornVersion0 RulesPackageRulesetDataswornVersion = "0.1.0"
)

// A standalone Datasworn package that describes its own ruleset.
type RulesPackageRuleset struct {
	ID RulesetID `json:"_id"`

	// A dictionary object containing asset collections, which contain assets.
	Assets map[string]AssetCollection `json:"assets"`

	// Lists authors credited by the source material.
	Authors []AuthorInfo `json:"authors"`

	// The version of the Datasworn format used by this data.
	DataswornVersion RulesPackageRulesetDataswornVersion `json:"datasworn_version"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date time.Time `json:"date"`

	License WebURL `json:"license"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleTablesCollection `json:"oracles"`

	Rules Rules `json:"rules"`

	// The title of the source document.
	Title Label `json:"title"`

	// A URL where the source document is available.
	URL WebURL `json:"url"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]AtlasCollection `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

type ActionRollMethod string

const (
// Use _every_ roll option at once.
	ActionRollMethodAll ActionRollMethod = "all"

// Use the roll option with the best/highest value.
	ActionRollMethodHighest ActionRollMethod = "highest"

// Use the roll option with the worst/lowest value.
	ActionRollMethodLowest ActionRollMethod = "lowest"

// An automatic miss.
	ActionRollMethodMiss ActionRollMethod = "miss"

// The player chooses which roll option to use.
	ActionRollMethodPlayerChoice ActionRollMethod = "player_choice"

// An automatic strong hit.
	ActionRollMethodStrongHit ActionRollMethod = "strong_hit"

// An automatic weak hit.
	ActionRollMethodWeakHit ActionRollMethod = "weak_hit"
)

// Represents any kind of non-wildcard ID, including IDs of embedded objects.
type AnyID = string

// Represents any kind of wildcard ID, including IDs of embedded objects.
type AnyIDWildcard = string

type AnyMoveID = string

type AnyMoveIDWildcard = string

type AnyOracleRollableID = string

type AnyOracleRollableIDWildcard = string

type AnyOracleRollableRowID = string

type AnyOracleRollableRowIDWildcard = string

type AssetType string

const (
	AssetTypeAsset AssetType = "asset"
)

type Asset struct {
	// The unique Datasworn ID for this node.
	ID AssetID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Abilities []AssetAbility `json:"abilities"`

	// A localized category label for this asset. This is the surtitle above the
	// asset's name on the card.
	Category Label `json:"category"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact bool `json:"count_as_impact"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// Options are input fields set when the player purchases the asset. They're
	// likely to remain the same through the life of the asset. Typically, they are
	// rendered at the top of the asset card.
	Options map[string]AssetOptionField `json:"options"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared bool `json:"shared"`

	Type AssetType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlField `json:"controls,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []AssetIDWildcard `json:"replaces,omitempty"`

	// Describes prerequisites for purchasing or using this asset.
	Requirement *MarkdownString `json:"requirement,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// An asset ability: one of the purchasable features of an asset. Most assets
// have three.
type AssetAbility struct {
	// The unique Datasworn ID for this node.
	ID AssetAbilityID `json:"_id"`

	// Is this asset ability enabled?
	Enabled bool `json:"enabled"`

	// The complete rules text of this asset ability.
	Text MarkdownString `json:"text"`

	Comment *Documentation `json:"_comment,omitempty"`

	// Fields whose values are expected to change over the life of the asset.
	Controls map[string]AssetAbilityControlField `json:"controls,omitempty"`

	// Changes made to the asset, when this ability is enabled.
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	// Describes changes made to various moves by this asset ability. Usually these
	// require specific trigger conditions.
	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`

	// Unique moves added by this asset ability.
	Moves map[string]EmbeddedMove `json:"moves,omitempty"`

	// A handful of asset abilities have a label/name, for instance classic
	// Ironsworn companion assets. Most canonical assets omit this property.
	Name *Label `json:"name,omitempty"`

	// Fields that are expected to be set once and remain the same through the life
	// of the asset.
	Options map[string]AssetAbilityOptionField `json:"options,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type AssetAbilityControlField struct {
	FieldType string

	Checkbox AssetAbilityControlFieldCheckbox

	Clock AssetAbilityControlFieldClock

	Counter AssetAbilityControlFieldCounter

	Text AssetAbilityControlFieldText
}

func (v AssetAbilityControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "clock":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldClock }{ v.FieldType, v.Clock })
	case "counter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCounter }{ v.FieldType, v.Counter })
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "clock":
		err = json.Unmarshal(b, &v.Clock)
	case "counter":
		err = json.Unmarshal(b, &v.Counter)
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetAbilityControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A clock with 4 or more segments.
type AssetAbilityControlFieldClock struct {
	Label Label `json:"label"`

	// The size of the clock -- in other words, the maximum number of filled clock
	// segments. Standard clocks have 4, 6, 8, or 10 segments.
	Max int8 `json:"max"`

	// The minimum number of filled clock segments. This is always 0.
	Min int8 `json:"min"`

	Rollable bool `json:"rollable"`

	// The current value of this input.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A basic counter representing a non-rollable integer value. They usually start
// at 0, and may or may not have a maximum.
type AssetAbilityControlFieldCounter struct {
	Label Label `json:"label"`

	Max int16 `json:"max"`

	// The (inclusive) minimum value.
	Min int8 `json:"min"`

	Rollable bool `json:"rollable"`

	// The current value of this input.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// Represents an input that accepts plain text.
type AssetAbilityControlFieldText struct {
	Label Label `json:"label"`

	Value string `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A unique ID representing an AssetAbility object.
type AssetAbilityID = string

// A wildcarded AssetAbilityId that can be used to match multiple AssetAbility
// objects.
type AssetAbilityIDWildcard = string

// A unique ID representing an AssetAbilityMove object.
type AssetAbilityMoveID = string

// A wildcarded AssetAbilityMoveId that can be used to match multiple
// AssetAbilityMove objects.
type AssetAbilityMoveIDWildcard = string

type AssetAbilityOptionField struct {
	FieldType string

	Text AssetAbilityOptionFieldText
}

func (v AssetAbilityOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Represents an input that accepts plain text.
type AssetAbilityOptionFieldText struct {
	Label Label `json:"label"`

	Value string `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A unique ID representing an AssetAbilityOracleRollable object.
type AssetAbilityOracleRollableID = string

// A wildcarded AssetAbilityOracleRollableId that can be used to match multiple
// AssetAbilityOracleRollable objects.
type AssetAbilityOracleRollableIDWildcard = string

// A unique ID representing an AssetAbilityOracleRollableRow object.
type AssetAbilityOracleRollableRowID = string

// A wildcarded AssetAbilityOracleRollableRowId that can be used to match
// multiple AssetAbilityOracleRollableRow objects.
type AssetAbilityOracleRollableRowIDWildcard = string

// Describes which assets can be attached to this asset. Example: Starforged's
// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
// Starforged for more info.
type AssetAttachment struct {
	// Asset IDs (which may be wildcards) that may be attached to this asset
	Assets []AssetIDWildcard `json:"assets"`

	Max int16 `json:"max"`
}

type AssetCardFlipFieldFieldType string

const (
	AssetCardFlipFieldFieldTypeCardFlip AssetCardFlipFieldFieldType = "card_flip"
)

type AssetCardFlipField struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	FieldType AssetCardFlipFieldFieldType `json:"field_type"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type AssetCheckboxFieldFieldType string

const (
	AssetCheckboxFieldFieldTypeCheckbox AssetCheckboxFieldFieldType = "checkbox"
)

type AssetCheckboxField struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	FieldType AssetCheckboxFieldFieldType `json:"field_type"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type AssetCollectionType string

const (
	AssetCollectionTypeAssetCollection AssetCollectionType = "asset_collection"
)

type AssetCollection struct {
	// The unique Datasworn ID for this node.
	ID AssetCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Collections map[string]AssetCollection `json:"collections"`

	Contents map[string]Asset `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type AssetCollectionType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []AssetCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []AssetCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing an AssetCollection object.
type AssetCollectionID = string

// A wildcarded AssetCollectionId that can be used to match multiple
// AssetCollection objects.
type AssetCollectionIDWildcard = string

type AssetConditionMeterFieldType string

const (
	AssetConditionMeterFieldTypeConditionMeter AssetConditionMeterFieldType = "condition_meter"
)

// Provides hints for moves that interact with this condition meter, such as
// suffer and recovery moves.
type AssetConditionMeterMoves struct {
	// The ID(s) of recovery moves associated with this meter.
	Recover []AnyMoveIDWildcard `json:"recover,omitempty"`

	// The ID(s) of suffer moves associated with the condition meter. If the
	// suffer move makes an action roll, this condition meter value should be made
	// available as a roll option.
	Suffer []AnyMoveIDWildcard `json:"suffer,omitempty"`
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetConditionMeter struct {
	// Checkbox controls rendered as part of the condition meter.
	Controls map[string]AssetConditionMeterControlField `json:"controls"`

	FieldType AssetConditionMeterFieldType `json:"field_type"`

	Label Label `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// Is this meter's `value` usable as a stat in an action roll?
	Rollable bool `json:"rollable"`

	// The current value of this meter.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`

	// Provides hints for moves that interact with this condition meter, such as
	// suffer and recovery moves.
	Moves *AssetConditionMeterMoves `json:"moves,omitempty"`
}

// A checkbox control field, rendered as part of an asset condition meter.
type AssetConditionMeterControlField struct {
	FieldType string

	CardFlip AssetConditionMeterControlFieldCardFlip

	Checkbox AssetConditionMeterControlFieldCheckbox
}

func (v AssetConditionMeterControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetConditionMeterControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetConditionMeterControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type AssetConditionMeterControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type AssetConditionMeterEnhancementFieldType string

const (
	AssetConditionMeterEnhancementFieldTypeConditionMeter AssetConditionMeterEnhancementFieldType = "condition_meter"
)

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetConditionMeterEnhancement struct {
	FieldType AssetConditionMeterEnhancementFieldType `json:"field_type"`

	// The maximum value of this meter.
	Max int8 `json:"max"`
}

type AssetControlField struct {
	FieldType string

	CardFlip AssetControlFieldCardFlip

	Checkbox AssetControlFieldCheckbox

	ConditionMeter AssetControlFieldConditionMeter

	SelectEnhancement AssetControlFieldSelectEnhancement
}

func (v AssetControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldConditionMeter }{ v.FieldType, v.ConditionMeter })
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type AssetControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// Provides hints for moves that interact with this condition meter, such as
// suffer and recovery moves.
type AssetControlFieldConditionMeterMoves struct {
	// The ID(s) of recovery moves associated with this meter.
	Recover []AnyMoveIDWildcard `json:"recover,omitempty"`

	// The ID(s) of suffer moves associated with the condition meter. If the
	// suffer move makes an action roll, this condition meter value should be made
	// available as a roll option.
	Suffer []AnyMoveIDWildcard `json:"suffer,omitempty"`
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetControlFieldConditionMeter struct {
	// Checkbox controls rendered as part of the condition meter.
	Controls map[string]AssetConditionMeterControlField `json:"controls"`

	Label Label `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// Is this meter's `value` usable as a stat in an action roll?
	Rollable bool `json:"rollable"`

	// The current value of this meter.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`

	// Provides hints for moves that interact with this condition meter, such as
	// suffer and recovery moves.
	Moves *AssetControlFieldConditionMeterMoves `json:"moves,omitempty"`
}

type AssetControlFieldSelectEnhancementChoice struct {
	ChoiceType string

	Choice AssetControlFieldSelectEnhancementChoiceChoice

	ChoiceGroup AssetControlFieldSelectEnhancementChoiceChoiceGroup
}

func (v AssetControlFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.ChoiceType {
	case "choice":
		return json.Marshal(struct { T string `json:"choice_type"`; AssetControlFieldSelectEnhancementChoiceChoice }{ v.ChoiceType, v.Choice })
	case "choice_group":
		return json.Marshal(struct { T string `json:"choice_type"`; AssetControlFieldSelectEnhancementChoiceChoiceGroup }{ v.ChoiceType, v.ChoiceGroup })
	}

	return nil, fmt.Errorf("bad ChoiceType value: %s", v.ChoiceType)
}

func (v *AssetControlFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"choice_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "choice":
		err = json.Unmarshal(b, &v.Choice)
	case "choice_group":
		err = json.Unmarshal(b, &v.ChoiceGroup)
	default:
		err = fmt.Errorf("bad ChoiceType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.ChoiceType = t.T
	return nil
}

// Represents an option in a list of choices.
type AssetControlFieldSelectEnhancementChoiceChoice struct {
	Label Label `json:"label"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetControlFieldSelectEnhancementChoiceChoiceGroup struct {
	Choices map[string]SelectEnhancementFieldChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type AssetControlFieldSelectEnhancement struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoice `json:"choices"`

	Label Label `json:"label"`

	Value DictKey `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type AssetControlFieldEnhancement struct {
	FieldType string

	ConditionMeter AssetControlFieldEnhancementConditionMeter
}

func (v AssetControlFieldEnhancement) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldEnhancementConditionMeter }{ v.FieldType, v.ConditionMeter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlFieldEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetControlFieldEnhancementConditionMeter struct {
	// The maximum value of this meter.
	Max int8 `json:"max"`
}

// A reference to the value of an asset control.
type AssetControlValueRefUsing string

const (
	AssetControlValueRefUsingAssetControl AssetControlValueRefUsing = "asset_control"
)

// A reference to the value of an asset control.
type AssetControlValueRef struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`

	// A reference to the value of an asset control.
	Using AssetControlValueRefUsing `json:"using"`
}

// Describes enhancements made to this asset in a partial asset object. The
// changes should be applied recursively; only the values that are specified
// should be changed.
type AssetEnhancement struct {
	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlFieldEnhancement `json:"controls,omitempty"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact *bool `json:"count_as_impact,omitempty"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared *bool `json:"shared,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A unique ID representing an Asset object.
type AssetID = string

// A wildcarded AssetId that can be used to match multiple Asset objects.
type AssetIDWildcard = string

// Options are asset input fields which are set once, usually when the character
// takes the asset. The most common example is the "name" field on companion
// assets. A more complex example is the choice of a god's stat for the Devotant
// asset.
type AssetOptionField struct {
	FieldType string

	SelectEnhancement AssetOptionFieldSelectEnhancement

	SelectValue AssetOptionFieldSelectValue

	Text AssetOptionFieldText
}

func (v AssetOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	case "select_value":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectValue }{ v.FieldType, v.SelectValue })
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	case "select_value":
		err = json.Unmarshal(b, &v.SelectValue)
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetOptionFieldSelectEnhancementChoice struct {
	ChoiceType string

	Choice AssetOptionFieldSelectEnhancementChoiceChoice

	ChoiceGroup AssetOptionFieldSelectEnhancementChoiceChoiceGroup
}

func (v AssetOptionFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.ChoiceType {
	case "choice":
		return json.Marshal(struct { T string `json:"choice_type"`; AssetOptionFieldSelectEnhancementChoiceChoice }{ v.ChoiceType, v.Choice })
	case "choice_group":
		return json.Marshal(struct { T string `json:"choice_type"`; AssetOptionFieldSelectEnhancementChoiceChoiceGroup }{ v.ChoiceType, v.ChoiceGroup })
	}

	return nil, fmt.Errorf("bad ChoiceType value: %s", v.ChoiceType)
}

func (v *AssetOptionFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"choice_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "choice":
		err = json.Unmarshal(b, &v.Choice)
	case "choice_group":
		err = json.Unmarshal(b, &v.ChoiceGroup)
	default:
		err = fmt.Errorf("bad ChoiceType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.ChoiceType = t.T
	return nil
}

// Represents an option in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceChoice struct {
	Label Label `json:"label"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceChoiceGroup struct {
	Choices map[string]SelectEnhancementFieldChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type AssetOptionFieldSelectEnhancement struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoice `json:"choices"`

	Label Label `json:"label"`

	Value DictKey `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// Represents a list of mutually exclusive choices.
type AssetOptionFieldSelectValue struct {
	Choices map[string]SelectValueFieldChoice `json:"choices"`

	Label Label `json:"label"`

	Value DictKey `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// Represents an input that accepts plain text.
type AssetOptionFieldText struct {
	Label Label `json:"label"`

	Value string `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A reference to the value of an asset option.
type AssetOptionValueRefUsing string

const (
	AssetOptionValueRefUsingAssetOption AssetOptionValueRefUsing = "asset_option"
)

// A reference to the value of an asset option.
type AssetOptionValueRef struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`

	// A reference to the value of an asset option.
	Using AssetOptionValueRefUsing `json:"using"`
}

type AtlasCollectionType string

const (
	AtlasCollectionTypeAtlasCollection AtlasCollectionType = "atlas_collection"
)

type AtlasCollection struct {
	// The unique Datasworn ID for this node.
	ID AtlasCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Collections map[string]AtlasCollection `json:"collections"`

	Contents map[string]AtlasEntry `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type AtlasCollectionType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []AtlasCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []AtlasCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing an AtlasCollection object.
type AtlasCollectionID = string

// A wildcarded AtlasCollectionId that can be used to match multiple
// AtlasCollection objects.
type AtlasCollectionIDWildcard = string

type AtlasEntryType string

const (
	AtlasEntryTypeAtlasEntry AtlasEntryType = "atlas_entry"
)

// An atlas entry, like the Ironlands region entries found in classic Ironsworn.
type AtlasEntry struct {
	// The unique Datasworn ID for this node.
	ID AtlasEntryID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Description MarkdownString `json:"description"`

	Features []MarkdownString `json:"features"`

	Name Label `json:"name"`

	Type AtlasEntryType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	QuestStarter *MarkdownString `json:"quest_starter,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []AtlasEntryIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

// A unique ID representing an AtlasEntry object.
type AtlasEntryID = string

// A wildcarded AtlasEntryId that can be used to match multiple AtlasEntry
// objects.
type AtlasEntryIDWildcard = string

// A reference to the value of an attached asset control. For example, a Module
// asset could use this to roll using the `integrity` control of an attached
// Vehicle.
type AttachedAssetControlValueRefUsing string

const (
	AttachedAssetControlValueRefUsingAttachedAssetControl AttachedAssetControlValueRefUsing = "attached_asset_control"
)

// A reference to the value of an attached asset control. For example, a Module
// asset could use this to roll using the `integrity` control of an attached
// Vehicle.
type AttachedAssetControlValueRef struct {
	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`

	// A reference to the value of an attached asset control. For example, a Module
	// asset could use this to roll using the `integrity` control of an attached
	// Vehicle.
	Using AttachedAssetControlValueRefUsing `json:"using"`
}

// A reference to the value of an attached asset option.
type AttachedAssetOptionValueRefUsing string

const (
	AttachedAssetOptionValueRefUsingAttachedAssetOption AttachedAssetOptionValueRefUsing = "attached_asset_option"
)

// A reference to the value of an attached asset option.
type AttachedAssetOptionValueRef struct {
	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`

	// A reference to the value of an attached asset option.
	Using AttachedAssetOptionValueRefUsing `json:"using"`
}

// Information on the original creator of this material.
type AuthorInfo struct {
	// The name of the author.
	Name Label `json:"name"`

	// An optional email contact for the author
	Email *Email `json:"email,omitempty"`

	// An optional URL for the author's website.
	URL *WebURL `json:"url,omitempty"`
}

// Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
type ChallengeRank = uint8

type ClockFieldFieldType string

const (
	ClockFieldFieldTypeClock ClockFieldFieldType = "clock"
)

// A clock with 4 or more segments.
type ClockField struct {
	FieldType ClockFieldFieldType `json:"field_type"`

	Label Label `json:"label"`

	// The size of the clock -- in other words, the maximum number of filled clock
	// segments. Standard clocks have 4, 6, 8, or 10 segments.
	Max int8 `json:"max"`

	// The minimum number of filled clock segments. This is always 0.
	Min int8 `json:"min"`

	Rollable bool `json:"rollable"`

	// The current value of this input.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type CollectableType string

const (
	CollectableTypeAsset CollectableType = "asset"

	CollectableTypeAtlasEntry CollectableType = "atlas_entry"

	CollectableTypeMove CollectableType = "move"

	CollectableTypeNpc CollectableType = "npc"

	CollectableTypeOracleRollable CollectableType = "oracle_rollable"
)

type CollectionType string

const (
	CollectionTypeAssetCollection CollectionType = "asset_collection"

	CollectionTypeAtlasCollection CollectionType = "atlas_collection"

	CollectionTypeMoveCategory CollectionType = "move_category"

	CollectionTypeNpcCollection CollectionType = "npc_collection"

	CollectionTypeOracleCollection CollectionType = "oracle_collection"
)

type ConditionMeterFieldFieldType string

const (
	ConditionMeterFieldFieldTypeConditionMeter ConditionMeterFieldFieldType = "condition_meter"
)

// A meter with an integer value, bounded by a minimum and maximum.
type ConditionMeterField struct {
	FieldType ConditionMeterFieldFieldType `json:"field_type"`

	Label Label `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// Is this meter's `value` usable as a stat in an action roll?
	Rollable bool `json:"rollable"`

	// The current value of this meter.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A basic, rollable player character resource specified by the ruleset.
type ConditionMeterKey = DictKey

// Describes a standard player character condition meter.
type ConditionMeterRule struct {
	// A description of this condition meter.
	Description MarkdownString `json:"description"`

	Label Label `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// Is this meter's `value` usable as a stat in an action roll?
	Rollable bool `json:"rollable"`

	// Is this condition meter shared by all players?
	Shared bool `json:"shared"`

	// The current value of this meter.
	Value int8 `json:"value"`
}

// A reference to the value of a standard player condition meter.
type ConditionMeterValueRefUsing string

const (
	ConditionMeterValueRefUsingConditionMeter ConditionMeterValueRefUsing = "condition_meter"
)

// A reference to the value of a standard player condition meter.
type ConditionMeterValueRef struct {
	ConditionMeter ConditionMeterKey `json:"condition_meter"`

	// A reference to the value of a standard player condition meter.
	Using ConditionMeterValueRefUsing `json:"using"`
}

type CoreTags struct {
	// This object requires allies to function, and is intended for co-op play, or
	// guided play with allies. It is not appropriate for solo play.
	RequiresAllies *bool `json:"requires_allies,omitempty"`

	// This object is supernatural in nature, and is ideal for settings that
	// feature supernatural or mythic powers.
	Supernatural *bool `json:"supernatural,omitempty"`

	// This object is technological in nature, and is ideal for settings that
	// feature remarkable technologies.
	Technological *bool `json:"technological,omitempty"`
}

type CounterFieldFieldType string

const (
	CounterFieldFieldTypeCounter CounterFieldFieldType = "counter"
)

// A basic counter representing a non-rollable integer value. They usually start
// at 0, and may or may not have a maximum.
type CounterField struct {
	FieldType CounterFieldFieldType `json:"field_type"`

	Label Label `json:"label"`

	Max int16 `json:"max"`

	// The (inclusive) minimum value.
	Min int8 `json:"min"`

	Rollable bool `json:"rollable"`

	// The current value of this input.
	Value int8 `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// A CSS color value.
type CSSColor = string

// An arbitrary static integer value with a label.
type CustomValueUsing string

const (
	CustomValueUsingCustom CustomValueUsing = "custom"
)

// An arbitrary static integer value with a label.
type CustomValue struct {
	Label Label `json:"label"`

	// An arbitrary static integer value with a label.
	Using CustomValueUsing `json:"using"`

	Value int16 `json:"value"`
}

type DelveSiteType string

const (
	DelveSiteTypeDelveSite DelveSiteType = "delve_site"
)

// A delve site with a theme, domain, and denizens.
type DelveSite struct {
	// The unique Datasworn ID for this node.
	ID DelveSiteID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Represents the delve site's denizen matrix as an array of objects.
	Denizens []DelveSiteDenizen `json:"denizens"`

	Description MarkdownString `json:"description"`

	// The ID of the site's DelveSiteDomain card.
	Domain DelveSiteDomainID `json:"domain"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Rank ChallengeRank `json:"rank"`

	// The ID of the site's DelveSiteTheme card.
	Theme DelveSiteThemeID `json:"theme"`

	Type DelveSiteType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An additional theme or domain card ID, for use with optional rules in
	// Ironsworn: Delve.
	ExtraCard *string `json:"extra_card,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// The ID of an atlas entry representing the region in which this delve site
	// is located.
	Region *AtlasEntryID `json:"region,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []DelveSiteIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// Represents an entry in a delve site denizen matrix. Denizen matrices are
// described in Ironsworn: Delve.
type DelveSiteDenizen struct {
	ID DelveSiteDenizenID `json:"_id"`

	Frequency DelveSiteDenizenFrequency `json:"frequency"`

	Roll DiceRange `json:"roll"`

	// A name for the denizen, if it's different than the `name` property of the
	// NPC.
	Name *Label `json:"name,omitempty"`

	// The ID of the relevant NPC entry, if one is specified.
	Npc *NpcID `json:"npc,omitempty"`
}

type DelveSiteDenizenFrequency string

const (
	DelveSiteDenizenFrequencyCommon DelveSiteDenizenFrequency = "common"

	DelveSiteDenizenFrequencyRare DelveSiteDenizenFrequency = "rare"

	DelveSiteDenizenFrequencyUncommon DelveSiteDenizenFrequency = "uncommon"

	DelveSiteDenizenFrequencyUnforeseen DelveSiteDenizenFrequency = "unforeseen"

	DelveSiteDenizenFrequencyVeryCommon DelveSiteDenizenFrequency = "very_common"
)

// A unique ID representing a DelveSiteDenizen object.
type DelveSiteDenizenID = string

// A wildcarded DelveSiteDenizenId that can be used to match multiple
// DelveSiteDenizen objects.
type DelveSiteDenizenIDWildcard = string

type DelveSiteDomainType string

const (
	DelveSiteDomainTypeDelveSiteDomain DelveSiteDomainType = "delve_site_domain"
)

// A delve site Domain card.
type DelveSiteDomain struct {
	// The unique Datasworn ID for this node.
	ID DelveSiteDomainID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Dangers []DelveSiteDomainDanger `json:"dangers"`

	// The description text that appears below the title on the card.
	Description MarkdownString `json:"description"`

	Features []DelveSiteDomainFeature `json:"features"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type DelveSiteDomainType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// An oracle table ID containing place name elements. For examples, see
	// oracle ID `oracle_rollable:delve/site_name/place/barrow`, and its siblings
	// in oracle collection ID `oracle_collection:delve/site_name/place`.
	// These oracles are used by the site name oracle from Ironsworn: Delve
	// (`oracle_rollable:delve/site_name/format`) to create random names for delve
	// sites.
	NameOracle *OracleRollableID `json:"name_oracle,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []DelveSiteDomainIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// Represents a row in an oracle table, with a single text cell.
type DelveSiteDomainDanger struct {
	ID DelveSiteDomainDangerID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A unique ID representing a DelveSiteDomainDanger object.
type DelveSiteDomainDangerID = string

// A wildcarded DelveSiteDomainDangerId that can be used to match multiple
// DelveSiteDomainDanger objects.
type DelveSiteDomainDangerIDWildcard = string

// Represents a row in an oracle table, with a single text cell.
type DelveSiteDomainFeature struct {
	ID DelveSiteDomainFeatureID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A unique ID representing a DelveSiteDomainFeature object.
type DelveSiteDomainFeatureID = string

// A wildcarded DelveSiteDomainFeatureId that can be used to match multiple
// DelveSiteDomainFeature objects.
type DelveSiteDomainFeatureIDWildcard = string

// A unique ID representing a DelveSiteDomain object.
type DelveSiteDomainID = string

// A wildcarded DelveSiteDomainId that can be used to match multiple
// DelveSiteDomain objects.
type DelveSiteDomainIDWildcard = string

// A unique ID representing a DelveSite object.
type DelveSiteID = string

// A wildcarded DelveSiteId that can be used to match multiple DelveSite
// objects.
type DelveSiteIDWildcard = string

type DelveSiteThemeType string

const (
	DelveSiteThemeTypeDelveSiteTheme DelveSiteThemeType = "delve_site_theme"
)

// A delve site theme card.
type DelveSiteTheme struct {
	// The unique Datasworn ID for this node.
	ID DelveSiteThemeID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Dangers []DelveSiteThemeDanger `json:"dangers"`

	// The description text that appears below the title on the card.
	Description MarkdownString `json:"description"`

	Features []DelveSiteThemeFeature `json:"features"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type DelveSiteThemeType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []DelveSiteThemeIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// Represents a row in an oracle table, with a single text cell.
type DelveSiteThemeDanger struct {
	ID DelveSiteThemeDangerID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A unique ID representing a DelveSiteThemeDanger object.
type DelveSiteThemeDangerID = string

// A wildcarded DelveSiteThemeDangerId that can be used to match multiple
// DelveSiteThemeDanger objects.
type DelveSiteThemeDangerIDWildcard = string

// Represents a row in an oracle table, with a single text cell.
type DelveSiteThemeFeature struct {
	ID DelveSiteThemeFeatureID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A unique ID representing a DelveSiteThemeFeature object.
type DelveSiteThemeFeatureID = string

// A wildcarded DelveSiteThemeFeatureId that can be used to match multiple
// DelveSiteThemeFeature objects.
type DelveSiteThemeFeatureIDWildcard = string

// A unique ID representing a DelveSiteTheme object.
type DelveSiteThemeID = string

// A wildcarded DelveSiteThemeId that can be used to match multiple
// DelveSiteTheme objects.
type DelveSiteThemeIDWildcard = string

// A simple dice roll expression with an optional (positive or negative)
// modifer.
type DiceExpression = string

// Represents a range of dice roll results, bounded by `min` and `max`
// (inclusive).
type DiceRange struct {
	// High end of the dice range.
	Max int16 `json:"max"`

	// Low end of the dice range.
	Min int16 `json:"min"`
}

// A `snake_case` key used in a Datasworn dictionary object.
type DictKey = string

// Implementation hints or other developer-facing comments on this node. These
// should be omitted when representing an object for gameplay.
type Documentation = string

// An email address.
type Email = string

type EmbedOnlyType string

const (
	EmbedOnlyTypeAbility EmbedOnlyType = "ability"

	EmbedOnlyTypeDanger EmbedOnlyType = "danger"

	EmbedOnlyTypeDenizen EmbedOnlyType = "denizen"

	EmbedOnlyTypeFeature EmbedOnlyType = "feature"

	EmbedOnlyTypeOption EmbedOnlyType = "option"

	EmbedOnlyTypeRow EmbedOnlyType = "row"

	EmbedOnlyTypeVariant EmbedOnlyType = "variant"
)

type EmbeddedActionRollMoveRollType string

const (
	EmbeddedActionRollMoveRollTypeActionRoll EmbeddedActionRollMoveRollType = "action_roll"
)

type EmbeddedActionRollMoveType string

const (
	EmbeddedActionRollMoveTypeMove EmbeddedActionRollMoveType = "move"
)

type EmbeddedActionRollMove struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	RollType EmbeddedActionRollMoveRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerActionRoll `json:"trigger"`

	Type EmbeddedActionRollMoveType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedMove struct {
	RollType string

	ActionRoll EmbeddedMoveActionRoll

	NoRoll EmbeddedMoveNoRoll

	ProgressRoll EmbeddedMoveProgressRoll

	SpecialTrack EmbeddedMoveSpecialTrack
}

func (v EmbeddedMove) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; EmbeddedMoveActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; EmbeddedMoveNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; EmbeddedMoveProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; EmbeddedMoveSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *EmbeddedMove) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

type EmbeddedMoveActionRollType string

const (
	EmbeddedMoveActionRollTypeMove EmbeddedMoveActionRollType = "move"
)

type EmbeddedMoveActionRoll struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerActionRoll `json:"trigger"`

	Type EmbeddedMoveActionRollType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedMoveNoRollType string

const (
	EmbeddedMoveNoRollTypeMove EmbeddedMoveNoRollType = "move"
)

type EmbeddedMoveNoRoll struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerNoRoll `json:"trigger"`

	Type EmbeddedMoveNoRollType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedMoveProgressRollType string

const (
	EmbeddedMoveProgressRollTypeMove EmbeddedMoveProgressRollType = "move"
)

type EmbeddedMoveProgressRoll struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Describes the common features of progress tracks associated with this move.
	Tracks ProgressTrackTypeInfo `json:"tracks"`

	// Trigger conditions for this move.
	Trigger TriggerProgressRoll `json:"trigger"`

	Type EmbeddedMoveProgressRollType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedMoveSpecialTrackType string

const (
	EmbeddedMoveSpecialTrackTypeMove EmbeddedMoveSpecialTrackType = "move"
)

type EmbeddedMoveSpecialTrack struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerSpecialTrack `json:"trigger"`

	Type EmbeddedMoveSpecialTrackType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedMoveID = string

type EmbeddedMoveIDWildcard = string

type EmbeddedNoRollMoveRollType string

const (
	EmbeddedNoRollMoveRollTypeNoRoll EmbeddedNoRollMoveRollType = "no_roll"
)

type EmbeddedNoRollMoveType string

const (
	EmbeddedNoRollMoveTypeMove EmbeddedNoRollMoveType = "move"
)

type EmbeddedNoRollMove struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	RollType EmbeddedNoRollMoveRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerNoRoll `json:"trigger"`

	Type EmbeddedNoRollMoveType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleColumnTextOracleType string

const (
	EmbeddedOracleColumnTextOracleTypeColumnText EmbeddedOracleColumnTextOracleType = "column_text"
)

type EmbeddedOracleColumnTextType string

const (
	EmbeddedOracleColumnTextTypeOracleRollable EmbeddedOracleColumnTextType = "oracle_rollable"
)

type EmbeddedOracleColumnTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleColumnText struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType EmbeddedOracleColumnTextOracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type EmbeddedOracleColumnTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleColumnTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleColumnText2OracleType string

const (
	EmbeddedOracleColumnText2OracleTypeColumnText2 EmbeddedOracleColumnText2OracleType = "column_text2"
)

type EmbeddedOracleColumnText2Type string

const (
	EmbeddedOracleColumnText2TypeOracleRollable EmbeddedOracleColumnText2Type = "oracle_rollable"
)

type EmbeddedOracleColumnText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleColumnText2 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType EmbeddedOracleColumnText2OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type EmbeddedOracleColumnText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleColumnText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleColumnText3OracleType string

const (
	EmbeddedOracleColumnText3OracleTypeColumnText3 EmbeddedOracleColumnText3OracleType = "column_text3"
)

type EmbeddedOracleColumnText3Type string

const (
	EmbeddedOracleColumnText3TypeOracleRollable EmbeddedOracleColumnText3Type = "oracle_rollable"
)

type EmbeddedOracleColumnText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleColumnText3 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType EmbeddedOracleColumnText3OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type EmbeddedOracleColumnText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleColumnText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollable struct {
	OracleType string

	ColumnText EmbeddedOracleRollableColumnText

	ColumnText2 EmbeddedOracleRollableColumnText2

	ColumnText3 EmbeddedOracleRollableColumnText3

	TableText EmbeddedOracleRollableTableText

	TableText2 EmbeddedOracleRollableTableText2

	TableText3 EmbeddedOracleRollableTableText3
}

func (v EmbeddedOracleRollable) MarshalJSON() ([]byte, error) {
	switch v.OracleType {
	case "column_text":
		return json.Marshal(struct { T string `json:"oracle_type"`; EmbeddedOracleRollableColumnText }{ v.OracleType, v.ColumnText })
	case "column_text2":
		return json.Marshal(struct { T string `json:"oracle_type"`; EmbeddedOracleRollableColumnText2 }{ v.OracleType, v.ColumnText2 })
	case "column_text3":
		return json.Marshal(struct { T string `json:"oracle_type"`; EmbeddedOracleRollableColumnText3 }{ v.OracleType, v.ColumnText3 })
	case "table_text":
		return json.Marshal(struct { T string `json:"oracle_type"`; EmbeddedOracleRollableTableText }{ v.OracleType, v.TableText })
	case "table_text2":
		return json.Marshal(struct { T string `json:"oracle_type"`; EmbeddedOracleRollableTableText2 }{ v.OracleType, v.TableText2 })
	case "table_text3":
		return json.Marshal(struct { T string `json:"oracle_type"`; EmbeddedOracleRollableTableText3 }{ v.OracleType, v.TableText3 })
	}

	return nil, fmt.Errorf("bad OracleType value: %s", v.OracleType)
}

func (v *EmbeddedOracleRollable) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"oracle_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "column_text":
		err = json.Unmarshal(b, &v.ColumnText)
	case "column_text2":
		err = json.Unmarshal(b, &v.ColumnText2)
	case "column_text3":
		err = json.Unmarshal(b, &v.ColumnText3)
	case "table_text":
		err = json.Unmarshal(b, &v.TableText)
	case "table_text2":
		err = json.Unmarshal(b, &v.TableText2)
	case "table_text3":
		err = json.Unmarshal(b, &v.TableText3)
	default:
		err = fmt.Errorf("bad OracleType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OracleType = t.T
	return nil
}

type EmbeddedOracleRollableColumnTextType string

const (
	EmbeddedOracleRollableColumnTextTypeOracleRollable EmbeddedOracleRollableColumnTextType = "oracle_rollable"
)

type EmbeddedOracleRollableColumnTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleRollableColumnText struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type EmbeddedOracleRollableColumnTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleRollableColumnTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollableColumnText2Type string

const (
	EmbeddedOracleRollableColumnText2TypeOracleRollable EmbeddedOracleRollableColumnText2Type = "oracle_rollable"
)

type EmbeddedOracleRollableColumnText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleRollableColumnText2 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type EmbeddedOracleRollableColumnText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleRollableColumnText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollableColumnText3Type string

const (
	EmbeddedOracleRollableColumnText3TypeOracleRollable EmbeddedOracleRollableColumnText3Type = "oracle_rollable"
)

type EmbeddedOracleRollableColumnText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleRollableColumnText3 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type EmbeddedOracleRollableColumnText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleRollableColumnText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollableTableTextColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`
}

type EmbeddedOracleRollableTableTextType string

const (
	EmbeddedOracleRollableTableTextTypeOracleRollable EmbeddedOracleRollableTableTextType = "oracle_rollable"
)

type EmbeddedOracleRollableTableTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleRollableTableText struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	ColumnLabels EmbeddedOracleRollableTableTextColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type EmbeddedOracleRollableTableTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleRollableTableTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollableTableText2ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type EmbeddedOracleRollableTableText2Type string

const (
	EmbeddedOracleRollableTableText2TypeOracleRollable EmbeddedOracleRollableTableText2Type = "oracle_rollable"
)

type EmbeddedOracleRollableTableText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleRollableTableText2 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	ColumnLabels EmbeddedOracleRollableTableText2ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type EmbeddedOracleRollableTableText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleRollableTableText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollableTableText3ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type EmbeddedOracleRollableTableText3Type string

const (
	EmbeddedOracleRollableTableText3TypeOracleRollable EmbeddedOracleRollableTableText3Type = "oracle_rollable"
)

type EmbeddedOracleRollableTableText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleRollableTableText3 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	ColumnLabels EmbeddedOracleRollableTableText3ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type EmbeddedOracleRollableTableText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleRollableTableText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleRollableID = string

type EmbeddedOracleRollableIDWildcard = string

type EmbeddedOracleTableTextColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`
}

type EmbeddedOracleTableTextOracleType string

const (
	EmbeddedOracleTableTextOracleTypeTableText EmbeddedOracleTableTextOracleType = "table_text"
)

type EmbeddedOracleTableTextType string

const (
	EmbeddedOracleTableTextTypeOracleRollable EmbeddedOracleTableTextType = "oracle_rollable"
)

type EmbeddedOracleTableTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleTableText struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	ColumnLabels EmbeddedOracleTableTextColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType EmbeddedOracleTableTextOracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type EmbeddedOracleTableTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleTableTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleTableText2ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type EmbeddedOracleTableText2OracleType string

const (
	EmbeddedOracleTableText2OracleTypeTableText2 EmbeddedOracleTableText2OracleType = "table_text2"
)

type EmbeddedOracleTableText2Type string

const (
	EmbeddedOracleTableText2TypeOracleRollable EmbeddedOracleTableText2Type = "oracle_rollable"
)

type EmbeddedOracleTableText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleTableText2 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	ColumnLabels EmbeddedOracleTableText2ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType EmbeddedOracleTableText2OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type EmbeddedOracleTableText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleTableText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedOracleTableText3ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type EmbeddedOracleTableText3OracleType string

const (
	EmbeddedOracleTableText3OracleTypeTableText3 EmbeddedOracleTableText3OracleType = "table_text3"
)

type EmbeddedOracleTableText3Type string

const (
	EmbeddedOracleTableText3TypeOracleRollable EmbeddedOracleTableText3Type = "oracle_rollable"
)

type EmbeddedOracleTableText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type EmbeddedOracleTableText3 struct {
	ID EmbeddedOracleRollableID `json:"_id"`

	ColumnLabels EmbeddedOracleTableText3ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType EmbeddedOracleTableText3OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type EmbeddedOracleTableText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *EmbeddedOracleTableText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedProgressRollMoveRollType string

const (
	EmbeddedProgressRollMoveRollTypeProgressRoll EmbeddedProgressRollMoveRollType = "progress_roll"
)

type EmbeddedProgressRollMoveType string

const (
	EmbeddedProgressRollMoveTypeMove EmbeddedProgressRollMoveType = "move"
)

type EmbeddedProgressRollMove struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	RollType EmbeddedProgressRollMoveRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Describes the common features of progress tracks associated with this move.
	Tracks ProgressTrackTypeInfo `json:"tracks"`

	// Trigger conditions for this move.
	Trigger TriggerProgressRoll `json:"trigger"`

	Type EmbeddedProgressRollMoveType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type EmbeddedSpecialTrackMoveRollType string

const (
	EmbeddedSpecialTrackMoveRollTypeSpecialTrack EmbeddedSpecialTrackMoveRollType = "special_track"
)

type EmbeddedSpecialTrackMoveType string

const (
	EmbeddedSpecialTrackMoveTypeMove EmbeddedSpecialTrackMoveType = "move"
)

type EmbeddedSpecialTrackMove struct {
	ID EmbeddedMoveID `json:"_id"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	RollType EmbeddedSpecialTrackMoveRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerSpecialTrack `json:"trigger"`

	Type EmbeddedSpecialTrackMoveType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// This type is a placeholder and may see signficant changes in v0.2.0.
type EntityPrompt struct {
	Text MarkdownString `json:"text"`
}

// The version of the Datasworn format used by this data.
type ExpansionDataswornVersion string

const (
	ExpansionDataswornVersion0 ExpansionDataswornVersion = "0.1.0"
)

type ExpansionType string

const (
	ExpansionTypeExpansion ExpansionType = "expansion"
)

// A Datasworn package that relies on an external package to provide its
// ruleset.
type Expansion struct {
	ID ExpansionID `json:"_id"`

	// A dictionary object containing asset collections, which contain assets.
	Assets map[string]AssetCollection `json:"assets"`

	// Lists authors credited by the source material.
	Authors []AuthorInfo `json:"authors"`

	// The version of the Datasworn format used by this data.
	DataswornVersion ExpansionDataswornVersion `json:"datasworn_version"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date time.Time `json:"date"`

	License WebURL `json:"license"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleTablesCollection `json:"oracles"`

	Ruleset RulesetID `json:"ruleset"`

	// The title of the source document.
	Title Label `json:"title"`

	Type ExpansionType `json:"type"`

	// A URL where the source document is available.
	URL WebURL `json:"url"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]AtlasCollection `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	Rules *RulesExpansion `json:"rules,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

// The ID of a Datasworn package that relies on an external package to provide
// its ruleset.
type ExpansionID = string

type I18nHint struct {
	// The part of speech for this string.
	PartOfSpeech *PartOfSpeech `json:"part_of_speech,omitempty"`
}

type I18nHintsTemplate struct {
	Text *I18nHint `json:"text,omitempty"`

	Text2 *I18nHint `json:"text2,omitempty"`

	Text3 *I18nHint `json:"text3,omitempty"`
}

// Internationalization/localization hints for the text content of this object.
type I18nHints struct {
	Template *I18nHintsTemplate `json:"template,omitempty"`

	Text *I18nHint `json:"text,omitempty"`

	Text2 *I18nHint `json:"text2,omitempty"`

	Text3 *I18nHint `json:"text3,omitempty"`
}

// Describes a category of standard impacts/debilities.
type ImpactCategory struct {
	// A dictionary object of the Impacts in this category.
	Contents map[string]ImpactRule `json:"contents"`

	// A description of this impact category.
	Description MarkdownString `json:"description"`

	// A label for this impact category.
	Label Label `json:"label"`
}

// Describes a standard impact/debility.
type ImpactRule struct {
	// A description of this impact.
	Description MarkdownString `json:"description"`

	// The label for this impact.
	Label Label `json:"label"`

	// Is this impact permanent?
	Permanent bool `json:"permanent"`

	// Any ruleset condition meters that can't recover when this impact is active.
	PreventsRecovery []ConditionMeterKey `json:"prevents_recovery"`

	// Is this impact applied to all players at once?
	Shared bool `json:"shared"`
}

// A localized, player-facing name or label, formatted as plain text. In some
// contexts it may be undesirable to render this text, but it should always be
// exposed to assistive technology (e.g. with `aria-label` in HTML).
type Label = string

// Localized, player-facing text, formatted in Markdown. It is *not* formatted
// for use "out of the box"; it uses some custom syntax, intended to be replaced
// in whatever way is most appropriate for your implementation.
// 
// * `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to
// the identified object. The ID must conform to the `AnyId` type; no wildcards
// allowed.
// * `{{table>oracle_rollable:starforged/core/action}}`: the referenced
// oracle is rendered here in the source material. The ID must conform to the
// `AnyOracleRollableId` type; no wildcards allowed.
// * `{{table_columns>move:delve/delve/delve_the_depths}}`: Render
// *all* direct OracleRollable children of the identified node. This
// can be an OracleCollectionId, or the ID of anything that can have
// EmbeddedOracleRollables (such as a Move or TruthOption).
type MarkdownString = string

// A rich text string in Markdown with replaced values from oracle roll results.
// 
// The custom syntax `{{some_row_key>some_oracle_table_id}}` should be replaced
// by the `some_row_key` string of a rolled oracle table. This is usually the
// `text` key, for example `{{text>oracle_rollable:starforged/core/action}}`
type MarkdownTemplateString = string

type Move struct {
	RollType string

	ActionRoll MoveActionRoll0

	NoRoll MoveNoRoll0

	ProgressRoll MoveProgressRoll0

	SpecialTrack MoveSpecialTrack0
}

func (v Move) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveActionRoll0 }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveNoRoll0 }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveProgressRoll0 }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveSpecialTrack0 }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *Move) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

type MoveActionRollType string

const (
	MoveActionRollTypeMove MoveActionRollType = "move"
)

// A move that makes an action roll.
type MoveActionRoll0 struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerActionRoll `json:"trigger"`

	Type MoveActionRollType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type MoveNoRollType string

const (
	MoveNoRollTypeMove MoveNoRollType = "move"
)

// A move that makes no progress rolls or action rolls.
type MoveNoRoll0 struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerNoRoll `json:"trigger"`

	Type MoveNoRollType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type MoveProgressRollType string

const (
	MoveProgressRollTypeMove MoveProgressRollType = "move"
)

// A progress move that rolls on a standard progress track type (whose features
// are defined by this move object). For progress rolls that use special tracks,
// see MoveSpecialTrack.
type MoveProgressRoll0 struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Describes the common features of progress tracks associated with this move.
	Tracks ProgressTrackTypeInfo `json:"tracks"`

	// Trigger conditions for this move.
	Trigger TriggerProgressRoll `json:"trigger"`

	Type MoveProgressRollType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type MoveSpecialTrackType string

const (
	MoveSpecialTrackTypeMove MoveSpecialTrackType = "move"
)

// A progress move that rolls on a special track, such as Legacies (Starforged)
// or Bonds (classic Ironsworn). For progress moves that use standard progress
// tracks, see MoveProgressRoll instead.
type MoveSpecialTrack0 struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerSpecialTrack `json:"trigger"`

	Type MoveSpecialTrackType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type MoveActionRollRollType string

const (
	MoveActionRollRollTypeActionRoll MoveActionRollRollType = "action_roll"
)

type MoveActionRollType0 string

const (
	MoveActionRollTypeMove0 MoveActionRollType0 = "move"
)

// A move that makes an action roll.
type MoveActionRoll struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	RollType MoveActionRollRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerActionRoll `json:"trigger"`

	Type MoveActionRollType0 `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A move must have this `roll_type` to receive this enhancement. This is in
// addition to any other restrictions made by other properties.
type MoveActionRollEnhancementRollType string

const (
	MoveActionRollEnhancementRollTypeActionRoll MoveActionRollEnhancementRollType = "action_roll"
)

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveActionRollEnhancement struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	// A move must have this `roll_type` to receive this enhancement. This is in
	// addition to any other restrictions made by other properties.
	RollType MoveActionRollEnhancementRollType `json:"roll_type"`

	Trigger *TriggerActionRollEnhancement `json:"trigger,omitempty"`
}

type MoveCategoryType string

const (
	MoveCategoryTypeMoveCategory MoveCategoryType = "move_category"
)

type MoveCategory struct {
	// The unique Datasworn ID for this node.
	ID MoveCategoryID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Collections map[string]MoveCategory `json:"collections"`

	Contents map[string]Move `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type MoveCategoryType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []MoveCategoryIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []MoveCategoryIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing a MoveCategory object.
type MoveCategoryID = string

// A wildcarded MoveCategoryId that can be used to match multiple MoveCategory
// objects.
type MoveCategoryIDWildcard = string

type MoveEnhancement struct {
	RollType string

	ActionRoll MoveEnhancementActionRoll

	NoRoll MoveEnhancementNoRoll

	ProgressRoll MoveEnhancementProgressRoll

	SpecialTrack MoveEnhancementSpecialTrack
}

func (v MoveEnhancement) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *MoveEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementActionRoll struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	Trigger *TriggerActionRollEnhancement `json:"trigger,omitempty"`
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementNoRoll struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	Trigger *TriggerNoRollEnhancement `json:"trigger,omitempty"`
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementProgressRoll struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	Trigger *TriggerProgressRollEnhancement `json:"trigger,omitempty"`
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementSpecialTrack struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	Trigger *TriggerSpecialTrackEnhancement `json:"trigger,omitempty"`
}

// A unique ID representing a Move object.
type MoveID = string

// A wildcarded MoveId that can be used to match multiple Move objects.
type MoveIDWildcard = string

type MoveNoRollRollType string

const (
	MoveNoRollRollTypeNoRoll MoveNoRollRollType = "no_roll"
)

type MoveNoRollType0 string

const (
	MoveNoRollTypeMove0 MoveNoRollType0 = "move"
)

// A move that makes no progress rolls or action rolls.
type MoveNoRoll struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	RollType MoveNoRollRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerNoRoll `json:"trigger"`

	Type MoveNoRollType0 `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A move must have this `roll_type` to receive this enhancement. This is in
// addition to any other restrictions made by other properties.
type MoveNoRollEnhancementRollType string

const (
	MoveNoRollEnhancementRollTypeNoRoll MoveNoRollEnhancementRollType = "no_roll"
)

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveNoRollEnhancement struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	// A move must have this `roll_type` to receive this enhancement. This is in
	// addition to any other restrictions made by other properties.
	RollType MoveNoRollEnhancementRollType `json:"roll_type"`

	Trigger *TriggerNoRollEnhancement `json:"trigger,omitempty"`
}

// A unique ID representing a MoveOracleRollable object.
type MoveOracleRollableID = string

// A wildcarded MoveOracleRollableId that can be used to match multiple
// MoveOracleRollable objects.
type MoveOracleRollableIDWildcard = string

// A unique ID representing a MoveOracleRollableRow object.
type MoveOracleRollableRowID = string

// A wildcarded MoveOracleRollableRowId that can be used to match multiple
// MoveOracleRollableRow objects.
type MoveOracleRollableRowIDWildcard = string

type MoveOutcome struct {
	Text MarkdownString `json:"text"`

	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`
}

// A standalone localized description for each move outcome (miss, weak hit,
// or strong hit). This is for for e.g. VTT implementations, where it's often
// useful to display only the rules text relevant to a roll result.
// 
//   This often requires light editorialization to create text that can stand
// alone without reference to the rest of the move. For example, 'as above'
// (in reference to another move outcome) shouldn't be used here; instead, the
// relevant text should be repeated.
type MoveOutcomes struct {
	Miss MoveOutcome `json:"miss"`

	StrongHit MoveOutcome `json:"strong_hit"`

	WeakHit MoveOutcome `json:"weak_hit"`
}

type MoveProgressRollRollType string

const (
	MoveProgressRollRollTypeProgressRoll MoveProgressRollRollType = "progress_roll"
)

type MoveProgressRollType0 string

const (
	MoveProgressRollTypeMove0 MoveProgressRollType0 = "move"
)

// A progress move that rolls on a standard progress track type (whose features
// are defined by this move object). For progress rolls that use special tracks,
// see MoveSpecialTrack.
type MoveProgressRoll struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	RollType MoveProgressRollRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Describes the common features of progress tracks associated with this move.
	Tracks ProgressTrackTypeInfo `json:"tracks"`

	// Trigger conditions for this move.
	Trigger TriggerProgressRoll `json:"trigger"`

	Type MoveProgressRollType0 `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A move must have this `roll_type` to receive this enhancement. This is in
// addition to any other restrictions made by other properties.
type MoveProgressRollEnhancementRollType string

const (
	MoveProgressRollEnhancementRollTypeProgressRoll MoveProgressRollEnhancementRollType = "progress_roll"
)

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveProgressRollEnhancement struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	// A move must have this `roll_type` to receive this enhancement. This is in
	// addition to any other restrictions made by other properties.
	RollType MoveProgressRollEnhancementRollType `json:"roll_type"`

	Trigger *TriggerProgressRollEnhancement `json:"trigger,omitempty"`
}

type MoveRollType string

const (
// A move that makes an action roll.
	MoveRollTypeActionRoll MoveRollType = "action_roll"

// A move that makes no action rolls or progress rolls.
	MoveRollTypeNoRoll MoveRollType = "no_roll"

// A progress move that rolls on a standard progress track type (defined by
// this move).
	MoveRollTypeProgressRoll MoveRollType = "progress_roll"

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacies (Starforged).
	MoveRollTypeSpecialTrack MoveRollType = "special_track"
)

type MoveSpecialTrackRollType string

const (
	MoveSpecialTrackRollTypeSpecialTrack MoveSpecialTrackRollType = "special_track"
)

type MoveSpecialTrackType0 string

const (
	MoveSpecialTrackTypeMove0 MoveSpecialTrackType0 = "move"
)

// A progress move that rolls on a special track, such as Legacies (Starforged)
// or Bonds (classic Ironsworn). For progress moves that use standard progress
// tracks, see MoveProgressRoll instead.
type MoveSpecialTrack struct {
	// The unique Datasworn ID for this node.
	ID MoveID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Is burning momentum allowed for this move?
	AllowMomentumBurn bool `json:"allow_momentum_burn"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	RollType MoveSpecialTrackRollType `json:"roll_type"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerSpecialTrack `json:"trigger"`

	Type MoveSpecialTrackType0 `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified moves. References to the
	// replaced moves can be considered equivalent to this move.
	Replaces []MoveIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A move must have this `roll_type` to receive this enhancement. This is in
// addition to any other restrictions made by other properties.
type MoveSpecialTrackEnhancementRollType string

const (
	MoveSpecialTrackEnhancementRollTypeSpecialTrack MoveSpecialTrackEnhancementRollType = "special_track"
)

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveSpecialTrackEnhancement struct {
	Enhances []AnyMoveIDWildcard `json:"enhances"`

	// A move must have this `roll_type` to receive this enhancement. This is in
	// addition to any other restrictions made by other properties.
	RollType MoveSpecialTrackEnhancementRollType `json:"roll_type"`

	Trigger *TriggerSpecialTrackEnhancement `json:"trigger,omitempty"`
}

type NonCollectableType string

const (
	NonCollectableTypeDelveSite NonCollectableType = "delve_site"

	NonCollectableTypeDelveSiteDomain NonCollectableType = "delve_site_domain"

	NonCollectableTypeDelveSiteTheme NonCollectableType = "delve_site_theme"

	NonCollectableTypeRarity NonCollectableType = "rarity"

	NonCollectableTypeTruth NonCollectableType = "truth"
)

type NpcType string

const (
	NpcTypeNpc NpcType = "npc"
)

// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
// Rulebook, or Chapter 4 of Starforged.
type Npc struct {
	// The unique Datasworn ID for this node.
	ID NpcID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Description MarkdownString `json:"description"`

	Drives []MarkdownString `json:"drives"`

	Features []MarkdownString `json:"features"`

	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	// The suggested challenge rank for this NPC.
	Rank ChallengeRank `json:"rank"`

	Tactics []MarkdownString `json:"tactics"`

	Type NpcType `json:"type"`

	Variants map[string]NpcVariant `json:"variants"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	QuestStarter *MarkdownString `json:"quest_starter,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []NpcIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

type NpcCollectionType string

const (
	NpcCollectionTypeNpcCollection NpcCollectionType = "npc_collection"
)

type NpcCollection struct {
	// The unique Datasworn ID for this node.
	ID NpcCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Collections map[string]NpcCollection `json:"collections"`

	Contents map[string]Npc `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type NpcCollectionType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []NpcCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []NpcCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing a NpcCollection object.
type NpcCollectionID = string

// A wildcarded NpcCollectionId that can be used to match multiple NpcCollection
// objects.
type NpcCollectionIDWildcard = string

// A unique ID representing a Npc object.
type NpcID = string

// A wildcarded NpcId that can be used to match multiple Npc objects.
type NpcIDWildcard = string

// A localized category label describing the nature of this NPC.
// 
// In Ironsworn classic, this is probably the singular form of the parent
// collection's name.
// 
// For Starforged, see the table on p. 258 for examples.
type NpcNature = Label

type NpcVariant struct {
	// The unique Datasworn ID for this node.
	ID NpcVariantID `json:"_id"`

	Description MarkdownString `json:"description"`

	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	// The suggested challenge rank for this NPC.
	Rank ChallengeRank `json:"rank"`

	Comment *Documentation `json:"_comment,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID representing a NpcVariant object.
type NpcVariantID = string

// A wildcarded NpcVariantId that can be used to match multiple NpcVariant
// objects.
type NpcVariantIDWildcard = string

type OracleCollection struct {
	OracleType string

	TableSharedRolls OracleCollectionTableSharedRolls

	TableSharedText OracleCollectionTableSharedText

	TableSharedText2 OracleCollectionTableSharedText2

	TableSharedText3 OracleCollectionTableSharedText3

	Tables OracleCollectionTables
}

func (v OracleCollection) MarshalJSON() ([]byte, error) {
	switch v.OracleType {
	case "table_shared_rolls":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleCollectionTableSharedRolls }{ v.OracleType, v.TableSharedRolls })
	case "table_shared_text":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleCollectionTableSharedText }{ v.OracleType, v.TableSharedText })
	case "table_shared_text2":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleCollectionTableSharedText2 }{ v.OracleType, v.TableSharedText2 })
	case "table_shared_text3":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleCollectionTableSharedText3 }{ v.OracleType, v.TableSharedText3 })
	case "tables":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleCollectionTables }{ v.OracleType, v.Tables })
	}

	return nil, fmt.Errorf("bad OracleType value: %s", v.OracleType)
}

func (v *OracleCollection) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"oracle_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "table_shared_rolls":
		err = json.Unmarshal(b, &v.TableSharedRolls)
	case "table_shared_text":
		err = json.Unmarshal(b, &v.TableSharedText)
	case "table_shared_text2":
		err = json.Unmarshal(b, &v.TableSharedText2)
	case "table_shared_text3":
		err = json.Unmarshal(b, &v.TableSharedText3)
	case "tables":
		err = json.Unmarshal(b, &v.Tables)
	default:
		err = fmt.Errorf("bad OracleType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OracleType = t.T
	return nil
}

// Provides column labels for this table. The `roll` key refers to the roll
// column showing the dice range (`min` and `max` on each table row). For all
// other column labels, see the `name` property of each child `OracleColumn`.
type OracleCollectionTableSharedRollsColumnLabels struct {
	Roll Label `json:"roll"`
}

type OracleCollectionTableSharedRollsType string

const (
	OracleCollectionTableSharedRollsTypeOracleCollection OracleCollectionTableSharedRollsType = "oracle_collection"
)

// An OracleCollection representing a single table with one roll column and
// multiple text columns.
type OracleCollectionTableSharedRolls struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Provides column labels for this table. The `roll` key refers to the roll
	// column showing the dice range (`min` and `max` on each table row). For all
	// other column labels, see the `name` property of each child `OracleColumn`.
	ColumnLabels OracleCollectionTableSharedRollsColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type OracleCollectionTableSharedRollsType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleCollectionTableSharedTextColumnLabels struct {
	Text Label `json:"text"`
}

type OracleCollectionTableSharedTextType string

const (
	OracleCollectionTableSharedTextTypeOracleCollection OracleCollectionTableSharedTextType = "oracle_collection"
)

// An OracleCollection representing a single table with multiple roll columns
// and one text column.
type OracleCollectionTableSharedText struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleCollectionTableSharedTextColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type OracleCollectionTableSharedTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleCollectionTableSharedText2ColumnLabels struct {
	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type OracleCollectionTableSharedText2Type string

const (
	OracleCollectionTableSharedText2TypeOracleCollection OracleCollectionTableSharedText2Type = "oracle_collection"
)

// An OracleCollection representing a single table with multiple roll columns,
// and 2 shared text columns.
type OracleCollectionTableSharedText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleCollectionTableSharedText2ColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText2 `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type OracleCollectionTableSharedText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleCollectionTableSharedText3ColumnLabels struct {
	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type OracleCollectionTableSharedText3Type string

const (
	OracleCollectionTableSharedText3TypeOracleCollection OracleCollectionTableSharedText3Type = "oracle_collection"
)

// An OracleCollection representing a single table with multiple roll columns,
// and 3 shared text columns.
type OracleCollectionTableSharedText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleCollectionTableSharedText3ColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText3 `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type OracleCollectionTableSharedText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleCollectionTablesType string

const (
	OracleCollectionTablesTypeOracleCollection OracleCollectionTablesType = "oracle_collection"
)

// An OracleCollection that represents a category or grouping of tables, which
// may themselves be `OracleTablesCollection`s.
type OracleCollectionTables struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Collections map[string]OracleCollection `json:"collections"`

	Contents map[string]OracleRollableTable `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type OracleCollectionTablesType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing an OracleCollection object.
type OracleCollectionID = string

// A wildcarded OracleCollectionId that can be used to match multiple
// OracleCollection objects.
type OracleCollectionIDWildcard = string

type OracleColumnTextOracleType string

const (
	OracleColumnTextOracleTypeColumnText OracleColumnTextOracleType = "column_text"
)

type OracleColumnTextType string

const (
	OracleColumnTextTypeOracleRollable OracleColumnTextType = "oracle_rollable"
)

type OracleColumnTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// Represents a single column in an OracleCollection.
type OracleColumnText struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleColumnTextOracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type OracleColumnTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleColumnTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleColumnText2OracleType string

const (
	OracleColumnText2OracleTypeColumnText2 OracleColumnText2OracleType = "column_text2"
)

type OracleColumnText2Type string

const (
	OracleColumnText2TypeOracleRollable OracleColumnText2Type = "oracle_rollable"
)

type OracleColumnText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type OracleColumnText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleColumnText2OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type OracleColumnText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleColumnText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleColumnText3OracleType string

const (
	OracleColumnText3OracleTypeColumnText3 OracleColumnText3OracleType = "column_text3"
)

type OracleColumnText3Type string

const (
	OracleColumnText3TypeOracleRollable OracleColumnText3Type = "oracle_rollable"
)

type OracleColumnText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type OracleColumnText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleColumnText3OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type OracleColumnText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleColumnText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// Special roll instructions to use when rolling multiple times on a single
// oracle.
type OracleDuplicateBehavior string

const (
// Duplicates results should be kept.
	OracleDuplicateBehaviorKeep OracleDuplicateBehavior = "keep"

// Duplicate results should be kept, and they compound to make things worse.
	OracleDuplicateBehaviorMakeItWorse OracleDuplicateBehavior = "make_it_worse"

// Duplicate results should be re-rolled.
	OracleDuplicateBehaviorReroll OracleDuplicateBehavior = "reroll"
)

type OracleMatchBehavior struct {
	Text MarkdownString `json:"text"`
}

type OracleRoll struct {
	// Both Ironsworn and Starforged explicitly recommend *against* rolling
	// all details at once. That said, some oracle results only provide useful
	// information once a secondary roll occurs, such as "Action + Theme" or "Roll
	// twice".
	Auto bool `json:"auto"`

	Dice DiceExpression `json:"dice"`

	// Special rules on how to handle duplicate results, when rolling multiple
	// times.
	Duplicates OracleDuplicateBehavior `json:"duplicates"`

	// The number of times to roll.
	NumberOfRolls int16 `json:"number_of_rolls"`

	Oracle OracleRollableID `json:"oracle"`
}

// Provides string templates that may be used in place of the static row
// text from `OracleRollableRow#text`, `OracleRollableRow#text2`, and
// `OracleRollableRow#text3`.
// 
//   These strings are formatted in Markdown, but use a special syntax for their
// placeholders: `{{text>some_oracle_rollable_id}}`. The placeholder should be
// replaced with the value of a rolled (or selected) `OracleRollableRow#text`
// from the target oracle rollable ID.
type OracleRollTemplate struct {
	// A string template that may be used in place of OracleRollableRow#text.
	Text *MarkdownTemplateString `json:"text,omitempty"`

	// A string template that may be used in place of OracleRollableRow#text2.
	Text2 *MarkdownTemplateString `json:"text2,omitempty"`

	// A string template that may be used in place of OracleRollableRow#text3.
	Text3 *MarkdownTemplateString `json:"text3,omitempty"`
}

// A collection of table rows from which random results may be rolled. This may
// represent a standalone table, or a column in a larger table.
type OracleRollable struct {
	OracleType string

	ColumnText OracleRollableColumnText

	ColumnText2 OracleRollableColumnText2

	ColumnText3 OracleRollableColumnText3

	TableText OracleRollableTableText

	TableText2 OracleRollableTableText2

	TableText3 OracleRollableTableText3
}

func (v OracleRollable) MarshalJSON() ([]byte, error) {
	switch v.OracleType {
	case "column_text":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableColumnText }{ v.OracleType, v.ColumnText })
	case "column_text2":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableColumnText2 }{ v.OracleType, v.ColumnText2 })
	case "column_text3":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableColumnText3 }{ v.OracleType, v.ColumnText3 })
	case "table_text":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableTableText }{ v.OracleType, v.TableText })
	case "table_text2":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableTableText2 }{ v.OracleType, v.TableText2 })
	case "table_text3":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableTableText3 }{ v.OracleType, v.TableText3 })
	}

	return nil, fmt.Errorf("bad OracleType value: %s", v.OracleType)
}

func (v *OracleRollable) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"oracle_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "column_text":
		err = json.Unmarshal(b, &v.ColumnText)
	case "column_text2":
		err = json.Unmarshal(b, &v.ColumnText2)
	case "column_text3":
		err = json.Unmarshal(b, &v.ColumnText3)
	case "table_text":
		err = json.Unmarshal(b, &v.TableText)
	case "table_text2":
		err = json.Unmarshal(b, &v.TableText2)
	case "table_text3":
		err = json.Unmarshal(b, &v.TableText3)
	default:
		err = fmt.Errorf("bad OracleType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OracleType = t.T
	return nil
}

type OracleRollableColumnTextType string

const (
	OracleRollableColumnTextTypeOracleRollable OracleRollableColumnTextType = "oracle_rollable"
)

type OracleRollableColumnTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// Represents a single column in an OracleCollection.
type OracleRollableColumnText struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type OracleRollableColumnTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableColumnTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableColumnText2Type string

const (
	OracleRollableColumnText2TypeOracleRollable OracleRollableColumnText2Type = "oracle_rollable"
)

type OracleRollableColumnText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type OracleRollableColumnText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type OracleRollableColumnText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableColumnText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableColumnText3Type string

const (
	OracleRollableColumnText3TypeOracleRollable OracleRollableColumnText3Type = "oracle_rollable"
)

type OracleRollableColumnText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

type OracleRollableColumnText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type OracleRollableColumnText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableColumnText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableTableTextColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`
}

type OracleRollableTableTextType string

const (
	OracleRollableTableTextTypeOracleRollable OracleRollableTableTextType = "oracle_rollable"
)

type OracleRollableTableTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// Represents a basic rollable oracle table with one roll column and one text
// result column.
type OracleRollableTableText struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleRollableTableTextColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type OracleRollableTableTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableTableTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableTableText2ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type OracleRollableTableText2Type string

const (
	OracleRollableTableText2TypeOracleRollable OracleRollableTableText2Type = "oracle_rollable"
)

type OracleRollableTableText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// A rollable oracle table with one roll column and two text columns.
type OracleRollableTableText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleRollableTableText2ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type OracleRollableTableText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableTableText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableTableText3ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type OracleRollableTableText3Type string

const (
	OracleRollableTableText3TypeOracleRollable OracleRollableTableText3Type = "oracle_rollable"
)

type OracleRollableTableText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// A rollable oracle table with one roll column and 3 text columns.
type OracleRollableTableText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleRollableTableText3ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type OracleRollableTableText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableTableText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing an OracleRollable object.
type OracleRollableID = string

// A wildcarded OracleRollableId that can be used to match multiple
// OracleRollable objects.
type OracleRollableIDWildcard = string

// A unique ID representing an OracleRollableRow object.
type OracleRollableRowID = string

// A wildcarded OracleRollableRowId that can be used to match multiple
// OracleRollableRow objects.
type OracleRollableRowIDWildcard = string

// Represents a row in an oracle table, with a single text cell.
type OracleRollableRowText struct {
	ID AnyOracleRollableRowID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Represents a row in an oracle table that provides a secondary text field.
type OracleRollableRowText2 struct {
	ID AnyOracleRollableRowID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	Text2 MarkdownString `json:"text2"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Represents a row in an oracle table with 3 text cells.
type OracleRollableRowText3 struct {
	ID AnyOracleRollableRowID `json:"_id"`

	Roll DiceRange `json:"roll"`

	// The primary text content of this row.
	Text MarkdownString `json:"text"`

	Text2 MarkdownString `json:"text2"`

	Text3 MarkdownString `json:"text3"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleRollableID `json:"embed_table,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	OracleRolls []OracleRoll `json:"oracle_rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type OracleRollableTable struct {
	OracleType string

	TableText OracleRollableTableTableText

	TableText2 OracleRollableTableTableText2

	TableText3 OracleRollableTableTableText3
}

func (v OracleRollableTable) MarshalJSON() ([]byte, error) {
	switch v.OracleType {
	case "table_text":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableTableTableText }{ v.OracleType, v.TableText })
	case "table_text2":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableTableTableText2 }{ v.OracleType, v.TableText2 })
	case "table_text3":
		return json.Marshal(struct { T string `json:"oracle_type"`; OracleRollableTableTableText3 }{ v.OracleType, v.TableText3 })
	}

	return nil, fmt.Errorf("bad OracleType value: %s", v.OracleType)
}

func (v *OracleRollableTable) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"oracle_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "table_text":
		err = json.Unmarshal(b, &v.TableText)
	case "table_text2":
		err = json.Unmarshal(b, &v.TableText2)
	case "table_text3":
		err = json.Unmarshal(b, &v.TableText3)
	default:
		err = fmt.Errorf("bad OracleType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OracleType = t.T
	return nil
}

type OracleRollableTableTableTextColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`
}

type OracleRollableTableTableTextType string

const (
	OracleRollableTableTableTextTypeOracleRollable OracleRollableTableTableTextType = "oracle_rollable"
)

type OracleRollableTableTableTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// Represents a basic rollable oracle table with one roll column and one text
// result column.
type OracleRollableTableTableText struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleRollableTableTableTextColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type OracleRollableTableTableTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableTableTableTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableTableTableText2ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type OracleRollableTableTableText2Type string

const (
	OracleRollableTableTableText2TypeOracleRollable OracleRollableTableTableText2Type = "oracle_rollable"
)

type OracleRollableTableTableText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// A rollable oracle table with one roll column and two text columns.
type OracleRollableTableTableText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleRollableTableTableText2ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type OracleRollableTableTableText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableTableTableText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleRollableTableTableText3ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type OracleRollableTableTableText3Type string

const (
	OracleRollableTableTableText3TypeOracleRollable OracleRollableTableTableText3Type = "oracle_rollable"
)

type OracleRollableTableTableText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// A rollable oracle table with one roll column and 3 text columns.
type OracleRollableTableTableText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleRollableTableTableText3ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type OracleRollableTableTableText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleRollableTableTableText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// Provides column labels for this table. The `roll` key refers to the roll
// column showing the dice range (`min` and `max` on each table row). For all
// other column labels, see the `name` property of each child `OracleColumn`.
type OracleTableSharedRollsColumnLabels struct {
	Roll Label `json:"roll"`
}

type OracleTableSharedRollsOracleType string

const (
	OracleTableSharedRollsOracleTypeTableSharedRolls OracleTableSharedRollsOracleType = "table_shared_rolls"
)

type OracleTableSharedRollsType string

const (
	OracleTableSharedRollsTypeOracleCollection OracleTableSharedRollsType = "oracle_collection"
)

// An OracleCollection representing a single table with one roll column and
// multiple text columns.
type OracleTableSharedRolls struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// Provides column labels for this table. The `roll` key refers to the roll
	// column showing the dice range (`min` and `max` on each table row). For all
	// other column labels, see the `name` property of each child `OracleColumn`.
	ColumnLabels OracleTableSharedRollsColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableSharedRollsOracleType `json:"oracle_type"`

	Type OracleTableSharedRollsType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTableSharedTextColumnLabels struct {
	Text Label `json:"text"`
}

type OracleTableSharedTextOracleType string

const (
	OracleTableSharedTextOracleTypeTableSharedText OracleTableSharedTextOracleType = "table_shared_text"
)

type OracleTableSharedTextType string

const (
	OracleTableSharedTextTypeOracleCollection OracleTableSharedTextType = "oracle_collection"
)

// An OracleCollection representing a single table with multiple roll columns
// and one text column.
type OracleTableSharedText struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleTableSharedTextColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableSharedTextOracleType `json:"oracle_type"`

	Type OracleTableSharedTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTableSharedText2ColumnLabels struct {
	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type OracleTableSharedText2OracleType string

const (
	OracleTableSharedText2OracleTypeTableSharedText2 OracleTableSharedText2OracleType = "table_shared_text2"
)

type OracleTableSharedText2Type string

const (
	OracleTableSharedText2TypeOracleCollection OracleTableSharedText2Type = "oracle_collection"
)

// An OracleCollection representing a single table with multiple roll columns,
// and 2 shared text columns.
type OracleTableSharedText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleTableSharedText2ColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText2 `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableSharedText2OracleType `json:"oracle_type"`

	Type OracleTableSharedText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTableSharedText3ColumnLabels struct {
	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type OracleTableSharedText3OracleType string

const (
	OracleTableSharedText3OracleTypeTableSharedText3 OracleTableSharedText3OracleType = "table_shared_text3"
)

type OracleTableSharedText3Type string

const (
	OracleTableSharedText3TypeOracleCollection OracleTableSharedText3Type = "oracle_collection"
)

// An OracleCollection representing a single table with multiple roll columns,
// and 3 shared text columns.
type OracleTableSharedText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleTableSharedText3ColumnLabels `json:"column_labels"`

	Contents map[string]OracleColumnText3 `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableSharedText3OracleType `json:"oracle_type"`

	Type OracleTableSharedText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTableTextColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`
}

type OracleTableTextOracleType string

const (
	OracleTableTextOracleTypeTableText OracleTableTextOracleType = "table_text"
)

type OracleTableTextType string

const (
	OracleTableTextTypeOracleRollable OracleTableTextType = "oracle_rollable"
)

type OracleTableTextRecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// Represents a basic rollable oracle table with one roll column and one text
// result column.
type OracleTableText struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleTableTextColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableTextOracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText `json:"rows"`

	Type OracleTableTextType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleTableTextRecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTableText2ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`
}

type OracleTableText2OracleType string

const (
	OracleTableText2OracleTypeTableText2 OracleTableText2OracleType = "table_text2"
)

type OracleTableText2Type string

const (
	OracleTableText2TypeOracleRollable OracleTableText2Type = "oracle_rollable"
)

type OracleTableText2RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// A rollable oracle table with one roll column and two text columns.
type OracleTableText2 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleTableText2ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableText2OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText2 `json:"rows"`

	Type OracleTableText2Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleTableText2RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTableText3ColumnLabels struct {
	Roll Label `json:"roll"`

	Text Label `json:"text"`

	Text2 Label `json:"text2"`

	Text3 Label `json:"text3"`
}

type OracleTableText3OracleType string

const (
	OracleTableText3OracleTypeTableText3 OracleTableText3OracleType = "table_text3"
)

type OracleTableText3Type string

const (
	OracleTableText3TypeOracleRollable OracleTableText3Type = "oracle_rollable"
)

type OracleTableText3RecommendedRolls struct {
	Max int16 `json:"max"`

	Min int16 `json:"min"`
}

// A rollable oracle table with one roll column and 3 text columns.
type OracleTableText3 struct {
	// The unique Datasworn ID for this node.
	ID OracleRollableID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	ColumnLabels OracleTableText3ColumnLabels `json:"column_labels"`

	// The roll used to select a result on this oracle.
	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTableText3OracleType `json:"oracle_type"`

	// An array of objects, each representing a single row of the table.
	Rows []OracleRollableRowText3 `json:"rows"`

	Type OracleTableText3Type `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleMatchBehavior `json:"match,omitempty"`

	RecommendedRolls *OracleTableText3RecommendedRolls `json:"recommended_rolls,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleRollableIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

type OracleTablesCollectionOracleType string

const (
	OracleTablesCollectionOracleTypeTables OracleTablesCollectionOracleType = "tables"
)

type OracleTablesCollectionType string

const (
	OracleTablesCollectionTypeOracleCollection OracleTablesCollectionType = "oracle_collection"
)

// An OracleCollection that represents a category or grouping of tables, which
// may themselves be `OracleTablesCollection`s.
type OracleTablesCollection struct {
	// The unique Datasworn ID for this node.
	ID OracleCollectionID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Collections map[string]OracleCollection `json:"collections"`

	Contents map[string]OracleRollableTable `json:"contents"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	OracleType OracleTablesCollectionOracleType `json:"oracle_type"`

	Type OracleTablesCollectionType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This node's content enhances all nodes that match these wildcards, rather
	// than being a standalone item of its own.
	Enhances []OracleCollectionIDWildcard `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []OracleCollectionIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// Represents a page number in a book.
type PageNumber = uint16

type PartOfSpeech string

const (
// An adjective.
	PartOfSpeechAdjective PartOfSpeech = "adjective"

// An adjective used as a proper noun.
	PartOfSpeechAdjectiveAsProperNoun PartOfSpeech = "adjective_as_proper_noun"

// A common noun used as an adjective, to modify another noun.
	PartOfSpeechAdjunctCommonNoun PartOfSpeech = "adjunct_common_noun"

// A proper noun used as an adjective, to modify another noun.
	PartOfSpeechAdjunctProperNoun PartOfSpeech = "adjunct_proper_noun"

// A verb used as an adjective, to modify a noun.
	PartOfSpeechAttributiveVerb PartOfSpeech = "attributive_verb"

// A common noun.
	PartOfSpeechCommonNoun PartOfSpeech = "common_noun"

// An common noun used as a proper noun.
	PartOfSpeechCommonNounAsProperNoun PartOfSpeech = "common_noun_as_proper_noun"

// Gerund or present participle of a verb, e.g. "going", "seeing", "waving". Can
// function as a noun, an adjective, or a progressive verb.
	PartOfSpeechGerund PartOfSpeech = "gerund"

// A proper noun.
	PartOfSpeechProperNoun PartOfSpeech = "proper_noun"

// A verb in present tense
	PartOfSpeechVerb PartOfSpeech = "verb"
)

type ProgressRollMethod string

const (
// An automatic miss.
	ProgressRollMethodMiss ProgressRollMethod = "miss"

// Make a progress roll on a progress track associated with this move.
	ProgressRollMethodProgressRoll ProgressRollMethod = "progress_roll"

// An automatic strong hit.
	ProgressRollMethodStrongHit ProgressRollMethod = "strong_hit"

// An automatic weak hit.
	ProgressRollMethodWeakHit ProgressRollMethod = "weak_hit"
)

type ProgressRollOptionUsing string

const (
	ProgressRollOptionUsingProgressTrack ProgressRollOptionUsing = "progress_track"
)

type ProgressRollOption struct {
	Using ProgressRollOptionUsing `json:"using"`
}

// Describes the features of a type of progress track.
type ProgressTrackTypeInfo struct {
	// A category label for progress tracks of this type.
	Category Label `json:"category"`

	Controls map[string]interface{} `json:"controls,omitempty"`
}

type RarityType string

const (
	RarityTypeRarity RarityType = "rarity"
)

// A rarity, as described in Ironsworn: Delve.
type Rarity struct {
	// The unique Datasworn ID for this node.
	ID RarityID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	// The asset augmented by this rarity.
	Asset AssetID `json:"asset"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Type RarityType `json:"type"`

	// From Ironsworn: Delve, p. 174:
	// 
	//       Some assets will bring a rarity into play more often than others, so
	// the experience point cost for a rarity will vary by the linked asset. These
	// costs are shown in the tables on page 175.
	// 
	//       If you are playing solo, and aren’t concerned with the relative
	// balance of rarity abilities, you can ignore these variable costs. If so,
	// spend 3 experience points to purchase a rarity.
	XpCost int16 `json:"xp_cost"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []RarityIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`
}

// A unique ID representing a Rarity object.
type RarityID = string

// A wildcarded RarityId that can be used to match multiple Rarity objects.
type RarityIDWildcard = string

// Provides a value like a stat, condition meter, or other number (usually for
// use in an action roll). The expected value is an integer, or null.
type RollableValue struct {
	Using string

	AssetControl RollableValueAssetControl

	AssetOption RollableValueAssetOption

	AttachedAssetControl RollableValueAttachedAssetControl

	AttachedAssetOption RollableValueAttachedAssetOption

	ConditionMeter RollableValueConditionMeter

	Custom RollableValueCustom

	Stat RollableValueStat
}

func (v RollableValue) MarshalJSON() ([]byte, error) {
	switch v.Using {
	case "asset_control":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAssetControl }{ v.Using, v.AssetControl })
	case "asset_option":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAssetOption }{ v.Using, v.AssetOption })
	case "attached_asset_control":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAttachedAssetControl }{ v.Using, v.AttachedAssetControl })
	case "attached_asset_option":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAttachedAssetOption }{ v.Using, v.AttachedAssetOption })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"using"`; RollableValueConditionMeter }{ v.Using, v.ConditionMeter })
	case "custom":
		return json.Marshal(struct { T string `json:"using"`; RollableValueCustom }{ v.Using, v.Custom })
	case "stat":
		return json.Marshal(struct { T string `json:"using"`; RollableValueStat }{ v.Using, v.Stat })
	}

	return nil, fmt.Errorf("bad Using value: %s", v.Using)
}

func (v *RollableValue) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"using"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "asset_control":
		err = json.Unmarshal(b, &v.AssetControl)
	case "asset_option":
		err = json.Unmarshal(b, &v.AssetOption)
	case "attached_asset_control":
		err = json.Unmarshal(b, &v.AttachedAssetControl)
	case "attached_asset_option":
		err = json.Unmarshal(b, &v.AttachedAssetOption)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "custom":
		err = json.Unmarshal(b, &v.Custom)
	case "stat":
		err = json.Unmarshal(b, &v.Stat)
	default:
		err = fmt.Errorf("bad Using value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Using = t.T
	return nil
}

// A reference to the value of an asset control.
type RollableValueAssetControl struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`
}

// A reference to the value of an asset option.
type RollableValueAssetOption struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`
}

// A reference to the value of an attached asset control. For example, a Module
// asset could use this to roll using the `integrity` control of an attached
// Vehicle.
type RollableValueAttachedAssetControl struct {
	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`
}

// A reference to the value of an attached asset option.
type RollableValueAttachedAssetOption struct {
	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`
}

// A reference to the value of a standard player condition meter.
type RollableValueConditionMeter struct {
	ConditionMeter ConditionMeterKey `json:"condition_meter"`
}

// An arbitrary static integer value with a label.
type RollableValueCustom struct {
	Label Label `json:"label"`

	Value int16 `json:"value"`
}

// A reference to the value of a standard player character stat.
type RollableValueStat struct {
	Stat StatKey `json:"stat"`
}

// Describes rules for player characters in this ruleset, such as stats and
// condition meters.
type Rules struct {
	// Describes the standard condition meters used by player characters in this
	// ruleset.
	ConditionMeters map[string]ConditionMeterRule `json:"condition_meters"`

	// Describes the standard impacts/debilities used by player characters in this
	// ruleset.
	Impacts map[string]ImpactCategory `json:"impacts"`

	// Describes the special tracks used by player characters in this ruleset, like
	// Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
	SpecialTracks map[string]SpecialTrackRule `json:"special_tracks"`

	// Describes the standard stats used by player characters in this ruleset.
	Stats map[string]StatRule `json:"stats"`

	Tags map[string]TagRule `json:"tags"`
}

// Describes rules for player characters in this ruleset, such as stats and
// condition meters.
type RulesExpansion struct {
	// Describes the standard condition meters used by player characters in this
	// ruleset.
	ConditionMeters map[string]ConditionMeterRule `json:"condition_meters,omitempty"`

	// Describes the standard impacts/debilities used by player characters in this
	// ruleset.
	Impacts map[string]ImpactCategory `json:"impacts,omitempty"`

	// Describes the special tracks used by player characters in this ruleset, like
	// Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
	SpecialTracks map[string]SpecialTrackRule `json:"special_tracks,omitempty"`

	// Describes the standard stats used by player characters in this ruleset.
	Stats map[string]StatRule `json:"stats,omitempty"`

	Tags map[string]TagRule `json:"tags,omitempty"`
}

type RulesPackageID = string

// The version of the Datasworn format used by this data.
type RulesetDataswornVersion string

const (
	RulesetDataswornVersion0 RulesetDataswornVersion = "0.1.0"
)

type RulesetType string

const (
	RulesetTypeRuleset RulesetType = "ruleset"
)

// A standalone Datasworn package that describes its own ruleset.
type Ruleset struct {
	ID RulesetID `json:"_id"`

	// A dictionary object containing asset collections, which contain assets.
	Assets map[string]AssetCollection `json:"assets"`

	// Lists authors credited by the source material.
	Authors []AuthorInfo `json:"authors"`

	// The version of the Datasworn format used by this data.
	DataswornVersion RulesetDataswornVersion `json:"datasworn_version"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date time.Time `json:"date"`

	License WebURL `json:"license"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleTablesCollection `json:"oracles"`

	Rules Rules `json:"rules"`

	// The title of the source document.
	Title Label `json:"title"`

	Type RulesetType `json:"type"`

	// A URL where the source document is available.
	URL WebURL `json:"url"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]AtlasCollection `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

// The ID of standalone Datasworn package that describes its own ruleset.
type RulesetID = string

type SelectEnhancementFieldChoice0 struct {
	ChoiceType string

	Choice SelectEnhancementFieldChoiceChoice

	ChoiceGroup SelectEnhancementFieldChoiceChoiceGroup
}

func (v SelectEnhancementFieldChoice0) MarshalJSON() ([]byte, error) {
	switch v.ChoiceType {
	case "choice":
		return json.Marshal(struct { T string `json:"choice_type"`; SelectEnhancementFieldChoiceChoice }{ v.ChoiceType, v.Choice })
	case "choice_group":
		return json.Marshal(struct { T string `json:"choice_type"`; SelectEnhancementFieldChoiceChoiceGroup }{ v.ChoiceType, v.ChoiceGroup })
	}

	return nil, fmt.Errorf("bad ChoiceType value: %s", v.ChoiceType)
}

func (v *SelectEnhancementFieldChoice0) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"choice_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "choice":
		err = json.Unmarshal(b, &v.Choice)
	case "choice_group":
		err = json.Unmarshal(b, &v.ChoiceGroup)
	default:
		err = fmt.Errorf("bad ChoiceType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.ChoiceType = t.T
	return nil
}

// Represents an option in a list of choices.
type SelectEnhancementFieldChoiceChoice struct {
	Label Label `json:"label"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents a grouping of options in a list of choices.
type SelectEnhancementFieldChoiceChoiceGroup struct {
	Choices map[string]SelectEnhancementFieldChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

type SelectEnhancementFieldFieldType string

const (
	SelectEnhancementFieldFieldTypeSelectEnhancement SelectEnhancementFieldFieldType = "select_enhancement"
)

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type SelectEnhancementField struct {
	Choices map[string]SelectEnhancementFieldChoice0 `json:"choices"`

	FieldType SelectEnhancementFieldFieldType `json:"field_type"`

	Label Label `json:"label"`

	Value DictKey `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type SelectEnhancementFieldChoiceChoiceType string

const (
	SelectEnhancementFieldChoiceChoiceTypeChoice SelectEnhancementFieldChoiceChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectEnhancementFieldChoice struct {
	ChoiceType SelectEnhancementFieldChoiceChoiceType `json:"choice_type"`

	Label Label `json:"label"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

type SelectEnhancementFieldChoiceGroupChoiceType string

const (
	SelectEnhancementFieldChoiceGroupChoiceTypeChoiceGroup SelectEnhancementFieldChoiceGroupChoiceType = "choice_group"
)

// Represents a grouping of options in a list of choices.
type SelectEnhancementFieldChoiceGroup struct {
	ChoiceType SelectEnhancementFieldChoiceGroupChoiceType `json:"choice_type"`

	Choices map[string]SelectEnhancementFieldChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

type SelectValueFieldFieldType string

const (
	SelectValueFieldFieldTypeSelectValue SelectValueFieldFieldType = "select_value"
)

// Represents a list of mutually exclusive choices.
type SelectValueField struct {
	Choices map[string]SelectValueFieldChoice `json:"choices"`

	FieldType SelectValueFieldFieldType `json:"field_type"`

	Label Label `json:"label"`

	Value DictKey `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

type SelectValueFieldChoice struct {
	Using string

	AssetControl SelectValueFieldChoiceAssetControl

	AssetOption SelectValueFieldChoiceAssetOption

	AttachedAssetControl SelectValueFieldChoiceAttachedAssetControl

	AttachedAssetOption SelectValueFieldChoiceAttachedAssetOption

	ConditionMeter SelectValueFieldChoiceConditionMeter

	Custom SelectValueFieldChoiceCustom

	Stat SelectValueFieldChoiceStat
}

func (v SelectValueFieldChoice) MarshalJSON() ([]byte, error) {
	switch v.Using {
	case "asset_control":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceAssetControl }{ v.Using, v.AssetControl })
	case "asset_option":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceAssetOption }{ v.Using, v.AssetOption })
	case "attached_asset_control":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceAttachedAssetControl }{ v.Using, v.AttachedAssetControl })
	case "attached_asset_option":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceAttachedAssetOption }{ v.Using, v.AttachedAssetOption })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceConditionMeter }{ v.Using, v.ConditionMeter })
	case "custom":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceCustom }{ v.Using, v.Custom })
	case "stat":
		return json.Marshal(struct { T string `json:"using"`; SelectValueFieldChoiceStat }{ v.Using, v.Stat })
	}

	return nil, fmt.Errorf("bad Using value: %s", v.Using)
}

func (v *SelectValueFieldChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"using"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "asset_control":
		err = json.Unmarshal(b, &v.AssetControl)
	case "asset_option":
		err = json.Unmarshal(b, &v.AssetOption)
	case "attached_asset_control":
		err = json.Unmarshal(b, &v.AttachedAssetControl)
	case "attached_asset_option":
		err = json.Unmarshal(b, &v.AttachedAssetOption)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "custom":
		err = json.Unmarshal(b, &v.Custom)
	case "stat":
		err = json.Unmarshal(b, &v.Stat)
	default:
		err = fmt.Errorf("bad Using value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Using = t.T
	return nil
}

type SelectValueFieldChoiceAssetControlChoiceType string

const (
	SelectValueFieldChoiceAssetControlChoiceTypeChoice SelectValueFieldChoiceAssetControlChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceAssetControl struct {
	Assets []AssetIDWildcard `json:"assets"`

	ChoiceType SelectValueFieldChoiceAssetControlChoiceType `json:"choice_type"`

	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`

	Label Label `json:"label"`
}

type SelectValueFieldChoiceAssetOptionChoiceType string

const (
	SelectValueFieldChoiceAssetOptionChoiceTypeChoice SelectValueFieldChoiceAssetOptionChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceAssetOption struct {
	Assets []AssetIDWildcard `json:"assets"`

	ChoiceType SelectValueFieldChoiceAssetOptionChoiceType `json:"choice_type"`

	Label Label `json:"label"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`
}

type SelectValueFieldChoiceAttachedAssetControlChoiceType string

const (
	SelectValueFieldChoiceAttachedAssetControlChoiceTypeChoice SelectValueFieldChoiceAttachedAssetControlChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceAttachedAssetControl struct {
	ChoiceType SelectValueFieldChoiceAttachedAssetControlChoiceType `json:"choice_type"`

	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`

	Label Label `json:"label"`
}

type SelectValueFieldChoiceAttachedAssetOptionChoiceType string

const (
	SelectValueFieldChoiceAttachedAssetOptionChoiceTypeChoice SelectValueFieldChoiceAttachedAssetOptionChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceAttachedAssetOption struct {
	ChoiceType SelectValueFieldChoiceAttachedAssetOptionChoiceType `json:"choice_type"`

	Label Label `json:"label"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`
}

type SelectValueFieldChoiceConditionMeterChoiceType string

const (
	SelectValueFieldChoiceConditionMeterChoiceTypeChoice SelectValueFieldChoiceConditionMeterChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceConditionMeter struct {
	ChoiceType SelectValueFieldChoiceConditionMeterChoiceType `json:"choice_type"`

	ConditionMeter ConditionMeterKey `json:"condition_meter"`

	Label Label `json:"label"`
}

type SelectValueFieldChoiceCustomChoiceType string

const (
	SelectValueFieldChoiceCustomChoiceTypeChoice SelectValueFieldChoiceCustomChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceCustom struct {
	ChoiceType SelectValueFieldChoiceCustomChoiceType `json:"choice_type"`

	Label Label `json:"label"`

	Value int16 `json:"value"`
}

type SelectValueFieldChoiceStatChoiceType string

const (
	SelectValueFieldChoiceStatChoiceTypeChoice SelectValueFieldChoiceStatChoiceType = "choice"
)

// Represents an option in a list of choices.
type SelectValueFieldChoiceStat struct {
	ChoiceType SelectValueFieldChoiceStatChoiceType `json:"choice_type"`

	Label Label `json:"label"`

	Stat StatKey `json:"stat"`
}

type SemanticVersion = string

// Metadata describing the original source of this node
type SourceInfo struct {
	// Lists authors credited by the source material.
	Authors []AuthorInfo `json:"authors"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date time.Time `json:"date"`

	License WebURL `json:"license"`

	// The title of the source document.
	Title Label `json:"title"`

	// A URL where the source document is available.
	URL WebURL `json:"url"`

	// The page number where this content is described in full.
	Page *PageNumber `json:"page,omitempty"`
}

type SpecialTrackRollMethod string

const (
// Use _every_ roll option at once.
	SpecialTrackRollMethodAll SpecialTrackRollMethod = "all"

// Use the roll option with the best/highest value.
	SpecialTrackRollMethodHighest SpecialTrackRollMethod = "highest"

// Use the roll option with the worst/lowest value.
	SpecialTrackRollMethodLowest SpecialTrackRollMethod = "lowest"

// An automatic miss.
	SpecialTrackRollMethodMiss SpecialTrackRollMethod = "miss"

// The player chooses which roll option to use.
	SpecialTrackRollMethodPlayerChoice SpecialTrackRollMethod = "player_choice"

// An automatic strong hit.
	SpecialTrackRollMethodStrongHit SpecialTrackRollMethod = "strong_hit"

// An automatic weak hit.
	SpecialTrackRollMethodWeakHit SpecialTrackRollMethod = "weak_hit"
)

// Describes a special track like Bonds (classic Ironsworn), Failure (Delve), or
// Legacies (Starforged).
type SpecialTrackRule struct {
	// A description of this special track.
	Description MarkdownString `json:"description"`

	// A label for this special track.
	Label Label `json:"label"`

	// Is this track an optional rule?
	Optional bool `json:"optional"`

	// Is this track shared by all players?
	Shared bool `json:"shared"`
}

// Special, ruleset-specific progress tracks. Usually, one exists per player
// character, and they persist through the life of the player character.
// 'Canonical' examples:
//   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
// legacy track, use `bonds_legacy` instead.
//   * `failure_track`, described in Ironsworn: Delve
//   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
// Ironsworn: Starforged
// 
type SpecialTrackType = DictKey

// A basic player character stat.
type StatKey = DictKey

// Describes a standard player character stat.
type StatRule struct {
	// A description of this stat.
	Description MarkdownString `json:"description"`

	// A label for this stat.
	Label Label `json:"label"`
}

// A reference to the value of a standard player character stat.
type StatValueRefUsing string

const (
	StatValueRefUsingStat StatValueRefUsing = "stat"
)

// A reference to the value of a standard player character stat.
type StatValueRef struct {
	Stat StatKey `json:"stat"`

	// A reference to the value of a standard player character stat.
	Using StatValueRefUsing `json:"using"`
}

type Suggestions = []AnyIDWildcard

// A relative (local) URL pointing to a vector image in the SVG format.
type SvgImageURL = string

type Tag = interface{}

type TagRule struct {
	// The JSON schema for this tag value.
	Schema TagSchema `json:"$schema"`

	NodeTypes []TaggableNodeType `json:"node_types"`
}

// JSON schema used to validate the tag data, with a mandatory description. Only
// a subset of all possible JSON schema are allowed, including references to
// some Datasworn types.
type TagSchema = interface{}

type TaggableNodeType string

const (
	TaggableNodeTypeAbility TaggableNodeType = "ability"

	TaggableNodeTypeAsset TaggableNodeType = "asset"

	TaggableNodeTypeAssetCollection TaggableNodeType = "asset_collection"

	TaggableNodeTypeAtlasCollection TaggableNodeType = "atlas_collection"

	TaggableNodeTypeAtlasEntry TaggableNodeType = "atlas_entry"

	TaggableNodeTypeDanger TaggableNodeType = "danger"

	TaggableNodeTypeDelveSite TaggableNodeType = "delve_site"

	TaggableNodeTypeDelveSiteDomain TaggableNodeType = "delve_site_domain"

	TaggableNodeTypeDelveSiteTheme TaggableNodeType = "delve_site_theme"

	TaggableNodeTypeDenizen TaggableNodeType = "denizen"

	TaggableNodeTypeFeature TaggableNodeType = "feature"

	TaggableNodeTypeMove TaggableNodeType = "move"

	TaggableNodeTypeMoveCategory TaggableNodeType = "move_category"

	TaggableNodeTypeNpc TaggableNodeType = "npc"

	TaggableNodeTypeNpcCollection TaggableNodeType = "npc_collection"

	TaggableNodeTypeOption TaggableNodeType = "option"

	TaggableNodeTypeOracleCollection TaggableNodeType = "oracle_collection"

	TaggableNodeTypeOracleRollable TaggableNodeType = "oracle_rollable"

	TaggableNodeTypeRarity TaggableNodeType = "rarity"

	TaggableNodeTypeRow TaggableNodeType = "row"

	TaggableNodeTypeTruth TaggableNodeType = "truth"

	TaggableNodeTypeVariant TaggableNodeType = "variant"
)

// A dictionary of tags, keyed by the RulesPackageId that the tags are from.
type Tags = map[string]map[string]Tag

type TextFieldFieldType string

const (
	TextFieldFieldTypeText TextFieldFieldType = "text"
)

// Represents an input that accepts plain text.
type TextField struct {
	FieldType TextFieldFieldType `json:"field_type"`

	Label Label `json:"label"`

	Value string `json:"value"`

	// An icon associated with this input.
	Icon *SvgImageURL `json:"icon,omitempty"`
}

// Describes trigger conditions for a move that makes an action roll.
type TriggerActionRoll struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerActionRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerActionRollCondition struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []RollableValue `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerActionRollConditionEnhancement struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []RollableValue `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerActionRollEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerActionRollConditionEnhancement `json:"conditions"`
}

// Information on who can activate this trigger condition. Usually this is just
// the player, but some asset abilities can trigger from an ally's move.
type TriggerBy struct {
	// Can this trigger be activated by one of the player's allies?
	Ally bool `json:"ally"`

	// Can this trigger be activated by the player who owns this?
	Player bool `json:"player"`
}

// Describes trigger conditions for a move that makes no rolls.
type TriggerNoRoll struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerNoRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerNoRollCondition struct {
	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerNoRollEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerNoRollCondition `json:"conditions"`
}

type TriggerProgressRoll struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerProgressRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerProgressRollCondition struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerProgressRollConditionEnhancement struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerProgressRollEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerProgressRollConditionEnhancement `json:"conditions"`
}

type TriggerSpecialTrack struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerSpecialTrackCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerSpecialTrackCondition struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacy (Starforged).
type TriggerSpecialTrackConditionEnhancement struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerSpecialTrackConditionOption struct {
	Using SpecialTrackType `json:"using"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerSpecialTrackEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerSpecialTrackConditionEnhancement `json:"conditions"`
}

type TruthType string

const (
	TruthTypeTruth TruthType = "truth"
)

// A setting truth category.
type Truth struct {
	// The unique Datasworn ID for this node.
	ID TruthID `json:"_id"`

	// Attribution for the original source (such as a book or website) of this
	// node, including the author and licensing information.
	Source SourceInfo `json:"_source"`

	Dice DiceExpression `json:"dice"`

	// The primary name/label for this node.
	Name Label `json:"name"`

	Options []TruthOption `json:"options"`

	Type TruthType `json:"type"`

	Comment *Documentation `json:"_comment,omitempty"`

	// The name of this node as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this node.
	Color *CSSColor `json:"color,omitempty"`

	// Prompts for factions related to this truth, like those presented in standard
	// isles. This is presented as a single paragraph in the original text;
	// Datasworn uses an array (one faction prompt per string) to represent them in
	// order to make them more suitable for programmatic use.
	// 
	// This property is a placeholder and may see signficant changes in v0.2.0.
	Factions []EntityPrompt `json:"factions,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This node replaces all nodes that match these wildcards. References to the
	// replaced nodes can be considered equivalent to this node.
	Replaces []TruthIDWildcard `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Tags *Tags `json:"tags,omitempty"`

	YourCharacter *MarkdownString `json:"your_character,omitempty"`
}

// A unique ID representing a Truth object.
type TruthID = string

// A wildcarded TruthId that can be used to match multiple Truth objects.
type TruthIDWildcard = string

type TruthOption struct {
	// The unique Datasworn ID for this node.
	ID TruthOptionID `json:"_id"`

	Description MarkdownString `json:"description"`

	QuestStarter MarkdownString `json:"quest_starter"`

	Roll DiceRange `json:"roll"`

	Comment *Documentation `json:"_comment,omitempty"`

	Oracles map[string]EmbeddedOracleRollable `json:"oracles,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID representing a TruthOption object.
type TruthOptionID = string

// A wildcarded TruthOptionId that can be used to match multiple TruthOption
// objects.
type TruthOptionIDWildcard = string

// A unique ID representing a TruthOptionOracleRollable object.
type TruthOptionOracleRollableID = string

// A wildcarded TruthOptionOracleRollableId that can be used to match multiple
// TruthOptionOracleRollable objects.
type TruthOptionOracleRollableIDWildcard = string

// A unique ID representing a TruthOptionOracleRollableRow object.
type TruthOptionOracleRollableRowID = string

// A wildcarded TruthOptionOracleRollableRowId that can be used to match
// multiple TruthOptionOracleRollableRow objects.
type TruthOptionOracleRollableRowIDWildcard = string

// An absolute URL pointing to a website.
type WebURL = string

// A relative (local) URL pointing to a raster image in the WEBP format.
type WebpImageURL = string
